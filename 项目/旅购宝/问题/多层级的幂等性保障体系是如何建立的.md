
## 接口层幂等性保障

在接口层，我们实现了基于Token+Redis的防重提交机制：

1. **接口防重令牌**：用户发起关键操作（如支付、下单）前，先向服务端申请一个具有时效性的幂等Token，该Token与用户ID、操作类型绑定并存储在Redis中。
   
2. **请求拦截验证**：通过自定义拦截器对含幂等性要求的接口进行拦截，验证请求中携带的Token是否有效。验证通过后，立即从Redis中删除该Token，保证同一Token只能使用一次。

3. **时效性控制**：为Token设置合理的过期时间，既保证用户有足够时间完成操作，又能避免长期占用系统资源。

这种机制有效防止了表单重复提交、页面刷新重复操作等问题，特别适用于支付、下单等关键业务场景。

## 服务层幂等性保障

服务层主要通过分布式锁和原子操作来保证幂等性：

1. **Redisson分布式锁**：利用Redisson框架实现的分布式锁，确保在集群环境下同一时间只有一个服务实例能处理相同业务标识的请求。在支付回调、秒杀等高并发场景特别有效。

2. **Lua脚本保证原子性**：将检查与更新操作封装在Lua脚本中，利用Redis的单线程特性，确保检查和执行是一个不可分割的原子操作。如秒杀扣减库存场景，通过一次Lua脚本执行同时完成库存检查和扣减。

3. **状态机严格控制**：订单系统中实现了严格的状态机，明确定义了各状态间的合法转换路径。每次状态变更前，先验证当前状态是否允许向目标状态转换，确保订单状态的一致性。

4. **业务号去重**：使用业务唯一标识（如订单号、交易流水号等）结合Redis缓存，快速判断请求是否重复。例如支付回调处理中，先检查支付记录状态，已处理则直接返回成功，避免重复处理。

## 数据层幂等性保障

数据层作为最后一道防线，通过数据库特性确保数据一致性：

1. **唯一约束**：在数据库表设计中，为业务关键字段（如订单号、交易流水号、优惠券核销码等）设置唯一索引约束，从数据库层面阻止重复数据的写入。

2. **乐观锁机制**：在高并发场景（如库存更新）中，使用版本号或条件更新实现乐观锁。例如，秒杀券库存更新时，SQL中添加库存大于0的条件，既能防止超卖，又能避免重复扣减。

3. **事务特性保障**：利用数据库事务的ACID特性，确保复杂业务逻辑的原子执行。特别是在订单取消需要恢复库存等场景，通过事务保证数据一致性。

4. **多表关联约束**：通过外键或应用层约束，确保关联数据的一致性，避免出现"半状态"数据。

## 应用价值与成效

多层级幂等性保障体系的建立，为系统带来了显著的稳定性提升：

1. 成功应对了业务高峰期的并发请求，保证了交易数据的准确性
2. 降低了因重复操作导致的数据不一致问题，减少了人工干预处理的次数
3. 提高了系统的容错能力，即使在网络不稳定的情况下，也能保证业务正确执行
4. 简化了业务代码中的异常处理逻辑，提高了开发效率

这种多层级的幂等性设计思想，可以作为分布式系统设计的最佳实践，应用到更广泛的业务场景中。