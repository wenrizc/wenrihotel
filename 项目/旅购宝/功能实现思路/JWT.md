
通过分析代码可以看到，HMDP项目目前使用的是基于Redis存储的会话管理方案：

1. 用户提交手机号获取验证码，验证码保存在Redis中（`LOGIN_CODE_KEY + phone`）
2. 用户登录时验证手机号和验证码
3. 登录成功后：
    - 生成随机UUID作为token
    - 将用户信息转为Map存入Redis（`LOGIN_USER_KEY + token`）
    - 设置token过期时间（30分钟）
4. 通过两层拦截器实现认证：
    - `RefreshTokenInterceptor`：获取并解析token，加载用户信息，刷新token有效期
    - LoginInterceptor：拦截需要登录的接口，检查用户信息是否存在

## JWT替换方案设计

### 1. JWT结构设计

设计JWT的三个部分：

- **Header**：指定算法和token类型
- **Payload**：存储用户信息，包含：
    - 用户ID 
    - 昵称
    - 标准声明（如过期时间`exp`、签发时间`iat`等）
- **Signature**：签名，确保token未被篡改

### 2. 登录流程改造

1. **发送验证码流程不变**
    
    - 仍使用Redis存储验证码及其过期时间
2. **登录接口改造**
    
    - 验证手机号和验证码
    - 检查用户是否存在，不存在则创建
    - 使用JWT库生成token，包含用户关键信息
    - 直接返回token给客户端，无需存储在Redis
3. **登出接口改造**
    
    - 可选方案1：由于JWT是无状态的，客户端丢弃token即可
    - 可选方案2：将token加入黑名单（需要Redis支持）

### 3. 拦截器体系改造

1. **修改[RefreshTokenInterceptor]
    - 从请求头或Cookie获取JWT token
    - 验证token签名和有效期
    - 解析token获取用户信息并存入UserHolder
    - 无需刷新token（JWT是无状态的）
2. **保留[LoginInterceptor]逻辑**
    - 检查UserHolder中是否存在用户信息
    - 不存在则返回401错误

### 4. JWT续期策略

由于JWT一旦签发不可更改，可采用以下续期策略：

1. **短效令牌+长效刷新令牌**
    
    - 签发短期JWT（如30分钟）
    - 同时签发一个长期有效的刷新令牌（如7天）
    - 客户端在JWT即将过期时使用刷新令牌获取新JWT
2. **滑动窗口**
    
    - 在每次请求时检查JWT剩余有效期
    - 如果剩余时间少于某个阈值（如5分钟），签发新的JWT
    - 服务端维护一个最小有效期窗口

### 5. 安全考虑

1. **密钥管理**
    
    - 使用安全的密钥存储方案
    - 考虑定期轮换密钥
    - 在配置文件中设置强健的密钥
2. **黑名单机制**
    
    - 为支持主动登出和撤销，可维护一个token黑名单
    - 在Redis中存储已撤销的token ID或JTI
    - 拦截器中检查token是否在黑名单中
3. **载荷设计**
    
    - 仅包含必要信息，避免敏感数据
    - 添加jti（JWT ID）以支持撤销
    - 设置适当的nbf（生效时间）和exp（过期时间）

### 6. 客户端适配

1. 调整前端存储token的方式（localStorage或Cookie）
2. 配置请求拦截器，在每个请求头中添加token
3. 实现token无感刷新机制
4. 处理token过期的重定向逻辑

### 7. 性能优化

1. **减少解密验证开销**
    
    - 对不需要验证的公开接口跳过JWT验证
    - 考虑在本地缓存已解析的JWT（注意安全隐患）
2. **负载均衡友好**
    
    - JWT天然支持分布式系统，无需共享会话状态
    - 多节点部署时无需会话同步