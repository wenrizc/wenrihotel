
#### 1. 上行消息处理
*   **流程**：客户端发送消息 -> API Server ->（通过消息队列 MQ）-> Msg Server 进行异步存储。
*   **关键点**：异步处理提升系统吞吐量和响应速度；MQ 解耦 API Server 和 Msg Server。

#### 2. 下行消息推送
*   **流程**：API Server 根据消息中的 `to_user_id` -> 查询 User Server 获取接收方详细信息 -> 打包下行消息 -> 接入层 (Gateway/Connection Server) -> 推送给目标用户。
*   **关键点**：准确的用户定位和信息获取。

#### 3. 群聊消息处理
*   **流程**：API Server -> 调用 Relation Server (根据 `sessionID` 查询群成员 `DID List`，排除发送者) -> 逐条为群成员打包下行消息 -> 接入层 -> 推送给各群成员。
*   **关键点**：高效的群成员查询；消息扇出逻辑。

#### 4. 多设备登录与消息同步
*   **登录**：用户某设备 (DID) 登录 -> 接入层通知 API Server (`userID` 及 `DID` 信息) -> API Server 将 `userID` 与 `DID` 的绑定关系注册到 Relation Server。
*   **同步**：API Server 发送下行消息时 -> Relation Server (查询 `userID` 下关联的所有在线 `DID List`) -> 为每个 `DID` 打包独立的下行消息 -> 接入层 -> 推送给用户各在线设备。
*   **约束**：需对单个 `userID` 允许绑定的 `DID` (设备) 数量进行限制。

#### 5. 在线状态同步
*   **流程**：用户上线/下线 -> 接入层通知 API Server -> API Server 查询 Relation Server (获取该用户的所有好友列表) -> 向其所有在线好友推送该用户的状态更新通知。
*   **关键点**：状态变更的实时性；好友关系的高效查询。

#### 6. 多媒体消息处理
*   **上传**：客户端先将文件（图片、音视频等）上传至云存储服务 (如 S3, OSS) -> 获取文件 URL。
*   **发送**：客户端将文件 URL 及自定义多媒体消息类型封装后，作为普通消息发送至 IM 系统。
*   **设计**：IM 系统需定义标准化的多媒体消息格式，以支持未来的业务扩展（如缩略图、时长、文件大小等元数据）。

#### 7. 消息漫游、历史消息拉取与离线补偿
*   **拉取机制**：客户端通过 HTTP 接口向 API Server 请求指定会话 (`session`) 的历史消息。
*   **分页与定位**：使用消息序列号 (`seqID`) 作为分页或定位锚点。客户端上报当前已拉取的最大 `seqID`，服务端据此返回例如最近20条消息。
*   **离线提示**：服务端可告知客户端在离线期间（或自上次拉取后）有多少条新消息未被拉取。
*   **反复拉取**：基于 `seqID` 作为偏移量 (offset) 或游标 (cursor) 实现历史消息的持续拉取。

#### 8. 消息撤回
*   **发起**：发送者客户端向接入层发送特定消息的撤回指令。
*   **处理**：API Server 接收指令 -> 在 Msg Server 中为对应消息打上“已删除”标记（逻辑删除或物理删除，取决于策略），并同步修改离线缓存中的消息状态 -> 将撤回通知推送给会话内所有相关成员（包括发送者自己其他设备）。
*   **客户端响应**：客户端收到撤回通知后，在本地删除或替换对应消息的显示。
*   **一致性**：确保后续历史消息拉取时，已撤回的消息不再可见或显示为“已撤回”。

#### 9. 消息已读/未读状态
*   **上报**：客户端主动上报已读事件（例如，用户点开某个会话，该会话内所有消息标记为已读，或精确到某条消息的已读 `seqID`）。建议通过 HTTP 短连接接口上报，以减轻长连接网关的带宽压力。
*   **处理与同步**：API Server (或专门的已读状态服务) 接收并处理已读事件 -> 更新消息的已读状态 (通常在 Msg Server 或专门的读扩散库) -> 将已读回执信息通过接入层推送给会话内的其他相关成员，以便其客户端更新未读计数和消息状态。

#### 10. 关系链管理 (添加好友、会话列表、好友列表)
*   **添加好友**：用户发起添加好友请求 -> API Server 操作 Relation Server，记录或更新用户间的双向/单向好友关系。
*   **会话创建/管理**：当用户首次与另一用户或群组开始聊天时，API Server (或 Msg Server) 负责创建新的会话 (`session`) 实体。会话列表由客户端按需拉取。
*   **列表获取**：客户端可通过 API Server 拉取好友列表、群组列表、会话列表等。这些数据主要源自 Relation Server (关系数据) 和 Msg Server (会话元数据，如最后一条消息、未读数等)。

---

### 二、架构考量与风险点：

#### 1. 架构目标
*   当前设计的微服务架构，目标是能够支撑**百万级别日活跃用户 (DAU)** 的规模，并完整覆盖上述所有核心业务需求。

#### 2. 主要风险点与挑战 (消息风暴及其他)

*   **在线状态同步风暴**：
    *   **问题**：用户好友数量庞大时（如KOL、明星用户），其上线/下线状态推送会瞬间产生大量消息，形成“消息风暴”。弱网环境下用户频繁掉线重连会加剧此问题。
    *   **考虑**：状态聚合推送、延迟推送、只推送给关心其状态的好友（如双向关注）、客户端按需拉取等优化策略。

*   **多媒体消息处理**：
    *   **安全风险**：用户上传的图片、音视频等可能涉及色情、暴力、诈骗等非法内容，存在“黑产”利用风险。需引入内容审核机制（AI审核+人工审核）。
    *   **存储成本**：大量二进制文件的存储和重复上传会导致高昂的存储成本和带宽成本。需考虑文件去重、生命周期管理、冷热数据分离等策略。

*   **历史消息拉取**：
    *   **存储与性能压力**：若允许用户无限制拉取全部历史消息，将对数据库/存储系统的容量、查询性能带来巨大挑战和成本。
    *   **考虑**：限制拉取深度（如最近N个月）、冷数据归档、分级存储、优化查询索引。

*   **消息撤回机制**：
    *   **群聊场景下的扩散**：在大型群聊中，一条消息撤回通知仍可能触达大量用户，形成小型“消息风暴”。
    *   **数据一致性**：修改离线消息存储（如数据库）时，需妥善处理并发操作，避免竞态条件，确保数据最终一致性（例如，用户A刚拉取完历史消息，消息B就被撤回，用户A本地如何更新）。

*   **已读回执处理**：
    *   **频繁传播**：已读状态的上报和通知在活跃群聊中会非常频繁，对系统的消息处理能力、网络带宽、客户端性能均构成压力。
    *   **低延迟与一致性**：保证已读状态在多端之间及时、准确地同步是一个技术挑战，尤其是在网络不稳定的情况下。
    *   **考虑**：已读回执聚合上报、延迟推送、按需拉取、优化读扩散模型。

*   **关系链服务 (Relation Server)**：
    *   **存储与性能**：需要存储海量的用户关系数据（好友关系、群组成员关系等），对存储容量、数据可靠性、查询（如图遍历）低延迟要求极高。
    *   **扩展性**：若设计为单体服务，将难以水平扩展，成为系统瓶颈，技术和维护成本巨大。
    *   **考虑**：采用分布式图数据库或针对关系数据优化的NoSQL数据库；服务拆分；缓存策略。
