
### **多维历史时间轴功能实现思路**

我们的核心目标是：用户输入一个事件名，系统能够智能地生成并展示一个包含多个并行视角的时间轴。整个过程可以看作一个从用户请求到数据呈现的“信息处理流水线”。

#### **第一阶段：请求的发起与前端的准备工作**

1. **用户交互的起点：**
    
    - 整个流程始于用户在前端界面输入框中键入一个历史事件，例如“淝水之战”，然后点击“生成时间轴”按钮。
        
2. **前端的即时响应与“信件”打包：**
    
    - 在向后端发送信息之前，前端的第一要务是管理用户体验。它会立刻让界面进入“加载”状态，比如显示一个旋转的图标或骨架屏。这告诉用户：“正在生成时间轴。”
        
    - 接着，前端将用户的输入（“淝水之战”）包装成一个结构化、标准化的“信件”（一个简单的JSON对象），准备发往后端。这封信的内容很简单，大致是：`{ "事件名称": "淝水之战" }`。
        
    - 前端将这封信发送到后端一个指定的地址（API端点）。完成这一步后，前端的工作暂时告一段落，它开始静静等待后端的回复。
        

#### **第二阶段：后端的智能决策与核心处理**

后端是这条流水线的大脑，它需要进行一系列有策略的判断和操作。

1. **接收请求与“记忆检索”：**
    
    - 后端的“接收站”（API控制器）收到了前端发来的信件。
        
    - 在做任何复杂工作之前，后端会先执行一个关键的“记忆检索”步骤，即**检查缓存**。它会问自己：“关于‘淝水之战’，我以前处理过吗？”
        
    - 这个“记忆”就是我们的数据库。后端会去表里查找是否存在名为“淝水之- 战”的记录。
        
2. **两条路径的选择：**
    
    - **路径A：命中缓存（在记忆中找到了）**
        
        - 如果找到了记录，说明这个事件的完整时间轴数据已经存在数据库中。
            
        - 后端的任务就变得非常简单，像一个图书管理员去书架上取一本整理好的书。它会根据找到的事件ID，去另外两张表中抓取所有相关的子轴和子事件数据。
            
        - 然后，它在内部将这些零散的数据重新组装成前端期望的、完整的、结构化的JSON格式。
            
        - 最后，直接将这个组装好的JSON“回复”给前端。整个过程快速、高效且成本低。
            
    - **路径B：未命中缓存（全新的请求）**
        
        - 如果在数据库中没有找到记录，后端知道这是一个全新的任务，需要启动“研究模式”。这时，它会将任务委托给AI。
            
3. **与AI专家的“沟通艺术”：**
    
    - 后端不会简单地把“淝水之战”这五个字扔给AI。它扮演的是一个“项目经理”的角色，需要向AI专家（大语言模型）提出一个非常具体且结构化的需求。
        
    - 它会取出一个预先设计好的“指令模板”（即我们在需求设计中提到的Prompt），然后将“事件名”填入模板中。            
        
    - 这个精心设计的指令是获取高质量、可用数据的关键。后端将这个完整的指令发送给AI服务。
        
4. **结果的验收与“归档整理”：**
    
    - AI完成分析后，会返回一个大的JSON字符串。
        
    - 后端收到后，首先会进行“验收”。它会检查返回的是不是一个合法的JSON，以及是否包含了它要求的关键部分（如`summary`、`tracks`等）。
        
    - 验收通过后，后端开始进行“归档整理”工作。它会解析这个JSON，将其中的信息分门别类，然后**一次性地**存入之前设计好的三张数据库表中（主事件、子轴、子事件）。这样做可以保证数据的完整性，也意味着下次再有同样请求时，就可以走“路径A”了。
        
5. **将研究成果交付前端：**
    
    - 在将数据存入数据库的同时，后端将从AI那里收到的、未经修改的原始JSON数据，作为本次请求的最终结果，回复给正在等待的前端。
        
