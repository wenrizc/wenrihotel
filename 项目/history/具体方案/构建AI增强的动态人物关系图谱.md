
#### **一、 核心设计哲学：构建“可溯源、有语境、可探索”的关系网络**

本系统的核心目标是构建一个动态、交互式的人物关系图谱。它并非一次性展示一张庞大而复杂的全景网络，而是允许用户从任何一个人物节点开始，通过点击交互，逐步探索和展开其关系脉络。每一次展开都应揭示人物间的具体关系（例如：师徒、血缘）。
ai调用默认返回该名字下最知名的人物，同时在用户搜索时，先调用一次ai判断返回结构化的语句历史上是否存在该知名人物

#### **二、 系统架构**

为实现上述设计哲学，我们采用前后端分离的架构，并结合双数据库模式以发挥各自的优势。

1. **前端 (Frontend)**：作为用户交互与可视化的界面。可选用 `Vue` 或 `React` 等现代框架，并集成 `AntV G6`, `D3.js`, 或 `ECharts` 等专业图表库，负责动态渲染关系图谱并处理用户的交互操作。
    
2. **后端 API 服务 (Backend)**：作为系统的业务逻辑中枢。采用java语言构建。它负责：
    
    - 处理前端发送的请求。
        
    - 根据业务逻辑，协调对 PostgreSQL 和 Neo4j 的数据操作。
        
    - 调用AI服务进行关系生成。
        
    - 整合数据并以标准格式（如JSON）返回给前端。
        
3. **数据库 (Databases)**：采用双库模式，实现事实与关系的解耦。
    
    - **事实库 (PostgreSQL)**：存储所有实体（人物）的权威、详尽信息。它是系统的数据基石和“单一事实来源”。
        
    - **关系库 (Neo4j)**：专用于存储和高效查询实体间的复杂、带语境的关系。其图结构天然适用于关系探索和网络分析。
        

#### **三、 数据模型设计**

**1. PostgreSQL 数据表定义 (`persons`)**

此表作为“事实库”，存储人物的详细档案。

- `id` (SERIAL PRIMARY KEY)：全局唯一标识符，自增主键。
    
- `name` (VARCHAR, UNIQUE, INDEXED)：人物姓名，建立唯一索引以保证姓名不重复并加速查询。
    
- `details` (JSONB)：存储人物的完整结构化信息，如生平、籍贯、主要成就等。AI生成的核心信息将存于此。
    
- `has_relationships` (BOOLEAN, DEFAULT false)：核心业务字段。`true` 表示该人物的关系网络已经由AI生成并存入Neo4j，`false` 表示尚未生成人物的关系网络。
    
- `created_at`, `updated_at` (TIMESTAMPTZ)：记录创建和最后更新时间。
    

**2. Neo4j 图模型定义**

此模型专注于关系，保持结构精简。

- **节点 (Node)**
    
    - **标签**: `Person`
        
    - **属性**:
        
        - `id` (String, UNIQUE, INDEXED)：节点的唯一标识符。此ID与PostgreSQL中 `persons` 表的 `id` 完全对应，是连接双库的核心桥梁。必须为此属性创建唯一性约束。
            
        - `name` (String)：人物姓名。此为冗余字段，主要用于图内查询和可视化时的直接展示，提升性能。
            
- 关系 (Relationship)
    
    - `IS_KIN_OF` (血缘关系)：表示 `p1` 与 `p2` 存在血缘联系。
        
    - `HAS_SUBORDINATE_OR_SUPERIOR` (从属关系)：表示 `p1` 与 `p2` 存在层级关系，方向不限。
        
    - `IS_MENTOR_OF` (师承关系)：表示 `p1` 是 `p2` 的老师或指导者。
        
    - `IS_FRIEND_OF` (朋友关系)：表示 `p1` 将 `p2` 视为朋友。
        
    - `IS_ENEMY_OF` (敌对关系)：表示 `p1` 将 `p2` 视为敌人。
        

---

#### **四、 核心工作流程：AI增强的图谱生成与查询**

本流程清晰地定义了从用户查询到图谱呈现的全过程，其核心在于“按需生成、一次生成、永久复用”的原则，由 `has_relationships` 字段精确控制AI的调用时机。

**第一步：用户查询与数据库校验**

1. 用户在前端界面输入人物姓名（例如“李信”）并发起查询。
    
2. 后端API接收到请求，首先对 PostgreSQL 的 `persons` 表执行精确查询，同时向前端发出消息提醒前端显示加载动画


**第二步：决策分支**

系统根据上一步的查询结果，自动选择最优处理路径：

- **情况一：人物存在且关系已生成**
    
    - **条件**：查询返回结果，且 `has_relationships` 字段为 `true`。
        
    - **动作**：直接跳转至 **第四步：加载并返回现有图谱**。这是最高效的路径，无需AI介入。
        
- **情况二：人物不存在，或存在但关系未生成**
    
    - **条件**：查询结果为空（新人物），或查询到结果但 `has_relationships` 为 `false`（已有的人物，但首次为其生成关系）。如果查询为空，先向ai发出一次预设的prompt请求，确认该知名人物在历史上是否存在，如果不存在，直接返回前端提示，如果存在，再继续后续操作
        
    - **动作**：进入 **第三步：AI关系生成与数据回填**。
        

**第三步：AI关系生成与数据回填（核心智能模块）**

此步骤仅在必要时触发，负责动态构建知识。

1. **准备核心人物数据**：
    
    - 如果核心人物在数据库中不存在，则调用 **AI prompt #1 (人物详情生成)**，获取其 `details` 信息。
        
    - 将新人物的基本信息存入 PostgreSQL 的 `persons` 表，此时 `has_relationships` 保持默认值 `false`。系统获得一个稳定的 `id`。
        
2. **调用AI生成关系网络**：
    
    - 使用核心人物的姓名”，调用 **AI prompt #2 (人物关系生成)**。此 prompt 专门用于获取与核心人物直接相关的人物列表及其关系类型。AI应返回一个结构化的列表
        
3. **解析并持久化关联人物**：
    
    - 后端遍历AI返回的关联人物列表（如“嬴政”、“王翦”）。
        
    - 对每一个关联人物，执行一次 `UPSERT` (或 `SELECT`后`INSERT`) 操作：
        
        - 在 `persons` 表中检查该人物是否存在。
            
        - 若不存在，则再次调用 **AI prompt #1** 为其生成 `details`，并创建新记录（`has_relationships` 为 `false`）。
            
        - 若已存在，则直接获取其 `id`。
            
    - 此过程结束后，确保所有涉及的人物（核心人物及所有关联人物）在 `persons` 表中都有唯一的 `id`。
        
4. **在Neo4j中创建图结构**：
    
    - **创建节点**：为所有涉及的人物，在 Neo4j 中批量创建 `Person` 节点（如果尚不存在），确保其 `id` 和 `name` 属性与 PostgreSQL 一致。
        
    - **创建关系**：根据AI返回的关系列表，使用各人物在 PostgreSQL 中的 `id`，在 Neo4j 中批量创建关系。例如：
        
        Cypher
        
        ```
        // 假设 李信 id='123', 嬴政 id='1'
        MATCH (p1:Person {id: '123'}), (p2:Person {id: '1'})
        MERGE (p1)-[:HAS_SUBORDINATE_OR_SUPERIOR]->(p2)
        ```
        
5. **更新状态**：
    
    - 所有关系成功写入 Neo4j 后，回到 PostgreSQL，将核心人物“李信”的 `has_relationships` 字段更新为 `true`。
        
    - 同时，更新核心人物的 `details` (如果第一步生成了新的) 和 `updated_at` 字段。
        
6. 数据写入完成后，流程自动进入下一步。
    

**第四步：加载并返回现有图谱**

此步骤是向前端提供数据的标准出口。

1. **获取核心网络 (Neo4j)**：使用核心人物的 `id` (例如 `'123'`)，向 Neo4j 查询其所有一度关系及关联的邻居节点。

2. **收集所有节点ID**：从上一步的查询结果中，提取出所有不重复的节点 `id`（包括中心人物和所有邻居）。

3. **批量获取节点详情 (PostgreSQL)**：使用收集到的ID列表，向 PostgreSQL 发起一次性的批量查询，以高效获取所有节点的详细信息。

4. **组合数据并响应**：后端将从 Neo4j 获取的“关系列表”（Edges）和从 PostgreSQL 获取的“节点信息列表”（Nodes）组合成一个前端绘图库可以直接使用的JSON对象，返回给前端进行最终的可视化渲染。