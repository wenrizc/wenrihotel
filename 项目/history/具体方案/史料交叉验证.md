
**角色**: 你是一名专业的Java后端架构师和全栈开发者，精通Spring Boot、Spring AI以及先进的RAG架构设计。

**核心任务**: 请根据我下方提供的《“史料交叉验证”功能RAG设计方案》，为我继续完成当前的Spring Boot项目。在rag文件夹内完成相关代码。

**技术栈要求**:

- **框架**: Spring Boot 3.x
    
- **核心AI库**: Spring AI
    
- **向量数据库**: PostgreSQL + pgvector
    
- **嵌入模型**: text-embedding-v4，参考阿里百炼的open ai接口调用
    
- **重排序模型**: gte-rerank-v2，参考阿里百炼的open ai接口调用
    
- **LLM**: deekseek
    
#### **一、 功能设计与说明 (面向用户)**

“史料交叉验证”功能是“history”项目的核心，它让用户从被动的历史信息接收者，变为主动的思辨者和研究者。

1. **用户输入**:
    
    - 用户可以输入一个历史相关的问题。
        
    - 用户可以上传自己的史料文档（支持.txt, .epub, .pdf格式等），系统会将其纳入史料库中。
        
2. **核心交互**:
    
    - **智能检索**: 系统接收到查询后，会自动从史料库中，检索所有相关原始史料。并结合用户问题，交付ai寻求答案。
        
3. **系统输出**:
    
    - 生成一份综合性的交叉验证报告。报告首先会给出一个关于该事件的、整合了多方说法的摘要。随后，以清晰的模块（共同点、矛盾点、各方视角）呈现详细的对比分析，并附上所有引用来源。
        

#### **二、 RAG设计思路与技术方案 (基于Spring AI)**

为了实现上述功能，我们将采用一套高度优化的RAG架构。此架构贯穿于您提到的“知识库构建”和“查询问答”两大阶段。

**整体架构流程图:**

```
用户输入 -> [1. 查询预处理] -> [2. 知识库路由] -> [3. 多路混合检索] -> [4. 重排序 Rerank] -> [5. 上下文构建] -> [6. CoT引导式生成] -> 最终报告
```

---

##### **阶段一：知识库构建 (Preprocessing)**

这是保证“史料交叉验证”质量的基石。我们将通过Spring AI的批处理作业（Spring Batch）或在应用启动时执行以下流程。

1. **高质量的文档解析与结构化**
2. **精细化的父子文本分片 (Parent-Child Chunking)**:
3. **向量模型与数据库**:
4. **元数据丰富化**:

---

##### **阶段二：查询问答 (Online Retrieval & Generation)**

当用户发起一次交叉验证请求时，系统将执行以下在线流程。

1. **查询预处理 (Query Pre-processing)**:
    
    - **技术选型**: 使用Spring AI的`ChatClient`调用一个轻量级大模型**qwen-turbo**。
        
    - **设计思路**: 。
        
        - **多查询重写 (Multi-Query Rewriting)**: 针对用户的原始问题，如“赤壁之战的经过”，LLM会生成多个角度的子问题：
            
            - `"赤壁之战中曹操军队的战前部署"`
                
            - `"周瑜在赤壁之战中的火攻计策"`
                
            - `"三国演义与三国志中关于赤壁之战的描述差异"`
                
        - 这些重写后的查询将并行用于后续的检索，以最大化召回率。
            
2. **知识库路由与混合检索 (Routing & Hybrid Search)**:
        
    - **设计思路**: 这是整个流程的核心调度器。
        
        - **知识库路由**: 暂时简易实现，用户会勾取需要的史料，根据这些史料进行相应的rag
            
        - **混合检索**: `HistoryRetriever`会同时发起两种检索：
            
            - **向量检索**: 使用`VectorStore#similaritySearch`，将所有重写后的查询向量化，在pgvector中查找最相似的“子文档”。利用元数据过滤器进行路由。
                
            - **关键词检索**: 利用PostgreSQL的全文检索功能（FTS），对人名、地名、特定术语等进行精确匹配。
                
        - **结果合并**: 将两种检索的结果合并去重。
            
3. **检索后处理 (Post-processing)**:
    
    - **父子关联 (Parent-Child Fetching)**: 检索到的是“子文档”，但它们可能信息不全。此时，根据子文档元数据中的`parent_id`，从文档数据库中批量获取完整的“父文档”上下文。
        
    - **重排序 (Rerank)**:
        
        - **技术选型**: 使用专门的`Reranker`模型（如`bge-reranker-large`）。这可以作为一个独立的微服务或通过Python脚本调用。
            
        - **设计思路**: 将上一步获取的“父文档”列表和用户的“原始问题”一同交给Reranker模型。Reranker会为每个文档计算一个与原始问题极度相关的精确分数。我们根据此分数对文档进行重新排序，并只选择Top-K（例如前5-10篇）最相关的文档进入最后生成环节。这步能极大地过滤掉由多路召回带来的噪音。
            
4. **结果生成优化 (Generator)**:
    
    - **技术选型**: 使用Spring AI的`ChatClient`和`PromptTemplate`。
        
    - **设计思路**: 这是展现成果的最后一步，我们将使用强大的思维链（Chain-of-Thought, CoT）Prompt。
        
        - **上下文构建**: 将经过重排序后的Top-K个最相关的“父文档”内容，连同它们的元数据（来源、作者等），一同塞入Prompt的上下文中。
            
        - **CoT Prompt设计**: 设计一个精巧的`PromptTemplate`，引导大模型进行逻辑推理和结构化输出。
            
        ``` Java
        // Spring AI PromptTemplate 示例
        String cotPrompt = """
        你是一名严谨的历史学家，你的任务是基于我提供的多份史料，对历史事件“{query}”进行交叉验证。
        请严格按照以下步骤思考和执行：
        
        第一步：逐一阅读并分析我提供的每一份史料。对于史料 {i}（来源：《{source_book}》），请总结其关于“{query}”的核心观点。
        
        第二步：整合所有史料，识别并列出它们共同承认的核心事实点。
        
        第三步：找出并详细说明不同史料之间的矛盾、差异或不同侧重点。请明确指出是哪些史料存在分歧，分歧点是什么。
        
        第四步：基于以上分析，生成一份综合性的交叉验证报告。报告需要包含以下部分：
        1.  **综合摘要**: 对事件“{query}”的整体概述。
        2.  **共同记述**: ...
        3.  **关键分歧**: ...
        4.  **史料引用**: 明确列出所有引用的史料来源。
        
        请直接引用史料原文来支撑你的分析。
        
        ---
        [提供的史料]
        {documents}
        ---
        
        请开始你的分析。
        """;
        PromptTemplate promptTemplate = new PromptTemplate(cotPrompt);
        ```
