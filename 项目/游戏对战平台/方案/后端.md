
### **后端单体应用架构总览**

尽管是单体应用，但内部我们遵循“高内聚、低耦合”的原则，通过**逻辑分层**和**面向接口编程**进行模块化设计。其核心结构如下：

*   **Controller层 (MVC)**: 暴露HTTP API，作为与API网关通信的入口。负责请求参数校验、基本的用户认证信息解析，并将业务逻辑委托给下层的Service。
*   **Service层**: 核心业务逻辑的实现。我们将按照您提供的功能模块划分（用户、房间、IM、VPN管理），创建相应的Service组件。这些Service之间可以相互调用。
*   **核心组件 (Core Components)**: 为了实现您提出的高级优化，我们将引入两个专门的后台组件，它们作为Service层的补充，专注于消息的异步处理：
    *   `MessageIngestService` (消息接收与预处理服务): 负责消费第一级MQ的消息。
    *   `MessagePushService` (消息推送服务): 负责消费第二级MQ的消息，并执行最终的推送逻辑。
*   **Repository/DAO层 (MyBatis-Plus)**: 数据访问层，负责与MySQL数据库进行交互。
*   **Infrastructure层**: 封装与外部系统的交互，如Redis客户端、RabbitMQ生产者/消费者、Headscale API客户端等。


### **1. 核心流程：消息生命周期的具体实现**

我们将详细拆解一条聊天消息从发送到接收的完整后端旅程，并融入“写放大”和“双层MQ”模式。

#### **阶段一：消息接收与投递 (Gateway -> MQ1)**

1.  **API网关**: 客户端通过WebSocket发送一条Protobuf编码的消息。网关收到后，进行Sa-Token初步认证，确认用户身份。
2.  **协议封装**: 网关不直接处理业务逻辑，而是将收到的消息（包含消息内容、目标会话ID等）连同发送者的`userId`和当前网关实例的`gatewayId`一起，封装成一个标准化的事件对象。
3.  **投递到一级MQ**: 网关作为生产者，将此事件对象发送到RabbitMQ的**第一级队列**。
    *   **MQ选型**: 使用一个`Direct Exchange`，命名为`im.ingest.exchange`。路由键（Routing Key）可以是消息类型，例如`chat.private`或`chat.room`，以便未来可能进行的分类处理。

#### **阶段二：一级MQ消费 - 预处理与持久化 (MessageIngestService)**

`MessageIngestService`组件作为**一级MQ的消费者**，负责所有消息的入口处理。

1.  **消费消息**: 从一级队列中获取到网关发送的事件对象。
2.  **生成全局序列号**:
    *   **实现**: 针对每个会话（单聊或群聊），使用Redis的`INCR`命令生成一个原子递增的序列号。
    *   **Redis Key**: `seq:conv:{conversation_id}`。
    *   **作用**: 这个序列号是保证消息在特定会话内**绝对有序**的关键。客户端将依据此序列号对消息进行排序。
3.  **消息持久化 (异步)**:
    *   **实现**: 将包含序列号、发送者、内容、时间戳等完整信息的消息对象，通过`Repository`层异步保存到MySQL的聊天记录表中。这里的“异步”可以通过Spring的`@Async`注解或提交到另一个专门用于数据库操作的线程池来完成，确保不阻塞主处理流程。这是**写放大模式**的核心体现，将写DB的延迟与主流程解耦。
4.  **构建推送消息**:
    *   根据消息类型（单聊/房间/大厅），从Redis缓存或数据库中查询出会话的所有目标用户ID。
    *   组装一个或多个用于推送的**净化后**的消息对象（包含内容、序列号、发送者信息等，但不包含网关信息这类内部数据）。
5.  **投递到二级MQ**:
    *   **MQ选型**: 使用一个`Fanout Exchange`，命名为`im.push.exchange`。因为同一条消息需要被所有`MessagePushService`实例接收并判断是否需要自己处理，`Fanout`模式（广播）是最高效的。
    *   **操作**: 将净化后的推送消息广播到这个交换机。

#### **阶段三：二级MQ消费 - 消息扇出与推送 (MessagePushService)**

`MessagePushService`组件作为**二级MQ的消费者**，可以水平扩展多个实例，共同处理推送任务。

1.  **消费消息**: 每个`MessagePushService`实例都从绑定的二级队列中获取到同一条推送消息。
2.  **确定推送目标**:
    *   **查询用户在线状态**: 遍历消息需要触达的所有`userId`，通过Redis查询他们的在线状态及所在的`gatewayId`。
    *   **Redis数据结构**: 使用Hash结构，`HGET user:status:{userId} gatewayId`。
3.  **执行推送**:
    *   **在线用户**: 如果用户在线，`MessagePushService`会通过内部服务间调用（如HTTP或更轻量的RPC框架）请求目标`gatewayId`对应的网关实例，让其将消息通过WebSocket推送给客户端。
    *   **离线用户**: 如果用户离线（查不到`gatewayId`或状态为offline），则执行**离线消息存储逻辑**：
        *   在Redis中，将该消息的ID（或完整消息，取决于大小）存入用户的离线消息队列（例如`LPUSH offline:msg:{userId} {message_json}`）。
        *   同时，在Redis中增加对应会话的未读消息计数（例如`HINCRBY user:unread:counts {conversation_id} 1`）。

---

### **2. 关键优化方案的后端实现**

#### **2.1. 大厅消息风暴应对 (信令+旁路拉取)**

此逻辑在**`MessageIngestService`**中实现。

1.  **流量识别**: 在处理一级MQ的消息时，增加一个判断逻辑，识别出消息是否发往高并发的大厅会话。可以通过配置（硬编码的`conversation_id`）或动态检测（基于Redis中维护的会话活跃度计数器）来实现。
2.  **触发阈值**: 设置一个时间窗口内的消息频率阈值（例如，1秒内超过20条消息）。
3.  **策略切换**:
    *   **正常模式**: 低于阈值时，按标准流程将完整消息投递到二级MQ。
    *   **风暴模式**: 超过阈值时，**改变投递到二级MQ的内容**：
        *   不再发送完整的聊天消息，而是发送一条轻量级的**“新消息通知”信令**，如`{ "type": "NOTIFY_NEW_MESSAGES", "channel": "lobby_main" }`。
        *   同时，将实际的聊天消息**批量缓存**到Redis的一个临时`List`中，例如`LPUSH lobby:cache:main "{message_json}"`，并使用`LTRIM`保持列表大小在合理范围（如最近200条）。
4.  **提供拉取API**:
    *   在`IM服务的Controller`中，提供一个HTTP API：`GET /api/v1/chat/pull/lobby`。
    *   该API接收客户端请求，从Redis的`lobby:cache`列表中拉取一批消息，可选择使用Protobuf进行序列化并用Gzip压缩后返回，实现高效的数据传输。

#### **2.2. 历史与离线消息 (推拉结合)**

*   **历史消息拉取 (信令模式)**:
    *   **实现**: 在`IM服务的Controller`中，提供一个分页查询的HTTP API：`GET /api/v1/chat/history`。
    *   **参数**: `conversation_id`, `last_message_seq` (或 `page_number`), `page_size`。
    *   **逻辑**: 该接口直接查询**MySQL数据库**（因为历史数据是冷数据），根据分页参数返回历史消息列表。客户端在进入聊天界面或向上滚动时调用此接口。

*   **离线消息处理 (推拉结合)**:
    *   **用户登录时**:
        1.  `用户服务`在处理登录成功后，除了生成Token，还需要执行一个**同步初始化**的动作。
        2.  **推送“摘要”**: 它会查询Redis中该用户的**所有会话未读数** (`user:unread:counts`) 和 **少量最近的离线消息**（从`offline:msg:{userId}`列表中`LPOP`几条）。
        3.  将这些摘要信息（如`{ unread_counts: {"conv1": 10, "conv2": 5}, recent_messages: [...] }`）通过登录成功的HTTP响应或首次WebSocket连接建立后的一条特殊消息推送给客户端。
        4.  客户端收到后，在UI上渲染未读红点，用户点击进入具体会话时，再通过**历史消息拉取API**按需加载完整聊天记录。

#### **2.3. 可靠消息投递 (ACK + 去重 + 有序)**

*   **服务端保障**:
    *   **全局有序**: 通过`Redis INCR`生成的`sequenceId`，为每个会话内的消息提供了严格的顺序。
    *   **消息不丢失**: RabbitMQ的持久化模式 + 生产者确认/消费者ACK机制，确保消息在从网关到`MessagePushService`的整个后端流程中不会丢失。
    *   **ACK处理**: 客户端发送的送达/已读ACK，同样作为一条特殊消息经由`网关 -> 一级MQ -> MessageIngestService`处理。服务收到后，更新MySQL中对应消息的状态字段。

*   **客户端配合 (后端需提供支持)**:
    *   **去重**: 后端推送给客户端的每条消息都必须包含一个**全局唯一的消息ID**（`message_id`，可以是数据库主键）和**会话内有序的序列号**（`sequence_id`）。客户端维护一个基于`message_id`的近期消息ID缓存池（如一个有固定大小的`Set`），收到新消息时先检查ID是否存在，若存在则直接丢弃，实现幂等性。
    *   **排序**: 客户端始终根据`sequence_id`对收到的消息进行排序展示，即使消息因网络原因乱序到达，也能在UI上正确显示。

#### **2.4. 动态心跳 (后端支持)**

虽然心跳机制主要在**客户端**与**API网关**之间实现，但后端可以提供支持：

*   **配置下发**: 后端可以通过`用户服务`的登录接口或一个全局配置接口，向客户端下发推荐的心跳参数，如`{ min_interval: 5, max_interval: 180, probe_count: 3 }`。这使得心跳策略可以由服务器动态调整，而无需更新客户端。

---

### **总结**

这个后端单体方案通过内部逻辑模块化、引入双层MQ异步处理核心消息流，并结合Redis实现状态管理和高性能操作，成功地将您提出的各项高级优化策略整合在一起。它既保持了单体应用部署和维护的简便性，又通过解耦和异步化获得了强大的性能、可靠性和可扩展性，能够有效应对高并发聊天和复杂网络环境下的挑战。