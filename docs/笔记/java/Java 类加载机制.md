
## 类的生命周期

一个类的完整生命周期包括七个阶段：加载、验证、准备、解析、初始化、使用和卸载。其中，类加载过程涵盖了前五个阶段。

-   加载 (Loading)
-   连接 (Linking)
    -   验证 (Verification)
    -   准备 (Preparation)
    -   解析 (Resolution)
-   初始化 (Initialization)
-   使用 (Using)
-   卸载 (Unloading)

注意：这些阶段通常是按顺序开始，但并非按顺序完成，它们会交叉混合地进行。解析阶段在某些情况下可能在初始化之后才开始，以支持Java的动态绑定。

---

## 类加载过程

### 1. 加载 (Loading)

这是类加载的第一个阶段，虚拟机主要完成三件事：

1.  通过一个类的全限定名获取定义此类的二进制字节流。
2.  将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。
3.  在内存中（具体为Java堆）生成一个代表这个类的 `java.lang.Class` 对象，作为方法区这个类的各种数据的访问入口。

加载`.class`文件的方式非常灵活，可以从本地文件、网络、jar包、数据库等来源获取，甚至可以动态编译生成。

### 2. 连接 (Linking)

#### 验证 (Verification)

确保读入的`.class`文件字节流符合JVM规范，并且不会危害虚拟机自身的安全。这个阶段包括文件格式验证、元数据验证、字节码验证和符号引用验证。

#### 准备 (Preparation)

正式为类的静态变量（static variables）分配内存，并设置其初始值。

-   内存分配：仅为类变量（`static`修饰）分配内存，不包括实例变量。内存分配在方法区。
-   初始值：通常是数据类型的“零值”，而不是代码中显式赋予的值。
    -   `int` 的零值为 `0`
    -   `boolean` 的零值为 `false`
    -   引用类型的零值为 `null`
-   特殊情况：如果一个类变量同时被 `static` 和 `final` 修饰（即常量），并且其在编译时就能确定值，那么在准备阶段，该变量就会被直接赋予代码中指定的值。
    -   例如 `public static final int VALUE = 100;`，在准备阶段 `VALUE` 的值就是 `100`，而不是 `0`。

#### 解析 (Resolution)

将常量池内的符号引用替换为直接引用的过程。

-   符号引用：以一组符号来描述所引用的目标，与虚拟机内存布局无关。
-   直接引用：可以直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，与虚拟机内存布局相关。

### 3. 初始化 (Initialization)

这是类加载过程的最后一步。此阶段根据程序员通过程序制定的主观计划去初始化类变量和其他资源，主要是执行类构造器 `<clinit>()` 方法的过程。

-   `<clinit>()` 方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（`static{}`块）中的语句合并产生的。
-   虚拟机会保证在子类的 `<clinit>()` 方法执行前，其父类的 `<clinit>()` 方法已经执行完毕。

#### 触发初始化的时机（主动使用）

JVM规范严格规定了有且只有六种情况必须立即对类进行初始化：
1.  创建类的实例时（如 `new` 关键字）。
2.  访问某个类或接口的静态变量，或者对该静态变量赋值时。
3.  调用类的静态方法时。
4.  使用 `java.lang.reflect` 包的方法对类进行反射调用时（如 `Class.forName("com.example.MyClass")`）。
5.  当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
6.  当虚拟机启动时，用户需要指定一个要执行的主类（包含 `main()` 方法的那个类），虚拟机会先初始化这个主类。

---

## 类加载器 (ClassLoaders)

### 类加载器的种类与层次

Java中的类加载器主要分为三类：

1.  启动类加载器 (Bootstrap ClassLoader)
    -   由C++实现，是虚拟机自身的一部分。
    -   负责加载 `<JAVA_HOME>\jre\lib` 目录下的，或者被 `-Xbootclasspath` 参数所指定的路径中存放的、能被虚拟机识别的类库（如 rt.jar）。
    -   它没有父加载器，在Java代码中尝试获取其父加载器会返回 `null`。

2.  扩展类加载器 (Extension ClassLoader)
    -   由Java语言实现。
    -   负责加载 `<JAVA_HOME>\jre\lib\ext` 目录下的，或者被 `java.ext.dirs` 系统变量所指定的路径中所有的类库。
    -   开发者可以直接使用扩展类加载器。

3.  应用程序类加载器 (Application ClassLoader)
    -   也称系统类加载器，由Java语言实现。
    -   负责加载用户类路径（Classpath）上所指定的类库。
    -   是程序中默认的类加载器。

这三者之间并非继承关系，而是通过组合关系来实现“父子”层级。

### 双亲委派模型 (Parent-Delegation Model)

这是Java默认的类加载机制，其工作过程是：

1.  当一个类加载器收到类加载请求时，它首先不会自己去尝试加载这个类。
2.  它会把这个请求委托给父类加载器去完成。
3.  每一层的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。
4.  只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

#### 双亲委派模型的优势

-   避免类的重复加载：保证一个类在各种类加载器环境中都是同一个 `Class` 对象。
-   保证核心类库的安全：防止用户自己编写的类覆盖Java核心类库中的类（例如，防止用户自定义一个 `java.lang.String` 类来替代系统中的 `String`）。

### `Class.forName()` vs `ClassLoader.loadClass()`

-   `ClassLoader.loadClass(name)`: 只将 `.class` 文件加载到JVM中，完成加载、验证、准备、解析，但不会执行初始化阶段。
-   `Class.forName(name)`: 不仅完成类的加载，默认还会对类进行初始化，即执行类中的静态代码块和静态变量的赋值。`Class.forName(name, initialize, loader)` 方法可以通过`initialize`参数控制是否执行初始化。

### 自定义类加载器

在某些场景下，需要自定义类加载器，例如：

-   需要从网络、数据库等非标准来源加载加密的字节码。
-   实现代码的热部署。
-   隔离不同应用的类，避免依赖冲突。

实现自定义类加载器通常需要继承 `java.lang.ClassLoader` 类，并重写其 `findClass(String name)` 方法。在 `findClass` 方法中获取类的字节码数据（如解密、从网络下载等），然后调用 `defineClass` 方法将字节码转换为 `Class` 对象。为了不破坏双亲委派模型，推荐的做法是只重写 `findClass`，而不是重写 `loadClass`。