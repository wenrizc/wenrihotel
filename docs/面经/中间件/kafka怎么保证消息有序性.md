
Kafka 通过 **分区（Partition）** 保证消息有序性。在单个分区内，消息按写入顺序存储和消费，生产者发送的消息顺序与消费者读取的顺序一致。要实现全局有序，可使用单一分区；若需局部有序，则按业务键（如用户 ID）分配到同一分区。

### 关键事实

1. **分区机制**：
    - Kafka 的 Topic 分为多个分区，每个分区是一个有序的日志文件。
    - 消息写入分区时，追加到日志末尾，偏移量（offset）递增。
2. **有序性范围**：
    - **分区内有序**：单分区内的消息严格按写入顺序排列。
    - **分区间无序**：不同分区间无全局顺序保证。
3. **实现方式**：
    - **生产者**：指定分区或用分区键（key）哈希到同一分区。
    - **消费者**：按分区顺序读取消息，单线程消费。
4. **全局有序限制**：
    - 单一分区可保证全局有序，但吞吐量受限（单分区单线程处理）。

### 延伸与面试角度

- **为什么分区内有序？**：
    - Kafka 采用追加写日志，offset 严格递增。
    - 单分区单 Leader 写，无并发干扰。
- **如何选择分区？**：
    - **默认分区器**：若无 key，轮询分配；有 key，哈希取模。
    - **自定义分区器**：实现 Partitioner 接口。
- **全局 vs 局部**：
    - **全局有序**：单分区，性能瓶颈（QPS 受限）。
    - **局部有序**：多分区 + key，高吞吐量，常用（如按用户 ID 排序）。
- **消费顺序保证**：
    - 单消费者线程消费单分区。
    - 多线程消费多分区，需业务层排序。
- **实际应用**：
    - **日志系统**：按时间戳 key 局部有序。
    - **订单处理**：按订单 ID 分配分区。
- **局限性**：
    - 分区数固定后不可减少，需提前规划。
    - 单分区故障影响有序性，依赖副本恢复。
- **面试点**：
    - 问“全局有序代价”时，提吞吐量瓶颈。
    - 问“多消费者”时，提线程分配和 offset。