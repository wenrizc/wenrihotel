
### 消费端限流

消费端限流的目的是为了保护消费者，防止其被无法处理的大量消息所压垮。

#### **核心机制：QoS (Quality of Service) 与 Prefetch Count**

这是 RabbitMQ 中最常用、也是最核心的消费者限流方式。 它通过设置一个“预取值”（Prefetch Count）来工作。

*   **工作原理**：
    1.  消费者通过 `basic.qos(prefetch_count=N)` 方法告知 RabbitMQ，它一次最多能接收并处理 N 条尚未发送确认回执（`ack`）的消息。
    2.  RabbitMQ 在向该消费者投递消息时，会持续追踪其未确认的消息数量。
    3.  一旦未确认的消息数达到 N，RabbitMQ 就会停止向该消费者投递新的消息。
    4.  只有当消费者处理完一条或多条消息并发送 `ack` 之后，未确认消息数减少，RabbitMQ 才会继续投递新的消息。

*   **优点**：
    *   **防止消费者过载**：避免因消息瞬间洪峰导致消费者内存耗尽或崩溃。
    *   **负载均衡**：当有多个消费者时，设置一个合理的 `prefetch_count`（例如 `1`）可以确保消息在消费者之间被更均匀地分配，避免出现一个消费者忙碌而其他消费者空闲的情况。

*   **如何选择 Prefetch 值**：
    *   **`prefetch_count = 1`**: 适用于消息处理时间较长或需要保证任务公平分配的场景。这能达到最公平的负载均衡效果，但网络开销相对较大。
    *   **较大的 `prefetch_count`**: 适用于消息处理速度非常快的场景。一次性批量获取多条消息可以减少网络通信的开销，从而提升整体吞吐量。 但值过高可能会导致负载不均和内存压力。
    *   **默认值**: 如果不设置，默认是无限制的，RabbitMQ 会尽可能快地将所有消息推送给消费者，这在大多数生产环境中是危险的。 （注意：一些客户端库如 Spring AMQP 2.x 可能会设置自己的默认值，例如 250。）

### 生产端限流

当生产者发送消息的速度远超消费者处理速度时，会导致消息在队列中大量积压，最终可能耗尽 Broker 的内存或磁盘资源。 生产端限流就是为了应对这种情况。

#### **机制一：队列长度限制 (Max Length)**

可以直接在 Broker 上为队列设置长度限制，从而对生产者进行被动限流。

*   **工作原理**：
    *   通过策略（Policy）或在声明队列时使用参数 `x-max-length`（消息数量）或 `x-max-length-bytes`（消息总体积）来限制队列的最大容量。
    *   当队列达到上限时，RabbitMQ 会根据预设的溢出行为（`x-overflow`）来处理新进入的消息。
        *   `drop-head` (默认): 丢弃队列头部的旧消息。
        *   `reject-publish`: 拒绝生产者发送的新消息。生产者会收到一个 `nack`，从而得知消息被拒绝，可以实现反压。
        *   `reject-publish-dlx`: 拒绝新消息，并将其路由到死信交换机（如果配置了）。

*   **优点**：简单直接，能有效防止队列无限增长，保护 Broker 的稳定性。

#### **机制二：Broker 内部的流控机制 (Flow Control)**

RabbitMQ 内置了一套自动的、基于信用的流控机制，用于保护自身免于被过快的生产者压垮。

*   **工作原理**：
    *   当 RabbitMQ 节点侦测到自身即将过载（例如内存或磁盘使用接近“水位线”）时，它会自动“阻塞”发送速度过快的生产者连接。
    *   从生产者的角度来看，就像是网络带宽突然降低了，发送操作会变慢或阻塞。 当 Broker 恢复正常后，该连接会自动解除阻塞。
    *   这是一个被动的保护机制，无需手动配置。

#### **机制三：客户端实现限流逻辑**

除了 Broker 端的限制，也可以在生产者应用层面主动进行限流。

*   **利用 Publisher Confirms**：生产者可以设置一个在途（未被 Broker 确认）消息数量的上限。在发送消息前检查未确认的消息数，如果超过阈值就暂停发送，直到收到 Broker 的确认回执。
*   **应用层限流算法**：在生产者代码中直接集成令牌桶、漏桶等限流算法，从源头控制发送速率。

| 限流方式 | 作用对象 | 实现机制 | 主要目的 |
| :--- | :--- | :--- | :--- |
| **QoS (Prefetch Count)** | 消费者 | `basic.qos` 设置未确认消息数上限 | 保护消费者，防止其过载，实现消费端的负载均衡。 |
| **队列长度限制** | 生产者 (间接) | 设置 `x-max-length` 和 `x-overflow` 策略 | 保护 Broker，防止队列无限积压，耗尽系统资源。 |
| **Broker 内部流控** | 生产者 | Broker 自动监测资源并阻塞过快的连接 | 保护 Broker 的自我保护机制，防止因内存/磁盘压力过大而崩溃。 |
| **客户端限流** | 生产者 | 在应用代码中实现限流算法或利用 Publisher Confirms | 主动控制消息发送速率，实现更精细化的流量控制。 |
