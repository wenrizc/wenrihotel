
### 生产端：确保消息成功到达RabbitMQ服务器

当生产者发送一条消息后，它并不知道消息是否成功到达了RabbitMQ的Broker。网络抖动、Broker异常等都可能导致消息在传输过程中丢失。为了解决这个问题，RabbitMQ提供了两种主要的机制：

- 事务机制：生产者可以开启一个事务，所有在该事务中发布的消息，在最后提交事务时会一并发送。如果Broker成功接收，事务就成功提交；如果中间出现任何问题，就可以回滚事务，意味着所有消息都未发送成功。但事务机制的性能开销极大，它会严重影响吞吐量，所以在线上环境中基本不使用。
    
- Publisher Confirms (发布者确认机制)：这是生产环境中推荐的主流方案。生产者开启Confirm模式后，它发送的每一条消息都会被分配一个唯一的ID。当消息被Broker成功接收后，Broker会向生产者发送一个确认（ACK）。如果因为某些原因（比如队列满了，或者内部错误）导致消息处理失败，Broker会发送一个否定确认（NACK）。这样，生产者就能明确知道每一条消息的投递结果。
    
    - 结合Publisher Returns：开启Confirm模式只能保证消息到达了交换机，但如果交换机没有匹配的队列可以路由，消息依然会丢失。通过设置mandatory标志位，我们可以告诉Broker，如果消息无法路由，请把它返回给生产者。这样生产者就可以通过回调函数接收到这些被退回的消息，并决定如何处理（例如记录日志、重发到备用队列等）。
        

通过“Publisher Confirms”加“Publisher Returns”的组合，我们就能在生产端实现非常可靠的投递，确保消息要么成功到达了队列，要么我们能明确知道它投递失败了。

### Broker端：确保进入服务器的消息能持久化存储

消息成功进入Broker后，默认是存储在内存中的。如果此时Broker发生宕机或重启，内存中的消息就会全部丢失。为了防止这种情况，我们需要开启持久化。

这需要两个层面的配合：

- 队列持久化：在声明队列时，必须将其设置为持久化（durable=true）。这样，队列的元数据信息（名字、属性等）才会被存储在磁盘上，Broker重启后队列依然存在。
    
- 消息持久化：在发送消息时，需要将消息的投递模式设置为持久化（delivery_mode=2）。这样，Broker在收到这条消息后，会将其写入到磁盘文件中。
    

必须同时满足以上两个条件，消息才算真正地被持久化了。如果队列不持久化，Broker重启后队列消失，消息自然也就没了。如果消息不持久化，Broker重启后，虽然队列还在，但里面的消息已经丢失了。

- 集群高可用：对于更高级别的容灾，我们会配置RabbitMQ集群，并使用镜像队列（Mirrored Queues）。这样，一个队列的消息会在多个集群节点上拥有完整的副本。当主节点宕机时，消息在其他镜像节点上依然存在，可以无缝切换，从而避免了单点故障导致的数据丢失。
    

### 消费端：确保消息被正确处理后再确认

消息从队列投递到消费者后，也可能发生丢失。例如，Broker将消息推送给消费者后，消费者的进程在处理消息的过程中异常退出了，而Broker并不知道，它以为消息已经被成功消费，从而将消息从队列中删除。

为了解决这个问题，我们必须使用手动确认模式（Manual Acknowledgement）。

- 关闭自动ACK：在消费者订阅队列时，要将自动确认（auto_ack）设置为false。
    
- 手动发送回执：当消费者从队列中获取到消息并完成所有业务逻辑处理后，再主动调用方法向Broker发送一个确认回执（ACK）。Broker收到这个ACK后，才会放心地将这条消息从队列中删除。
    
- 失败处理：如果在处理过程中发生异常，消费者可以发送一个否定确认（NACK），并告知Broker是选择将消息重新放回队列（requeue=true）等待其他消费者处理，还是直接丢弃/放入死信队列（requeue=false）。
    

通过手动ACK机制，消费的主动权掌握在了我们自己手中，只有业务逻辑真正执行成功，消息才会被确认消费，这极大地保证了消费端的可靠性。
