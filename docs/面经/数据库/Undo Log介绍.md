
Undo Log是一种逻辑日志。它记录的是与实际数据操作相反的操作。

*   当执行`INSERT`时，Undo Log会记录一条对应的`DELETE`操作。
*   当执行`DELETE`时，Undo Log会记录一条对应的`INSERT`操作。
*   当执行`UPDATE`时，Undo Log会记录一条“反向”的`UPDATE`操作，即把数据修改回原来的值。

这些日志被存放在一个称为“回滚段（Rollback Segment）”的特殊段中，这个段位于共享表空间或独立的Undo表空间内。

#### 作用一：实现事务的回滚（Atomicity - 原子性）

这是Undo Log最直观的作用。我们知道，事务具有原子性，即一个事务中的所有操作要么全部成功，要么全部失败。当一个事务因为某种原因需要回滚时（比如执行了`ROLLBACK`语句，或者事务执行过程中出现错误），InnoDB就会利用Undo Log来实现这一过程。

*   工作流程：InnoDB会找到该事务对应的Undo Log链，然后按照与事务执行时相反的顺序，执行Undo Log中记录的那些“反向操作”。
*   举例：如果一个事务先`INSERT`了一行，然后`UPDATE`了另一行，当它回滚时，InnoDB会先执行反向的`UPDATE`将数据改回去，然后再执行`DELETE`操作将新插入的行删除掉，从而使数据恢复到事务开始前的状态。

#### 作用二：实现MVCC（多版本并发控制）

这是Undo Log更深层次、也是更重要的作用。我们之前谈到的MVCC，其核心就是能够在同一时刻为不同的事务提供不同版本的数据快照。这些“历史版本”的数据，正是由Undo Log来存储和提供的。

*   工作流程：
    1.  当一个事务修改某行数据时，InnoDB会把这行数据的旧版本（修改前的数据）完整地复制一份，存入Undo Log中。
    2.  这个旧版本的Undo Log记录会通过行记录中的隐藏字段`DB_ROLL_PTR`（回滚指针）串联起来，形成一个**版本链**。
    3.  当另一个读事务（我们称之为事务A）需要读取这行数据时，它会获取一个ReadView（读视图）。
    4.  如果事务A发现当前数据的最新版本对它不可见（比如是由一个在它开启后才启动的事务所修改的），它就会顺着回滚指针，去Undo Log中查找上一个版本。
    5.  它会沿着版本链一直回溯，直到找到一个对它的ReadView来说“可见”的版本，然后将这个版本的数据作为查询结果返回。

*   带来的好处：通过Undo Log构建的版本链，MVCC实现了读操作的非阻塞。读事务不需要等待写事务释放锁，而是可以直接去读取数据的历史快照，极大地提升了数据库的并发性能。

### Undo Log的管理与清理

Undo Log是会不断增长的，因此需要有机制来清理它。

*   清理时机：Undo Log不能在事务回滚后就立即删除。因为它可能还需要被其他正在运行的事务用来构建数据快D照（用于MVCC）。
*   清理机制：InnoDB有一个后台的`purge`线程，它会定期检查Undo Log中的版本。如果一个版本确认不再被任何活跃的事务的ReadView所需要，那么这个版本就可以被安全地清理掉了。
