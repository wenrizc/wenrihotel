
要检查一个SQL查询是否用到了索引，以及如何使用的，最主要和最直接的方法就是使用数据库提供的`EXPLAIN`命令（或者在某些数据库中是`EXPLAIN PLAN`）。`EXPLAIN`可以分析查询语句，并返回数据库优化器为该查询生成的执行计划。通过解读执行计划，我们就能清晰地了解索引的使用情况。

以下是使用`EXPLAIN`进行检查的具体步骤和需要关注的关键信息（以MySQL为例，其他关系型数据库的`EXPLAIN`输出虽然格式不同，但核心思想类似）：

1.  使用`EXPLAIN`命令：
    在你的SQL查询语句前加上`EXPLAIN`关键字，然后在数据库客户端中执行。
    例如：
    `EXPLAIN SELECT * FROM users WHERE age > 25 ORDER BY create_time;`

2.  解读`EXPLAIN`的输出结果：
    `EXPLAIN`会返回一个表格，其中包含了执行计划的详细信息。需要重点关注以下几列：

    *   id: 查询的标识符，每个`SELECT`都有一个唯一的id。
    *   select_type: 查询的类型（如SIMPLE, PRIMARY, SUBQUERY, UNION等）。
    *   table: 输出结果集的表。
    *   partitions: 查询匹配到的分区。
    *   type: 这是最重要的列之一，直接反映了查询的访问类型，也是判断是否使用索引的关键。常见的值按性能从优到劣大致排序如下：
        *   system: 表只有一行记录（系统表），是const类型的特例。
        *   const: 通过主键或唯一索引进行等值查询，最多只匹配一行数据。性能极高。
        *   eq_ref: 在连接查询中，被驱动表是通过主键或唯一索引进行等值匹配。
        *   ref: 使用非唯一性索引进行等值查询，或者联合索引的最左前缀匹配。
        *   range: 使用索引进行范围查询，例如 `BETWEEN`, `>`, `<`, `IN` 等。
        *   index: 全索引扫描。遍历整个索引树来查找数据，通常比全表扫描快，因为索引文件通常比数据文件小。
        *   ALL: 全表扫描。这是最坏的情况，意味着没有使用任何索引，数据库需要遍历表中的每一行数据。
        如果`type`列的值是`ALL`或`index`（对于大数据量的表），通常就意味着索引使用不佳或索引失效，需要进行优化。

    *   possible_keys: 显示查询可能使用哪些索引。如果这一列是`NULL`，则很可能没有可用的索引，或者查询条件不满足使用索引的条件。

    *   key: 显示查询实际决定使用的索引。
        *   如果这一列是`NULL`，表示优化器最终没有选择使用任何索引。
        *   如果显示了某个索引名，则表示查询成功用到了该索引。

    *   key_len: 显示了实际使用的索引的长度（字节数）。这个值可以帮助判断联合索引是否被充分利用。如果一个联合索引`idx(a, b, c)`，查询`WHERE a=1 AND b=2`，`key_len`会比查询`WHERE a=1`要长，说明`b`列的索引部分也被用上了。

    *   ref: 显示了与索引列进行比较的列或常量。

    *   rows: 估算为了找到所需行而需要读取的行数。这个值越小越好。

    *   filtered: 表示存储引擎返回的数据在server层过滤后，剩下满足查询条件的记录数的百分比。

    *   Extra: 包含额外的重要信息，能揭示查询的执行细节。
        *   Using index: 表示查询使用了覆盖索引，这是一个非常好的性能信号，因为它意味着查询所需的所有数据都直接从索引中获取，无需回表。
        *   Using where: 表示在存储引擎层面进行了过滤。
        *   Using temporary: 表示查询中使用了临时表来存储中间结果，通常发生在`GROUP BY`或`UNION`操作中，是性能瓶颈的信号。
        *   Using filesort: 表示查询需要进行外部排序（当数据量大无法在内存中完成排序时）。如果`ORDER BY`的列没有合适的索引，通常会出现这个。这也是性能瓶颈的信号。
        *   Index pushdown / Using index condition: 索引条件下推，表示部分`WHERE`条件可以在存储引擎层面利用索引直接进行过滤，减少了返回到Server层的数据量。

3.  总结检查步骤：
    1.  执行`EXPLAIN your_sql_query;`
    2.  首先看 `type` 列。如果不是 `ALL` 或 `index`（对于大表），通常说明索引起作用了。
    3.  再看 `key` 列。确认是否使用了你期望的索引。如果为`NULL`，则索引失效。
    4.  查看 `Extra` 列。寻找 `Using filesort`, `Using temporary` 等性能警告，并寻找 `Using index` 这样的优化机会。
    5.  结合 `rows` 列估算的扫描行数，判断查询的效率。

4.  使用`EXPLAIN ANALYZE`（在支持的数据库中，如MySQL 8.0.18+, PostgreSQL）：
    *   这个命令不仅会显示执行计划，还会实际执行查询并返回真实的执行耗时、实际扫描行数、循环次数等更精确的信息。
    *   `EXPLAIN ANALYZE SELECT ...;`
    *   这对于分析优化器估算的准确性以及定位性能瓶颈的具体环节非常有帮助。


