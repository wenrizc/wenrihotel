

### EXPLAIN 的核心作用

简单来说，EXPLAIN命令的核心作用就是**展示查询优化器为一条SQL语句生成的执行计划（Query Execution Plan）**。

它本身并不会真正地执行查询，所以速度很快。通过这个计划，我们可以精确地知道以下关键信息：

1. 查询会以什么样的顺序访问哪些表。
    
2. 访问每个表时，采用了哪种数据访问方法（比如是全表扫描还是索引扫描）。
    
3. 哪些索引实际被用上了，或者有哪些索引本可以被用上。
    
4. 执行过程中是否需要创建临时表或进行文件排序等耗费性能的操作。
    
5. 优化器预估为了找到所需数据，需要扫描多少行记录。
    

掌握了这些信息，我们就能判断出一条查询的性能瓶颈所在，从而进行针对性的优化。

### EXPLAIN 输出的详细解读

EXPLAIN的输出是一张表，每一行代表查询中的一个步骤。其中有几个列至关重要，我会逐一解释它们（以MySQL为例）：

- id: 查询中操作的序列号。ID越大，优先级越高，越先被执行。ID相同则从上到下执行。
    
- select_type: 查询的类型，比如SIMPLE（简单查询）、SUBQUERY（子查询）、UNION（联合查询）等。
    
- table: 这一步操作涉及的表名。
    
- type: **这是最重要的列，没有之一**。它描述了数据库如何找到所需的数据，也就是访问类型。性能从好到差依次是：
    
    - system > const: 结果只有一行，基本是常量级别，速度最快。
        
    - eq_ref: 在JOIN查询中，使用了主键或唯一索引进行关联，对于前一张表的每一行，后一张表只有一行匹配。非常高效。
        
    - ref: 使用了非唯一性索引进行查找。
        
    - range: 使用了索引进行了范围查询，比如 WHERE id > 100。
        
    - index: 全索引扫描。虽然扫描了整个索引树，但比扫描整个表数据要快，因为索引通常比表数据小。
        
    - ALL: **全表扫描（Full Table Scan）**。这是最坏的情况，是性能的巨大杀手。优化慢查询的主要目标之一就是消灭ALL。
        
- possible_keys: 显示查询可能用到的索引。
    
- key: **实际决定使用的索引**。如果为NULL，则表示没有使用索引。
    
- key_len: 索引中被使用的字节数。这个值越短越好。通过它，我们可以判断复合索引是否被完全利用。
    
- rows: **第二重要的列**。优化器预估要找到目标数据需要读取的行数。这个数值越小越好。
    
- Extra: **信息量极大的补充说明列**，包含了很多“坏味道”的信号，比如：
    
    - Using filesort: 表示无法利用索引完成排序，需要在内存或磁盘上进行额外的排序操作，性能损耗大。
        
    - Using temporary: 表示需要创建一个临时表来存储中间结果，常见于GROUP BY或UNION操作，严重影响性能。
        
    - Using where: 表示在存储引擎层返回数据后，在Server层进行了一次过滤。这是正常现象。
        
    - Using index: **这是一个好信号**。表示查询使用了“覆盖索引（Covering Index）”，即查询所需的所有数据都直接从索引中获取，无需回表查询数据行，性能极高。
        

### 如何依赖EXPLAIN进行慢查询优化（实战方法论）

优化慢查询是一个系统性的过程，EXPLAIN是这个过程中的核心诊断工具。我的优化流程通常如下：

#### 第1步：定位慢查询

通过数据库的慢查询日志（slow query log）或者性能监控平台（如Prometheus + Grafana）找到执行时间过长、开销过大的SQL语句。

#### 第2步：执行 EXPLAIN

对找到的慢查询SQL执行 EXPLAIN，获取其执行计划。  
EXPLAIN SELECT * FROM orders WHERE customer_id = 123 AND status = 'pending' ORDER BY created_at DESC;

#### 第3步：分析执行计划，寻找“坏味道”

我会像医生看体检报告一样，按优先级检查EXPLAIN的输出：

1. **检查 type 列**：
    
    - **问题**：type是否为 ALL 或 index？
        
    - **分析**：如果是，说明查询走了全表扫描或全索引扫描，这是首要的优化目标。通常是因为WHERE子句中的条件列没有建立合适的索引。
        
    - **对策**：为WHERE子句中频繁用于查询的列建立索引。对于上面的例子，应该在customer_id和status上建立复合索引 (customer_id, status)。
        
2. **检查 Extra 列**：
    
    - **问题**：Extra中是否出现了 Using filesort 或 Using temporary？
        
    - **分析**：
        
        - Using filesort：说明ORDER BY子句中的列没有索引，或者无法利用现有索引进行排序。
            
        - Using temporary：通常是GROUP BY操作没有利用到索引。
            
    - **对策**：
        
        - **解决filesort**：优化索引。将排序字段也加入到索引中。例如，将索引升级为 (customer_id, status, created_at)。这样，数据在索引中已经按created_at排好序，可以直接取出，无需额外排序。
            
        - **解决temporary**：为GROUP BY的列建立索引。
            
3. **检查 key 和 rows 列**：
    
    - **问题**：key列是否为NULL？rows列的值是否远大于预期？
        
    - **分析**：key为NULL明确表示没有使用索引。rows值过大，说明即使使用了索引，其选择性（selectivity）也不好，导致扫描了大量无效数据。
        
    - **对策**：
        
        - 检查SQL语句的写法，看是否因为函数使用（如WHERE YEAR(order_date) = 2023）、类型不匹配等原因导致索引失效。应改写为WHERE order_date >= '2023-01-01' AND order_date < '2024-01-01'。
            
        - 分析索引的设计是否合理，是否需要创建选择性更好的复合索引。
            
4. **检查 key_len 列**：
    
    - **问题**：对于复合索引，key_len的值是否小于预期的长度？
        
    - **分析**：这说明复合索引没有被完全利用。比如索引是(a, b, c)，但查询条件违反了最左前缀原则（比如直接WHERE b = 1），导致只有a部分或者完全没有用到。
        
    - **对策**：调整SQL语句中WHERE条件的顺序，或者重新设计索引以匹配查询模式。
        

#### 第4步：提出优化方案并验证

根据分析结果，提出假设（如“增加一个复合索引 (c, s, t)”）。在测试环境中创建该索引，然后再次执行EXPLAIN，对比优化前后的执行计划。如果type从ALL变成了ref，Extra中的filesort消失了，rows数量大幅下降，那么就证明优化是有效的。

#### 第5步：上线并持续观察

将优化方案部署到生产环境，并持续监控该查询的性能表现，确保优化达到预期效果。

总结一下，EXPLAIN是连接我们和数据库优化器的桥梁。通过系统性地解读它的输出，特别是关注type, rows, Extra等关键列，我们就能找到SQL的性能瓶ED颈，并像外科手术一样，精准地通过调整SQL写法或优化索引来解决问题。