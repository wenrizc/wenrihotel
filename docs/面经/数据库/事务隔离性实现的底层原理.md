
#### 事务隔离性概述
- **定义**：
  - 事务隔离性是 ACID 中的 “I”，确保并发事务之间互不干扰，避免数据不一致（如脏读、不可重复读、幻读）。
- **隔离级别**：
  - 读未提交、读已提交、可重复读、串行化。
- **底层原理**：
  - 通过 **多版本并发控制（MVCC）** 和 **锁机制** 实现。

#### 核心实现
1. **MVCC**：
   - 维护数据多版本，隔离读写。
2. **锁**：
   - 控制并发写操作。
3. **结合**：
   - MVCC 解决读问题，锁解决写冲突。

#### 核心点
- InnoDB 用 MVCC + 锁实现不同隔离级别。

---

### 1. 隔离性底层原理详解
#### (1) MVCC（多版本并发控制）
- **原理**：
  - 为每行数据维护多个版本，事务读取适合的版本，避免读写冲突。
- **关键字段**（InnoDB）：
  - **DB_TRX_ID**：记录创建或最后修改的事务 ID。
  - **DB_ROLL_PTR**：回滚指针，指向旧版本（Undo Log）。
  - **DB_ROW_ID**：行 ID（隐含主键）。
- **Read View**：
  - 每个事务生成一个视图，包含：
    - 当前活跃事务列表。
    - 最小事务 ID（`up_limit_id`）。
    - 最大事务 ID（`low_limit_id`）。
  - 判断版本可见性：
    - 版本的事务 ID < `up_limit_id`：可见。
    - 版本的事务 ID 在活跃列表中：不可见。

- **隔离级别实现**：
  - **读未提交**：
    - 直接读最新数据，无 MVCC。
  - **读已提交**：
    - 每次查询生成新 Read View，读最新提交版本。
  - **可重复读**：
    - 事务开始时生成 Read View，始终读快照。
  - **串行化**：
    - 通常不用 MVCC，依赖锁。

- **示例**：
```sql
-- 事务 A
START TRANSACTION;
SELECT * FROM user WHERE id = 1; -- 读快照（MVCC）

-- 事务 B
UPDATE user SET name = 'Bob' WHERE id = 1;
COMMIT;

-- 事务 A
SELECT * FROM user WHERE id = 1; -- 仍读旧版本
```

#### (2) 锁机制
- **类型**：
  - **共享锁（S Lock）**：读锁，允许多事务读。
  - **排他锁（X Lock）**：写锁，独占访问。
  - **意向锁（IS/IX）**：表级锁，协调行锁。
  - **间隙锁（Gap Lock）**：锁住索引间隙，防幻读。
- **作用**：
  - 控制并发写，保护数据一致性。
- **隔离级别实现**：
  - **读未提交**：无锁限制。
  - **读已提交**：写加 X 锁，读不加锁。
  - **可重复读**：写加 X 锁，读用 MVCC + 间隙锁防幻读。
  - **串行化**：读加 S 锁，写加 X 锁，串行执行。

- **示例**：
```sql
-- 事务 A
START TRANSACTION;
SELECT * FROM user WHERE id = 1 LOCK IN SHARE MODE; -- 加 S 锁

-- 事务 B
UPDATE user SET name = 'Bob' WHERE id = 1; -- 等待 X 锁
```

#### (3) Undo Log
- **作用**：
  - 存储旧版本数据，支持 MVCC 和回滚。
- **位置**：
  - 保存在回滚段（Rollback Segment）。
- **过程**：
  - 更新时，旧数据写入 Undo Log，新数据覆盖。

---

### 2. 隔离级别与实现
| **隔离级别**    | **MVCC**         | **锁**             | **解决的问题**       |
|-----------------|------------------|--------------------|----------------------|
| 读未提交        | 无               | 无读锁             | 无                  |
| 读已提交        | 每次新 Read View | 写加 X 锁          | 脏读                |
| 可重复读        | 事务初 Read View | 写加 X 锁 + 间隙锁 | 脏读、不可重复读    |
| 串行化          | 少用 MVCC        | 读写加锁           | 脏读、不可重复读、幻读 |

---

### 3. 底层流程示例
#### 可重复读（InnoDB 默认）
- **场景**：
  - 事务 A 读 `id = 1` 的数据。
  - 事务 B 修改 `id = 1`。
- **过程**：
  1. A 生成 Read View，记录活跃事务。
  2. B 更新数据，生成新版本，旧版本存 Undo Log。
  3. A 再次读，MVCC 读取 Undo Log 中的旧版本。
  4. B 提交，A 仍读旧版本（快照一致）。

#### 幻读防护
- **间隙锁**：
  - `SELECT * FROM user WHERE id BETWEEN 1 AND 10 FOR UPDATE`。
  - 锁住范围，防止插入。

---

### 4. 延伸与面试角度
- **与性能**：
  - MVCC 减少锁竞争，但 Undo Log 占空间。
- **实际应用**：
  - 电商：库存扣减用可重复读。
- **调试**：
  - `SHOW ENGINE INNODB STATUS` 查看锁。
- **面试点**：
  - 问“原理”时，提 MVCC 和锁。
  - 问“级别”时，提实现差异。

---

### 总结
事务隔离性通过 MVCC（多版本控制）和锁机制实现，InnoDB 用 Read View 和 Undo Log 隔离读写，用锁（如间隙锁）解决幻读。面试时，可提版本管理或画事务图，展示理解深度。