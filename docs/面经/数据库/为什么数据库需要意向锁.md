
#### 1. 问题的根源：多粒度锁定

InnoDB存储引擎支持多粒度锁定，即它同时提供了表级锁和行级锁。这就带来了一个问题：当一个事务想要获取一个表的表级锁时（比如`LOCK TABLES ... WRITE;`），它如何快速地知道，这张表里有没有任何一行已经被其他事务锁住了呢？

如果没有意向锁，数据库唯一的办法就是遍历这张表的所有行，去检查每一行是否存在行级锁。对于一张有数百万甚至上亿行数据的表来说，这是一个无法接受的性能灾难。

#### 2. 意向锁的解决方案

意向锁（Intention Lock）就是为了解决这个问题而生的。它是一种**表级锁**，但它的作用不是为了锁定表本身，而是为了**表明一个事务正准备或者已经在这张表的某些行上加锁**。

意向锁主要有两种类型：
*   意向共享锁 (Intention Shared Lock, IS Lock)：表示一个事务打算在表中的某些行上设置共享锁（S锁）。例如，执行`SELECT ... LOCK IN SHARE MODE`之前，会先获取该表的IS锁。
*   意向排他锁 (Intention Exclusive Lock, IX Lock)：表示一个事务打算在表中的某些行上设置排他锁（X锁）。例如，执行`UPDATE`, `DELETE`, `INSERT`, `SELECT ... FOR UPDATE`之前，会先获取该表的IX锁。

#### 3. 意向锁的工作流程

1.  当一个事务想要对某一行加行级锁（S锁或X锁）时，它必须**首先**自动地、隐式地获取该表对应的意向锁（IS锁或IX锁）。
2.  当另一个事务想要获取这张表的表级锁（表S锁或表X锁）时，它不需要再去检查每一行。它只需要检查这张表上是否存在与它想加的表锁不兼容的意向锁即可。

#### 4. 锁的兼容性

*   意向锁之间是完全兼容的：一个事务获取了表的IX锁，另一个事务也可以同时获取这张表的IX或IS锁。这很好理解，因为它们只是表明了意图，可能锁定的行并不冲突。
*   意向锁与表级锁的冲突关系：
    *   一个事务想要获取表的S锁，它必须等待所有持有IX锁的事务释放。
    *   一个事务想要获取表的X锁，它必须等待所有持有IS锁或IX锁的事务释放。

通过这个机制，当事务B想对表T加X锁时，它只需要检查表T上是否有IS或IX锁。如果发现有，就意味着肯定有其他事务正在锁定表中的某些行，于是事务B就进入等待状态。这个检查过程是O(1)的，速度极快。

意向锁是InnoDB为了支持高效的、多粒度的加锁策略而设计的一种内部锁机制。它的唯一目的，就是作为一个快速的、低成本的“信号”，让需要获取表级锁的事务，能够瞬间判断出是否有行级锁的存在，从而避免了对全表进行逐行扫描的巨大性能开销。** 它是由数据库自动管理的，我们开发者不需要也无法直接操作它。