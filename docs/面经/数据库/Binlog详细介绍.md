
Binlog是MySQL在服务层（Server Level）产生的一种逻辑日志。它以二进制格式记录了所有对数据库进行修改的操作（DDL和DML），但不包括`SELECT`和`SHOW`这类不修改数据的查询。

可以把它理解为数据库的“操作历史录像带”，它忠实地记录了数据库从某个时间点开始，发生过的所有数据变更事件。

### Binlog有什么作用？

它的核心作用主要有两个：

1.  数据复制（Replication）：这是Binlog最广为人知的应用。在主从架构中，主库（Master）会将自己的Binlog文件传输给从库（Slave）。从库接收到Binlog后，会启动一个I/O线程和一个SQL线程，前者负责拉取和写入Relay Log，后者负责读取Relay Log并重放其中的SQL事件，从而将主库上的数据变更在从库上复现一遍，达到主从数据同步的目的。

2.  数据恢复（Point-in-Time Recovery）：这是保障数据安全的最后一道防线。假如数据库在某个时间点发生了误操作或崩溃，我们可以这样做：
    *   首先，找到最近的一次全量备份文件，将数据库恢复到那个备份的时间点。
    *   然后，找到从那个备份时间点之后开始记录的Binlog文件。
    *   利用MySQL提供的`mysqlbinlog`工具，将这些Binlog中的操作重放到数据库中，直到误操作发生前的那一刻。
    这样，我们就可以实现任意时间点的精准恢复。

### Binlog的三种格式

Binlog记录事件的格式直接影响了复制的准确性和日志文件的大小。主要有三种格式，可以通过`binlog_format`参数进行设置。

#### 1. STATEMENT格式
*   特点：这是最早的格式。它直接记录了导致数据变更的原始SQL语句。
*   优点：日志文件体积最小，因为只记录一条SQL。
*   缺点：可能导致主从数据不一致。比如，如果SQL中使用了像`UUID()`、`NOW()`这类不确定性函数，或者使用了依赖于查询执行顺序的`LIMIT`语句，那么同一条SQL在主库和从库上执行的结果可能不同。

#### 2. ROW格式
*   特点：这是现在MySQL 5.7.7版本以后默认的、也是被广泛推荐的格式。它不记录SQL语句，而是记录了每一行数据被修改前后的具体内容。
    *   对于`INSERT`操作，它记录了要插入的整行数据。
    *   对于`DELETE`操作，它记录了被删除的整行数据。
    *   对于`UPDATE`操作，它记录了修改前和修改后的整行数据。
*   优点：非常安全，能够完美地保证主从数据的一致性，因为它是基于数据本身的变化来复制的。
*   缺点：日志文件体积会比STATEMENT格式大很多，特别是在执行`UPDATE`大表或者`DELETE`大量数据的操作时。

#### 3. MIXED格式
*   特点：这是STATEMENT和ROW格式的混合体。MySQL会根据执行的SQL语句来智能地选择使用哪种格式。
*   工作方式：对于一般的、确定性的SQL操作，它会使用STATEMENT格式来节省空间。但当它检测到可能导致主从不一致的SQL时（比如使用了不确定性函数），就会自动切换到ROW格式来记录。
*   优缺点：它试图在日志大小和数据一致性之间找到一个平衡点。但在实际应用中，由于其行为存在不确定性，现在大家更倾向于直接使用ROW格式，以获得最强的可靠性。

### Binlog的核心工作流程与相关参数

1.  事务执行与写入：当一个事务执行数据修改操作时，变更事件会被写入到一个内存缓冲区（Binlog Cache）。
2.  事务提交与刷盘：当事务提交时，MySQL会将Binlog Cache中的内容写入到磁盘上的Binlog文件中。这个刷盘的时机由`sync_binlog`参数控制：
    *   `sync_binlog = 0`（默认值，5.7.7前）：由操作系统决定何时刷盘，性能最好，但最不安全。数据库宕机可能丢失一部分已提交事务的Binlog。
    *   `sync_binlog = 1`：每次事务提交都强制将Binlog刷入磁盘，最安全，但性能影响最大。这是保证数据不丢失的推荐配置（“双1配置”之一）。
    *   `sync_binlog = N`（N>1）：每N次事务提交才刷一次盘。
