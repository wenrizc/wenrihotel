
### 幻读

为了理解如何解决幻读，我们先用一个例子来清晰地定义它。

假设我们有一个`products`表，事务A想查询所有价格低于100元的商品数量。

1. 事务A开始，执行查询：`SELECT COUNT(*) FROM products WHERE price < 100;`，假设得到的结果是10条。
    
2. 此时，事务B插入了一条新数据：`INSERT INTO products (name, price) VALUES ('new_product', 50);`，并且提交了事务。
    
3. 接着，事务A为了进行某些后续操作，再次执行了同一个查询：`SELECT COUNT(*) FROM products WHERE price < 100;`。这时，它得到的结果是11条。
    

对于事务A来说，第二次查询多出来的那一行数据就像一个“幻影”一样凭空出现了，这就是幻读。它破坏了事务的一致性，即在一个事务内部，相同查询条件的数据集应该是一致的。

三、InnoDB是如何解决幻读的？

InnoDB在RR级别下，主要通过两种技术的结合来解决幻读：

1. **MVCC (Multi-Version Concurrency Control) 多版本并发控制**
    
2. **Next-Key Locking (临键锁)**
    

**1. MVCC：应对“快照读”场景**

MVCC是InnoDB实现事务隔离的基础。它的核心思想是为每一行数据保存多个版本，每个版本都与一个事务ID相关联。

当一个RR级别的事务启动时，它会创建一个一致性视图（Read View）。这个视图记录了事务启动时所有活跃的（未提交的）事务ID。

当这个事务执行普通的`SELECT`查询（我们称之为“快照读”）时，InnoDB会根据以下规则从数据行的版本链中选择一个合适的版本返回：

- 只读取在事务启动前就已经提交的数据版本。
    
- 不读取在事务启动后才提交的数据版本。
    
- 不读取其他未提交事务产生的数据版本。
    

通过这个机制，MVCC可以很好地解决幻读问题中的一类情况。回到刚才的例子，如果事务A的第二次查询仍然是一个普通的`SELECT`，那么由于事务B的插入是在事务A的Read View创建之后提交的，事务A将“看不见”这条新插入的数据，查询结果依然会是10。

如果事务A中包含了更新、删除或加锁的查询（如 `SELECT ... FOR UPDATE` 或 `UPDATE ... WHERE ...`），这类查询被称为“当前读”。“当前读”需要读取数据库中最新的、已提交的版本，并对数据进行加锁。在这种情况下，MVCC就无法阻止幻读的发生了，因为事务A必须看到事务B新插入的数据。这时，就需要锁机制登场了。

**2. Next-Key Lock：应对“当前读”场景**

这是InnoDB解决幻读问题的关键所在。Next-Key Lock是InnoDB中一种特殊的锁，它可以看作是两种锁的结合体：

- **Record Lock (记录锁)**：锁定单个索引记录。
    
- **Gap Lock (间隙锁)**：锁定索引记录之间的“间隙”，防止其他事务在这个间隙中插入新的记录。
    

当一个事务执行“当前读”并带有范围条件时，InnoDB不仅会用Record Lock锁住满足条件的已有记录，还会用Gap Lock锁住这些记录之间的间隙，甚至包括查询范围边界之外的下一个键值之前的间隙。

我们再用刚才的例子来分析，假设`products`表的`price`字段有索引。

1. 事务A执行了一个加锁的当前读：`SELECT * FROM products WHERE price < 100 FOR UPDATE;`
    
2. InnoDB在处理这个查询时，会对`price`索引进行扫描。它不仅会锁住所有`price`小于100的现有记录（Record Lock），更重要的是，它会在这个查询范围内的所有间隙，以及`price`等于100这个值的“临界点”之前的间隙加上Gap Lock。例如，如果索引中有90和110两条记录，那么（90, 110）这个区间就会被锁定。
    
3. 现在，当事务B尝试`INSERT ... VALUES ('new_product', 50);`时，它需要获取`price`为50的索引位置的写锁。但由于50这个值落在了被事务A锁定的间隙之内，所以事务B的`INSERT`操作会被阻塞，必须等待事务A提交或回滚。
    

通过这种方式，Next-Key Lock阻止了任何可能满足事务A查询范围的新数据的插入，从而彻底杜绝了在“当前读”场景下幻读的发生。
