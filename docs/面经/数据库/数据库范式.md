
数据库范式（Normal Forms, NF）是设计关系型数据库时，为了减少数据冗余、提高数据一致性而遵循的一系列规范或准则。简单来说，它是一套指导你如何设计出结构良好、没有太多“垃圾”数据的表结构的规则。

范式的级别越高，数据冗余就越小，数据一致性就越好。通常，我们讨论最多的是第一范式（1NF）、第二范式（2NF）和第三范式（3NF），在大多数应用场景下，达到3NF就足够了。

### 为什么需要范式？

如果表结构设计不佳，会引发一系列问题，统称为“更新异常”：
1.  数据冗余：相同的数据在多个地方重复存储。
2.  插入异常：本应保存的数据，因为缺少某些其他信息而无法存入。
3.  更新异常：修改一条数据时，需要去修改多个地方，容易遗漏导致数据不一致。
4.  删除异常：删除某条数据时，导致一些本应保留的其他信息也一并丢失了。

范式化的过程，就是通过对表进行拆分（分解），来逐步消除这些异常。

---

### 第一范式 (1NF)

*   定义：确保表中的每个字段（列）都是不可再分的原子值。
*   通俗解释：每一列的值都应该是单一的，不能是一个集合、列表或包含多个值的字符串。这是关系型数据库最基本的要求。

*   例子：
    假设有一个“订单表”设计得不符合1NF：
    (不符合1NF的表)
| 订单ID | 客户姓名 | 商品 (Products) |
| :--- | :--- | :--- |
| 101 | 张三 | "苹果, 香蕉" |
| 102 | 李四 | "牛奶" |

    这个表中的“商品”列包含了多个值，不是原子的。这会导致你很难查询“所有购买了香蕉的订单”，也很难单独修改某个商品的价格或数量。

*   如何修正为1NF：
    将非原子列拆分成多行。
    (符合1NF的表)
| 订单ID | 客户姓名 | 商品 |
| :--- | :--- | :--- |
| 101 | 张三 | 苹果 |
| 101 | 张三 | 香蕉 |
| 102 | 李四 | 牛奶 |

现在，每一列都是原子值了，这就满足了第一范式。

---

### 第二范式 (2NF)

*   前提：必须先满足第一范式（1NF）。
*   定义：在1NF的基础上，消除“部分函数依赖”。也就是说，表中所有非主键列都必须完全依赖于整个主键，而不能只依赖于主键的一部分。
*   这个范式只针对“联合主键”（由多个列组成的主键）的情况。如果一个表只有一个单列作为主键，那么它只要满足1NF，就自动满足2NF。

*   核心概念：“函数依赖”。如果知道了A的值就能唯一确定B的值，我们称B函数依赖于A，记作 A -> B。例如，知道了学号，就能唯一确定学生的姓名（学号 -> 姓名）。

*   例子：
    我们有一个“学生选课成绩表”，主键是 (学号, 课程号)。
    (不符合2NF的表)
| 学号 | 课程号 | 学生姓名 | 课程名称 | 成绩 |
| :--- | :--- | :--- | :--- | :--- |
| S01 | C01 | 张三 | 计算机科学 | 85 |
| S01 | C02 | 张三 | 数据库原理 | 90 |
| S02 | C01 | 李四 | 计算机科学 | 78 |

    主键是 (学号, 课程号)。
    *   “成绩” 完全依赖于 (学号, 课程号)，因为某个学生某门课的成绩是唯一的。
    *   “学生姓名” 只依赖于 “学号”，与 “课程号” 无关。（学号 -> 学生姓名）
    *   “课程名称” 只依赖于 “课程号”，与 “学号” 无关。（课程号 -> 课程名称）
    这里，“学生姓名”和“课程名称”就对主键产生了“部分函数依赖”。

    这会带来问题：
    *   数据冗余：张三的名字“张三”和课程名“计算机科学”都重复出现了。
    *   更新异常：如果张三改名了，你需要修改所有他选的课程记录。
    *   插入异常：如果一个新学生刚入学还没选课，他的信息无法录入这张表，因为主键的一部分（课程号）是空的。
    *   删除异常：如果李四退选了“计算机科学”这门课，删掉记录后，李四这个学生的信息就从系统中消失了。

*   如何修正为2NF：
    进行拆分，把部分依赖的列分离出去，建立新的表。
    1.  学生表 (Student)
| 学号 (主键) | 学生姓名 |
| :--- | :--- |
| S01 | 张三 |
| S02 | 李四 |

    2.  课程表 (Course)
| 课程号 (主键) | 课程名称 |
| :--- | :--- |
| C01 | 计算机科学 |
| C02 | 数据库原理 |

    3.  选课成绩表 (Score)
| 学号 (外键) | 课程号 (外键) | 成绩 |
| :--- | :--- | :--- |
| S01 | C01 | 85 |
| S01 | C02 | 90 |
| S02 | C01 | 78 |
    (学号, 课程号) 是这张表的联合主键。

经过拆分后，所有表都满足了第二范式，解决了之前的更新异常问题。

---

### 第三范式 (3NF)

*   前提：必须先满足第二范式（2NF）。
*   定义：在2NF的基础上，消除“传递函数依赖”。也就是说，表中所有非主键列都不能依赖于其他非主键列。
*   通俗解释：一个非主键列不能由另一个非主键列决定。所有非主键列都必须直接依赖于主键，不能间接依赖。

*   例子：
    我们继续看“学生表”，并增加一些字段。
    (不符合3NF的表)
| 学号 (主键) | 学生姓名 | 所在院系ID | 院系名称 |
| :--- | :--- | :--- | :--- |
| S01 | 张三 | D01 | 计算机学院 |
| S02 | 李四 | D02 | 外国语学院 |
| S03 | 王五 | D01 | 计算机学院 |

    在这个表中：
    *   学号 -> 所在院系ID (学生属于哪个院系是确定的)
    *   所在院系ID -> 院系名称 (院系的ID和名称是一一对应的)
    因此，存在一个传递依赖链：学号 -> 所在院系ID -> 院系名称。
    “院系名称”这个非主键列，依赖于“所在院系ID”这个非主键列，这就违反了3NF。

    这会带来问题：
    *   数据冗余：“计算机学院”这个名字重复了。
    *   更新异常：如果计算机学院改名为“人工智能学院”，你需要修改所有属于该学院的学生记录。

*   如何修正为3NF：
    将传递依赖的列分离出去，建立新表。
    1.  学生表 (Student)
| 学号 (主键) | 学生姓名 | 所在院系ID (外键) |
| :--- | :--- | :--- |
| S01 | 张三 | D01 |
| S02 | 李四 | D02 |
| S03 | 王五 | D01 |

    2.  院系表 (Department)
| 院系ID (主键) | 院系名称 |
| :--- | :--- |
| D01 | 计算机学院 |
| D02 | 外国语学院 |

现在，所有非主键列都直接依赖于它们所在表的主键，满足了第三范式。
