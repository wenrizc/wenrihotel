
### 读未提交 (Read Uncommitted)

*   实现方式：这是最简单的级别，因为它几乎什么都不做。
*   写操作：对数据的修改会加上排他锁，防止其他写操作并发进行。
*   读操作：执行`SELECT`时，完全不加任何锁，也不使用MVCC。它直接读取内存中数据的最新版本，无论修改它的事务是否已经提交。
*   结果：由于读操作没有任何限制，它可以直接看到其他事务尚未提交的修改，因此会发生脏读。

### 读已提交 (Read Committed / RC)

这是大多数主流数据库的默认隔离级别。

*   实现方式：主要依赖MVCC。
*   写操作：依然是加排他锁，保证写操作的原子性。
*   读操作：
    *   它的关键实现细节在于ReadView的创建时机：在RC级别下，每一次执行`SELECT`语句，都会生成一个新的ReadView（读视图）。
    *   这个ReadView记录了在`SELECT`开始的那一刻，系统中所有活跃（未提交）的事务ID。
    *   当读取某行数据时，InnoDB会使用这个ReadView来判断数据的哪个版本是可见的。它只会看到在它这个`SELECT`语句开始之前，就已经提交了的事务所做的修改。
*   结果：
    *   解决了脏读：因为每次读都基于一个快照，这个快照排除了所有未提交的事务，所以不会读到脏数据。
    *   会发生不可重复读：在一个事务内，如果第一次`SELECT`和第二次`SELECT`之间，有另一个事务提交了对数据的修改，那么第二次`SELECT`会生成一个新的ReadView，这个新的ReadView就能看到那个已提交的修改，导致两次读取结果不一致。

### 可重复读 (Repeatable Read / RR)

这是MySQL InnoDB引擎的默认隔离级别。

*   实现方式：主要依赖MVCC，并辅以锁机制来解决幻读。
*   写操作：加排他锁。
*   读操作 (快照读 - 普通`SELECT`)：
    *   与RC级别最大的不同在于ReadView的创建时机：ReadView只在事务中的第一个`SELECT`语句执行时创建一次，并且在整个事务的生命周期内，都会复用这同一个ReadView。
    *   因为整个事务期间使用的读视图是固定的，所以无论其他事务如何修改并提交数据，当前事务看到的永远是它启动那一刻的数据快照。
*   结果 (快照读)：
    *   解决了不可重复读：由于ReadView不变，事务内部多次读取同一行数据，看到的结果永远是一致的。
*   当前读 (Current Read - `SELECT...FOR UPDATE`, `UPDATE`, `DELETE`) 与幻读的解决：
    *   对于需要加锁的当前读操作，仅仅依靠MVCC是不够的，因为它需要读取数据的最新版本。
    *   为了防止在当前读的场景下发生幻读（即一个事务在两次范围查询之间，另一个事务插入了新的记录），InnoDB引入了Next-Key Locking，也就是临键锁。
    *   临键锁是记录锁和间隙锁的结合体。当执行一个范围查询的当前读时，InnoDB不仅会锁住满足条件的记录（记录锁），还会锁住这些记录之间的间隙（间隙锁），从而阻止其他事务在这个范围内插入新数据。
    *   通过这种方式，InnoDB在RR级别下，有效地防止了幻读的发生。

### 可串行化 (Serializable)

*   实现方式：完全不使用MVCC，退回到纯粹的锁模型。
*   写操作：加排他锁。
*   读操作：不再是快照读。对于所有的`SELECT`语句，都会隐式地在它读取的每一行数据上加上共享锁，也称为S锁。
*   结果：
    *   解决了所有并发问题（脏读、不可重复读、幻读）。
    *   由于读会加共享锁，写会加排他锁，读和写之间会互相阻塞，写和写之间也会互相阻塞。这相当于强制所有事务串行执行，一个接一个。
    *   并发性能极差，因此在实际应用中非常罕见。

| 隔离级别 | 实现核心技术 | ReadView创建时机 | 是否使用间隙锁 |
| :--- | :--- | :--- | :--- |
| 读未提交 | 无锁 | 不使用 | 否 |
| 读已提交 | MVCC | 每条`SELECT`创建一次 | 否 |
| 可重复读 | MVCC + 临键锁 | 事务首次`SELECT`创建一次 | 是（用于当前读） |
| 可串行化 | 纯粹的锁机制 | 不使用 | 是（所有读都加锁） |
