
当两个事务（我们称之为事务A和事务B）同时尝试修改同一条记录，并且此时有另一个读操作（我们称之为事务C或当前事务的一个读操作）去读取这条记录时，读到的结果会怎样，以及是否一样，这完全取决于以下几个关键因素：

1.  数据库的事务隔离级别。
2.  读操作的类型（是当前读还是快照读）。
3.  事务A和事务B的执行顺序、它们是否已提交，以及它们持有锁的情况。

我们以MySQL的InnoDB存储引擎为例，并分析在不同隔离级别下的情况。InnoDB默认的隔离级别是可重复读（Repeatable Read）。

情况分析：

假设记录的初始值为 V0。
事务A：尝试将记录修改为 V_A。
事务B：尝试将记录修改为 V_B。

场景一：一个事务修改，另一个事务读取（在修改事务提交前后）

*   如果事务A修改记录为V_A但尚未提交：
    *   在读未提交（Read Uncommitted）隔离级别下：事务C的读操作（无论是快照读还是当前读）可能会读取到V_A（脏读）。
    *   在读已提交（Read Committed, RC）隔离级别下：
        *   事务C的快照读会读取到V0（事务A提交前的版本）。
        *   事务C的当前读（如`SELECT ... FOR UPDATE`）会等待事务A释放锁（即事务A提交或回滚）。如果A提交，C将读到V_A；如果A回滚，C将读到V0。
    *   在可重复读（Repeatable Read, RR）隔离级别下：
        *   事务C的快照读（如果事务C在事务A开始修改前或事务A修改但未提交时启动）会读取到V0（事务C开始时的快照版本）。
        *   事务C的当前读会等待事务A释放锁。
    *   在串行化（Serializable）隔离级别下：所有读都会加锁，行为类似于RR下的当前读，会等待。

*   如果事务A修改记录为V_A并已提交：
    *   在读未提交隔离级别下：事务C的读操作会读取到V_A。
    *   在读已提交隔离级别下：
        *   事务C的快照读（如果事务C在事务A提交后启动，或者其快照是在A提交后生成的）会读取到V_A。
        *   事务C的当前读会读取到V_A。
    *   在可重复读隔离级别下：
        *   事务C的快照读（如果事务C在事务A提交前启动）仍然会读取到V0（基于其事务开始时的快照）。
        *   事务C的快照读（如果事务C在事务A提交后启动）会读取到V_A。
        *   事务C的当前读会读取到V_A。
    *   在串行化隔离级别下：会读取到V_A。

场景二：两个事务同时修改同一条记录

这种情况通常意味着发生了写-写冲突。数据库的并发控制机制（主要是锁）会介入。

*   通常，第一个成功获取到该记录排他锁（X锁）的事务（比如事务A）可以进行修改。
*   第二个事务（事务B）在尝试修改同一条记录时，会发现记录已被锁定，它会被阻塞，直到事务A释放锁（提交或回滚）。

现在，我们再考虑事务C的读操作：

假设事务A先获取了锁并修改记录为V_A（但未提交），事务B被阻塞等待。

*   此时事务C去读：
    *   行为与场景一中“事务A修改记录为V_A但尚未提交”的情况类似，取决于C的隔离级别和读类型。
        *   例如，在RR级别下，事务C的快照读会读到V0（如果C在A修改前开始）。当前读会等待A。

假设事务A提交（释放锁），记录变为V_A。然后事务B被唤醒，获取锁，并将记录修改为V_B（但未提交）。

*   此时事务C去读：
    *   行为与场景一中“一个事务（现在是B）修改记录为V_B但尚未提交”的情况类似。
        *   例如，在RR级别下，事务C的快照读仍然是V0（如果C在A和B修改前开始）。当前读会等待B。

读到的结果是否一样？

这取决于“读”这个动作发生的时间点、读的类型、以及两个修改事务的提交状态和顺序。

1.  如果两次读操作都发生在两个修改事务都未开始之前，那么两次读到的都是V0，结果一样。

2.  如果第一次读在事务A修改并提交之后（记录为V_A），第二次读在事务B修改并提交之后（记录为V_B），那么：
    *   在RC隔离级别下：
        *   如果两次都是快照读，且快照生成时间点不同（第一次在A提交后B修改前，第二次在B提交后），则第一次读到V_A，第二次读到V_B，结果不一样。
        *   如果两次都是当前读，则第一次读到V_A，第二次读到V_B，结果不一样。
    *   在RR隔离级别下：
        *   如果两次都是同一个事务C中的快照读，且事务C开始于A和B的修改之前，那么两次都会读到V0，结果一样（可重复读）。
        *   如果两次是不同事务的快照读，或者同一个事务C的快照是在不同时间点生成的（这在RR下不常见，除非是不同语句的快照点），则可能不一样。
        *   如果两次都是当前读，则第一次可能读到V_A（如果A已提交，B未开始或未提交），第二次可能读到V_B（如果B已提交），结果可能不一样。

3.  如果两个修改事务并发执行，并且读操作也在此期间发生：
    *   由于锁机制，两个修改事务对同一条记录的修改在物理上是串行的（一个先完成，另一个后完成）。
    *   读操作的结果会根据其隔离级别和发生时间点，看到某个已提交的版本，或者被阻塞。
    *   在RC级别下，连续两次快照读如果跨越了一个写事务的提交，结果会不一样。
    *   在RR级别下，同一个事务内的连续两次快照读，结果会一样（除非是本事务自己修改了）。

总结：

*   两个事务修改同一条记录，由于锁机制，它们的修改在数据库层面通常是串行化的（一个先完成，一个后完成）。
*   此时再去读这个记录：
    *   读到的值取决于当前事务的隔离级别、是快照读还是当前读，以及在读操作发生时，那两个修改事务的提交状态。
    *   在RC隔离级别下，如果两次读之间有写事务提交，则两次读到的结果可能不一样（不可重复读）。
    *   在RR隔离级别下，同一个事务内的多次快照读，结果会是一样的（可重复读）。但如果是当前读，或者不同事务的读，则结果可能因为其他事务的提交而不同。
    *   最终，当所有修改事务都提交后，任何新的读操作（在合适的隔离级别下）都会读到最后那个成功提交的事务所写入的值。

