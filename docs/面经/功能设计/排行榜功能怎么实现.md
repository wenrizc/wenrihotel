
排行榜功能可以通过 **Redis 的 Sorted Set（有序集合）** 实现，利用其底层跳表数据结构高效存储和查询有序数据。核心步骤包括：将用户 ID 和分数存入 Sorted Set，按分数排序，支持快速插入、更新、查询排名和范围数据，适用于实时性高、并发大的场景。

---

### 关键事实

1. **技术选择**：
    - **Redis Sorted Set**：适合内存操作，查询和更新效率高（O(log N)）。
    - **数据库**（如 MySQL）：适合持久化存储，但查询排序慢（需索引优化）。
    - **内存缓存 + 定时同步**：结合 Redis 和数据库，兼顾性能和持久性。
2. **核心功能**：
    - **添加/更新分数**：用户得分变化时更新。
    - **查询排名**：获取某用户的排名。
    - **范围查询**：获取前 N 名或指定分数段用户。
    - **实时性**：支持高并发更新和查询。
3. **Redis 实现**：
    - 数据结构：ZSET，键为排行榜名，成员为用户 ID，分数为得分。
    - 常用命令：
        - ZADD：添加或更新分数。
        - ZRANK：查询排名。
        - ZRANGE：获取前 N 名。
### 延伸与面试角度

- **为什么用 Sorted Set？**
    - 跳表实现，插入、查询、范围操作均为 **O(log N)**，远优于链表（O(N)）。
    - 内存操作，延迟低，适合实时排行榜。
- **优化方案**：
    - **分片存储**：数据量大时，按区间（如 0-1000 分）分多个 ZSET。
    - **缓存 + 持久化**：Redis 存实时数据，定时同步到 MySQL。
    - **去重处理**：分数相同时，按时间戳或 ID 排序（用复合分数，如 score.timestamp）。
- **高并发支持**：
    - Redis 单线程 + 多线程 I/O（6.0+）处理大量请求。
    - 加锁（如 Redis 分布式锁）避免更新冲突。
- **替代方案**：
    - **数据库**：用索引字段（如 score）排序，但高并发下性能差。
    - **内存结构**：如 Java 的 TreeMap，自建跳表，但需手动管理分布式场景。
- **实际应用**：
    - 游戏排行榜：实时更新玩家分数，展示前 100 名。
    - 电商活动：用户积分排名，动态刷新。
    - 
**跳表（Skip List）** 是一种随机化的数据结构，基于有序链表，通过多层索引加速查找、插入和删除操作。它的平均时间复杂度为 **O(log N)**，结合了链表的简单性和二叉搜索树的效率，广泛用于需要动态排序的场景，如 Redis 的 Sorted Set。
1. **基本结构**：
    - 底层是完整的有序链表，包含所有元素。
    - 上层是稀疏索引，每层节点是下层节点的子集，通过指针连接。
    - 层数随机生成，通常最高层到第 0 层（底层）。
2. **工作原理**：
    - **查找**：从最高层开始，沿索引向右或向下移动，快速定位目标。
    - **插入**：随机决定新节点的层数，插入到对应层并调整指针。
    - **删除**：移除节点并更新各层指针。
3. **时间复杂度**：
    - 平均 **O(log N)**（查找、插入、删除），因层数是对数级别。
    - 最坏 **O(N)**（极端随机情况，但概率极低）。
4. **空间复杂度**：
    - **O(N)**，每节点可能有多层指针，但实际占用比理论少。