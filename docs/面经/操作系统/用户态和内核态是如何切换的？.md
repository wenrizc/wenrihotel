
### 用户态和内核态

CPU通常设计了多个权限级别（Privilege Levels），最基本的就是用户态（User Mode）和内核态（Kernel Mode，也叫特权态、系统态、管态）。

*   内核态：操作系统内核运行在该模式下。在此模式下，CPU可以执行所有指令，访问所有内存和硬件资源。这是最高权限级别。
*   用户态：应用程序运行在该模式下。在此模式下，CPU执行的指令和可访问的资源受到限制。例如，用户态程序不能直接访问硬件设备，不能直接修改关键的系统数据结构，不能执行某些特权指令。

这种区分的主要目的是：

*   保护操作系统：防止用户程序意外或恶意地破坏操作系统内核，从而保证系统的稳定性。
*   资源管理：操作系统作为资源管理者，需要有能力统一调度和分配CPU时间、内存、I/O设备等，用户程序只能通过操作系统提供的接口来请求这些资源。
*   提供抽象：操作系统向用户程序提供简洁、一致的接口（如系统调用），屏蔽底层硬件的复杂性。

### 切换的触发条件

从用户态切换到内核态，通常由以下三种情况触发：

1.  系统调用（System Call）：
    *   这是最常见的主动切换方式。用户程序为了获得操作系统提供的服务（如文件操作、进程管理、网络通信等），会主动请求内核。例如，当一个C程序调用`open()`、`read()`、`fork()`等库函数时，这些库函数内部会封装一个或多个系统调用。

2.  中断（Interrupt）：
    *   这是被动的切换方式。当中断发生时，CPU会暂停当前正在执行的用户程序，转而去执行内核中的中断处理程序。
    *   硬件中断：由外部硬件设备产生，例如磁盘I/O完成、网络数据包到达、定时器到期等。
    *   软件中断：通常指由特定指令（如x86的`INT n`指令）引发的中断，系统调用在某些架构上也通过特定的软件中断指令实现。

3.  异常（Exception）或陷阱（Trap）：
    *   这也是被动的切换方式。当CPU在执行用户态指令时，如果发生了错误或特殊情况（如除零错误、缺页故障、访问非法内存地址、执行了非法指令等），CPU会捕获这些异常，并切换到内核态，由内核来处理这些异常。

### 具体的切换过程

以系统调用为例，切换过程大致如下（不同CPU架构细节可能有所不同，但原理相似）：

1.  准备阶段（用户态）：
    *   用户程序将系统调用号（标识请求哪个服务）和参数保存到CPU的特定寄存器或内存的约定位置。
    *   用户程序执行一条特殊的“陷入指令”或“陷阱指令”（Trap Instruction），例如x86架构下的`SYSCALL` (较新的方式) 或 `INT 0x80` (传统方式)，ARM架构下的`SVC` (Supervisor Call) 指令。

2.  硬件执行阶段：
    *   当CPU执行这条陷入指令时，硬件会自动完成以下一些操作：
        *   将CPU的当前模式从用户态切换到内核态。这通常是通过修改CPU状态寄存器中的某个标志位实现的。
        *   保存当前用户态的上下文信息，至少包括：
            *   程序计数器（PC，指向下一条要执行的用户指令）
            *   用户栈指针（User Stack Pointer）
            *   某些关键的CPU状态寄存器（如程序状态字PSW）
            这些信息通常会被保存到内核栈或者一个预定义的内存区域。
        *   CPU根据陷入指令的类型或系统调用号（或中断/异常号），查询一个由操作系统预先设置好的表，称为中断描述符表（IDT）或系统调用向量表。这个表存放了所有内核提供的服务例程（中断处理程序、系统调用处理程序）的入口地址。
        *   CPU跳转到该表中查找到的内核处理程序的入口地址开始执行。

3.  内核执行阶段（内核态）：
    *   内核处理程序首先会做进一步的上下文保存，例如保存用户态的其他通用寄存器的值到内核栈中。这是因为内核代码可能需要使用这些寄存器，并且在返回用户态时需要恢复它们。
    *   内核会切换到内核栈（每个进程通常都有自己的内核栈）。
    *   内核根据系统调用号和传递的参数，执行相应的内核服务代码。
    *   在执行期间，内核拥有完全的权限，可以访问所有硬件和内存。

### 从内核态如何返回用户态

当内核服务执行完毕，或者中断/异常处理完成后，需要从内核态返回到用户态：

1.  内核准备返回：
    *   内核将系统调用的返回值（如果有）存放到约定的寄存器中。
    *   内核从内核栈中恢复之前保存的用户态通用寄存器。

2.  执行特权返回指令：
    *   内核执行一条特殊的“返回指令”，例如x86架构下的`SYSRET` (与`SYSCALL`对应) 或 `IRET` (中断返回)，ARM架构下的`ERET`。
    *   这条指令会使CPU完成以下操作：
        *   将之前保存的用户态PC、用户栈指针和CPU状态寄存器等恢复到CPU中。
        *   将CPU的当前模式从内核态切换回用户态。

3.  继续用户态执行：
    *   CPU从之前保存的用户态PC指向的指令处，继续执行用户程序。

用户态和内核态的切换是一个由硬件和操作系统内核紧密协作完成的过程。它通过一个明确定义的接口（陷入指令、中断向量表）和严格的上下文保存与恢复机制，确保了在提供强大功能的同时，系统的安全性和稳定性不受损害。这个切换过程虽然有一定的开销（涉及到寄存器操作、栈切换、可能的TLB刷新等），但对于现代操作系统的设计是不可或缺的。

