
死锁（Dead Lock）指的是在多任务系统中，两个或两个以上的运算单元（进程、线程或协程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法继续执行下去。

**死锁产生的原因（四个必要条件）**

死锁的发生必须同时满足以下四个条件，缺一不可:

1.  **互斥条件（Mutual Exclusion）**：指资源一次只能被一个进程（或线程）占用，即在一段时间内某个资源只能被一个运算单元所占用，不能被共享。这是许多系统资源的固有特性，通常难以破坏。
2.  **请求与保持条件（Hold and Wait）**：指进程（或线程）已经持有至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占用，此时请求进程阻塞，但对自己已获得的资源保持不放。
3.  **不可剥夺条件（No Pre-emption）**：指进程（或线程）已获得的资源在未使用完之前，不能被其他进程强行剥夺，只能在使用完时由自己释放。
4.  **环路等待条件（Circular Wait）**：指在发生死锁时，必然存在一个进程-资源的环形链。即若干进程之间形成一种头尾相接的循环等待资源的关系，每个进程都在等待下一个进程所占用的资源。

**解决死锁的方法**

解决死锁问题通常有四种基本方法：死锁预防、死锁避免、死锁检测与恢复。要解决死锁，只需要破坏其产生的四个必要条件中的一个或多个即可。

1.  **死锁预防（Deadlock Prevention）**
    通过设置一些限制条件，破坏死锁产生的四个必要条件之一，严格防止死锁的发生。
    *   **破坏“互斥条件”**：
        对于可共享的资源，允许多个进程同时访问。然而，很多资源（如打印机）本身就是互斥的，此条件通常难以被破坏。
    *   **破坏“请求和保持条件”**：
        *   **一次性分配所有资源**：要求进程在开始运行前一次性申请其在整个运行过程中所需的所有资源。如果所需资源不能全部满足，则不分配任何资源。这可以有效防止死锁，但可能导致资源利用率低和进程长时间等待。
        *   **释放已占有资源**：要求进程在申请新的资源时，如果不能立即得到满足，必须释放已占有的所有资源。
    *   **破坏“不可剥夺条件”**：
        允许系统在某个进程等待新的资源时，剥夺其已占有的资源。例如，当进程P1请求资源R，R被P2占用，如果P2也正在等待其他资源，P1可以剥夺P2的R资源。
    *   **破坏“环路等待条件”**：
        对所有资源进行线性排序（编号），要求进程必须按照资源编号递增的顺序请求资源，并且只能在释放编号较高的资源后才能请求编号较低的资源。这可以防止形成循环等待。

2.  **死锁避免（Deadlock Avoidance）**
    死锁避免不限制产生死锁的必要条件存在，而是在系统运行时对进程发出的每一个系统可能满足的资源申请进行动态检查，并根据检查结果决定是否分配资源。如果分配后系统可能进入不安全状态（可能发生死锁），则不予分配；否则予以分配。
    *   **银行家算法（Banker's Algorithm）**：这是最著名的死锁避免算法，它通过判断系统是否处于安全状态来决定是否分配资源。系统维护一个安全状态，如果分配资源后系统仍然处于安全状态，则允许分配；否则拒绝。

3.  **死锁检测（Deadlock Detection）**
    允许死锁的发生，但系统会定期地检测死锁是否存在。一旦检测到死锁，就采取措施进行恢复。
    *   **资源分配图算法**：通过构建资源分配图（Resource Allocation Graph, RAG）来描述系统中资源的分配和请求情况。如果图中存在环路，则可能发生死锁。通过简化资源分配图来检测系统是否处于死锁状态，如果无法完全简化，则表明存在死锁。
    *   **等待图算法**：对于每种资源只有一个实例的情况，可以将资源分配图转换为等待图，如果等待图中存在环路，则表示发生了死锁。

4.  **死锁恢复（Deadlock Recovery）**
    当检测到死锁发生时，采取措施解除死锁，使系统从死锁状态中恢复过来。
    *   **进程终止法（Process Termination）**：
        *   **终止所有死锁进程**：最简单粗暴的方式是终止所有参与死锁的进程。代价是之前的工作全部丢失。
        *   **逐个终止进程**：按照一定的顺序（如进程优先级、已消耗CPU时间等）逐个终止死锁进程，直到死锁解除。
    *   **资源剥夺法（Resource Preemption）**：
        挂起某些死锁进程，并抢占其资源，将这些资源分配给其他死锁进程，从而打破死锁。需要注意防止被挂起的进程长时间得不到资源。
    *   **进程回退法（Rollback）**：
        让一个或多个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。这要求系统能够保存进程的历史信息，并设置还原点。

在实际编程中，为了避免死锁，通常建议遵循以下策略：
*   以固定的顺序访问表和行，即按顺序申请锁，避免交叉等待。
*   将大事务拆分为小事务，因为大事务更容易导致死锁。
*   在同一个事务中，尽可能一次性锁定所有需要的资源。
*   为表添加合理的索引，以减少锁的范围和时间。
*   时刻检查程序在跳出时是否忘记释放锁。
*   对于可能重复使用锁的模块，考虑使用嵌套锁。