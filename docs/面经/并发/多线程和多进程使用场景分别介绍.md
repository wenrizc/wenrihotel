
### 多线程 (Multithreading)

#### 核心特点
1.  资源共享：这是多线程最显著的特点。同一进程下的所有线程共享该进程的内存空间（如堆内存、方法区）、文件描述符等资源。
2.  轻量级：线程被称为“轻量级进程”。创建、销毁和切换线程的开销，远小于进程。
3.  通信方便：因为共享内存，线程之间的通信非常直接和高效。可以直接读写共享变量，或使用共享的数据结构（如队列）来传递信息。
4.  同步复杂：正是因为共享资源，为了防止数据竞争和不一致，必须使用锁、信号量等同步机制来小心地保护共享数据，这增加了编程的复杂度，也容易引入死锁等问题。
5.  稳定性差：一个线程的崩溃（如未捕获的异常）可能会导致整个进程退出，影响所有其他线程。

#### 使用场景
多线程非常适合于那些需要频繁进行数据共享、或者任务之间有紧密协作需求的场景，特别是I/O密集型应用。

1.  I/O密集型任务：
    当一个任务需要等待网络响应或磁盘读写时，CPU是空闲的。多线程可以让CPU在某个线程等待I/O时，切换到另一个就绪的线程去执行计算任务，从而充分利用CPU，提高程序的整体吞吐量和响应速度。
    *   示例：Web服务器（如Tomcat）。主线程负责监听连接，每当有新的请求到来，就从线程池中取一个工作线程来处理。这些工作线程可能需要访问共享的缓存、数据库连接池等。

2.  需要高响应性的GUI应用：
    在桌面应用中，通常会有一个专门的UI线程负责界面的渲染和事件响应。如果把耗时的操作（如下载文件、复杂计算）也放在UI线程中，界面就会卡死。正确的做法是将这些耗时操作放到一个或多个后台工作线程中去执行，完成后再通知UI线程更新界面，保证了用户体验的流畅。

3.  生产者-消费者模型：
    一个或多个线程负责生产数据并放入一个共享的缓冲区（队列），同时一个或多个线程从缓冲区中取出数据进行消费。这种模型天然地需要共享数据结构，非常适合用多线程实现。

### 多进程 (Multiprocessing)

#### 核心特点
1.  资源隔离：每个进程都有自己独立的内存地址空间、文件句柄等资源。一个进程无法直接访问另一个进程的内存。
2.  重量级：创建、销毁和切换进程的开销都比较大，因为涉及到操作系统内核分配和回收独立的资源。
3.  通信复杂：进程间的通信（IPC, Inter-Process Communication）需要通过操作系统提供的机制，如管道（Pipe）、套接字（Socket）、消息队列（Message Queue）、共享内存（Shared Memory）等，相对复杂且速度较慢。
4.  同步简单：由于内存不共享，天然避免了数据竞争问题，同步的需求主要体现在IPC的过程中。
5.  稳定性高：一个进程的崩溃通常不会影响到其他进程，操作系统会负责回收其资源。

#### 使用场景
多进程非常适合于那些需要利用多核CPU进行并行计算的场景，或者对稳定性和安全性要求极高的场景。

1.  CPU密集型任务：
    对于需要大量计算的任务（如科学计算、视频编码、大数据分析），可以通过创建多个进程，将任务拆分给每个进程，让它们在不同的CPU核心上并行执行，从而真正地利用多核处理器的计算能力，缩短总的计算时间。在Python中，由于GIL（全局解释器锁）的存在，多进程是实现CPU并行计算的唯一途径。

2.  需要隔离和稳定性的应用：
    现代浏览器（如Chrome）就是一个典型的多进程架构。每个标签页、每个插件都可能运行在独立的进程中。这样做的好处是，即使某个网页或插件崩溃了，也只会影响它自己的进程，而不会导致整个浏览器崩溃，极大地提升了稳定性和安全性。

3.  执行外部程序：
    当一个程序需要调用另一个独立的外部程序时，它会创建一个新的进程来运行那个程序。

| 特性 | 多线程 | 多进程 |
| :--- | :--- | :--- |
| 资源共享 | 共享内存，通信方便 | 内存隔离，通信复杂 |
| 创建/切换开销 | 小，轻量级 | 大，重量级 |
| 稳定性/隔离性 | 差，一荣俱荣，一损俱损 | 好，进程间互不影响 |
| 编程复杂度 | 同步复杂，易出错 | IPC复杂，同步相对简单 |
| 适用场景 | I/O密集型，任务间需共享数据 | CPU密集型，需要隔离和稳定性 |
