
### 多进程

多进程是指在一个操作系统中同时运行多个独立的程序，或者一个程序被分成多个独立的执行单元，每个单元都是一个独立的进程。每个进程都拥有自己独立的地址空间、内存、文件句柄等资源。进程之间互相独立，一个进程的崩溃通常不会影响到其他进程或主程序的稳定性。进程是操作系统进行资源分配和调度的基本单位。

**优点：**
*   **独立性高、稳定性强：** 每个进程都拥有独立的地址空间和资源，互相独立。一个子进程的崩溃不会影响到主程序或其他子进程的稳定性。
*   **易于扩展性能：** 可以通过增加CPU核心数量，方便地扩展整个系统的性能。
*   **减少锁竞争：** 由于进程间不直接共享内存，可以尽量减少线程加锁/解锁的影响，从而在某些情况下极大提高性能，即使某些模块算法效率较低也无妨。
*   **总性能上限高：** 每个子进程都有独立的地址空间和相关资源，能够达到的总体性能上限非常大。
*   **适用于UNIX/Linux环境：** 在UNIX/Linux环境下，进程调度效率很高，且调度开销与线程调度开销没有显著区别。TUXEDO等高性能中间件也倾向于采用多进程架构。

**缺点：**
*   **资源消耗大、创建销毁慢：** 启动新进程需要分配独立的地址空间和建立众多数据表，这是一种“昂贵”的多任务方式，系统开销明显大于创建或撤销线程。
*   **通信复杂：** 进程间内存无法直接共享，通信（IPC）机制相对复杂，通常需要通过管道、消息队列、共享内存、套接字等方式进行，这对于大数据量传输不太方便，更适合小数据量传输和密集运算。
*   **逻辑控制相对复杂：** 需要处理进程间通信和协调，程序逻辑控制会比多线程更复杂。

**适合场景：**
*   **高稳定性要求：** 对程序的健壮性要求极高，不希望一个模块的错误影响整个系统。
*   **独立且并发的任务：** 任务之间相对独立，不需要频繁共享大量数据，但需要高度并行执行。
*   **安全隔离：** 需要在不同进程之间进行安全隔离，例如运行不可信的代码。
*   **分布式系统和服务器：** 特别是高性能交易服务器中间件，如TUXEDO，倾向于多进程架构以实现高并发和高吞吐量。
*   **UNIX/Linux服务器开发：** 考虑到UNIX家族从多进程发展而来，且进程调度效率高，多进程在这些系统下通常表现优异。
### 多线程

多线程是指在一个进程内部，创建和运行多个独立的执行流。这些执行流称为线程。所有线程共享所属进程的地址空间、文件句柄等资源，但每个线程有自己独立的程序计数器、栈和寄存器。线程是CPU调度的基本单位，它是一种“节俭”的多任务操作方式。
多线程和多进程在不同的场景下各有优劣，因此在实际编程中需要根据具体需求进行权衡和选择。


**优点：**
*   **资源消耗低、创建销毁快：** 线程被认为是“节俭”的多任务操作方式。它们共享相同的地址空间，启动和切换的开销远小于进程，因为系统无需为每个线程分配独立的地址空间和建立大量的数据表。
*   **数据共享方便：** 由于线程在同一进程内共享内存空间，它们之间的数据交换非常便捷和快速。
*   **逻辑和控制简单：** 在无需跨进程边界的情况下，程序逻辑和控制方式相对简单。
*   **有效利用多CPU：** 操作系统可以确保当线程数不超过CPU数量时，不同的线程运行在不同的CPU上，从而有效利用多核处理器。
*   **改善程序结构：** 可以将一个长而复杂的程序拆分为多个独立或半独立的线程部分，有助于理解和修改。

**缺点：**
*   **同步与加锁复杂：** 线程之间共享内存虽然方便，但也引入了复杂的同步和加锁控制问题，容易出错，可能导致死锁或数据不一致。
*   **稳定性风险：** 由于共享地址空间，一个线程的崩溃可能影响到整个程序的稳定性，导致整个进程崩溃。
*   **地址空间限制：** 每个线程与主程序共用地址空间，可能会受限于总体的地址空间大小（例如，传统32位系统2GB的限制，尽管现代64位系统已大大缓解）。
*   **性能上限有限：** 线程数量达到一定程度后，即使增加CPU也无法提高性能，甚至因为线程调度本身的开销（需要保存线程状态，频繁调度占用大量机时）而导致性能下降。

**适合场景：**
*   **轻量级并发任务：** 当任务需要频繁创建和销毁，或者任务之间需要大量共享数据时。
*   **CPU密集型任务：** 在合理控制线程数量（不超出CPU核心数太多）的情况下，利用多核进行并行计算。
*   **响应用户界面：** 在GUI应用程序中，将耗时操作放到后台线程，以保持界面响应。
*   **模块化程序结构：** 将一个大型复杂程序分解为多个功能独立的执行单元。

### 结合

在实际应用中，单单选择多线程或多进程可能都不是最优解。更常见且高效的做法是多进程和多线程结合。

*   **策略：** 一个常见的策略是，根据CPU核心数开启相应数量的子进程（例如，每个CPU核心开启一个子进程），然后在每个子进程内部再开启多线程来处理同类型的数据或执行更细粒度的并发任务。
*   **考虑数据传输量：** 如果任务之间需要传输的数据量大，且频繁，则倾向于在进程内部使用多线程。如果数据传输量小，但需要高度隔离和稳定性，或者任务是计算密集型的，则可以考虑多进程。
*   **系统环境：** 在UNIX/Linux环境下，多进程的开销相对较小，效率较高，因此多进程是一个非常可行的选择，尤其是在构建高性能服务器时。而在Windows环境下，由于其在线程切换和锁性能上的优势，多线程可能在某些场景下表现更佳。
*   **编程复杂度：** 如果对开发速度和代码简洁性有较高要求，且对稳定性要求可以稍作妥协，多线程可能更具吸引力。反之，如果能接受更高的开发复杂度和维护成本以换取更高的稳定性和可扩展性，多进程或混合模式更为合适。
*   **内存消耗：** 尽管现在内存价格便宜，服务器动辄若干GB内存，多进程额外的全局数据区消耗不再是主要问题，但仍需在设计时考虑。
