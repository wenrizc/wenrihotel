
### 死锁

在多线程中，死锁指的是两个或多个线程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力干涉，它们都将无法继续向前推进。

### 死锁产生的原因：四个必要条件

一个死锁的发生，必须同时满足以下四个条件。只要其中任意一个条件不成立，死锁就不会发生。这也被称为“Coffman条件”。

1.  互斥条件 (Mutual Exclusion)
    *   定义：一个资源在同一时刻只能被一个线程所持有。如果其他线程请求该资源，那么请求线程只能等待，直到资源被释放。
    *   比喻：就像一间只有一个座位的洗手间。当一个人进去后，他就锁上了门，其他任何想使用的人都必须在外面排队等待。

2.  占有并等待条件 (Hold and Wait)
    *   定义：一个线程至少已经持有一个资源，并且正在请求其他新的资源，但该新资源已被别的线程所占有。此时，该线程不会释放自己已持有的资源，而是一直等待新资源。
    *   比喻：一个人已经占有了洗手间的坑位（持有资源1），但他还需要卫生纸（请求资源2），而卫生纸在洗手间外面另一个人手里。他不会离开坑位去拿纸，而是坐在那里等着别人把纸送进来。

3.  不可剥夺条件 (No Preemption)
    *   定义：线程已获得的资源，在未使用完毕之前，不能被其他线程强行剥夺，只能由持有该资源的线程自己主动释放。
    *   比喻：占了坑位的人，在他自己办完事出来之前，你不能把他从坑位上强行拉走，来让给外面那个拿着卫生纸的人。

4.  循环等待条件 (Circular Wait)
    *   定义：存在一个线程资源的循环等待链。线程T1等待线程T2占有的资源，线程T2等待线程T3占有的资源，...，最后一个线程等待线程T1占有的资源，形成一个闭环。
    *   比喻：
        *   张三手里拿着一支笔，但他需要李四手里的纸来写字。
        *   李四手里拿着一张纸，但他需要张三手里的笔来写字。
        *   张三等李四的纸，李四等张三的笔，两人互相等待，形成了一个循环等待的僵局。这是最简单的死锁形式。

这四个条件是相辅相成的，共同导致了死锁的发生。

### 如何避免死锁

避免死锁的核心思想就是去破坏上述四个必要条件中的任意一个或多个。

1.  破坏“占有并等待”条件
    这是最常用和最有效的策略之一。
    *   方法一：一次性申请所有资源。
        *   一个线程在开始执行前，一次性地申请它在整个运行过程中所需要的所有资源。如果系统可以满足它的所有请求，就分配给它；否则，就不给它分配任何资源，让它等待。
        *   优点：实现简单，可以有效避免死锁。
        *   缺点：会降低资源的利用率，因为一个线程可能在很长一段时间里都不需要使用某些资源，但它却一直占有着。这还可能导致“饥饿”现象，即某个线程可能因为资源不足而永远无法开始执行。

2.  破坏“不可剥夺”条件
    *   方法：当一个线程占有部分资源，再去请求其他资源但被阻塞时，它可以主动释放自己已占有的资源。
    *   实现：Java的`java.util.concurrent.locks.Lock`接口中的`tryLock`方法提供了这种可能性。线程可以使用`tryLock`来尝试获取锁，可以设置一个超时时间。如果在指定时间内没有获取到锁，它就不会无限等待，而是会返回`false`。这时，它就可以在自己的代码逻辑里选择释放掉已经持有的其他锁，然后过一段时间再重新尝试。

3.  破坏“循环等待”条件
    这也是一种非常常用且高效的策略。
    *   方法：对所有资源进行线性排序，并规定所有线程都必须按照这个固定的顺序来申请资源。
    *   实现：比如系统里有两个资源：锁A和锁B。我们规定，任何线程如果需要同时持有A和B，必须先获取锁A，再获取锁B。
        *   线程1：先锁A，再锁B。
        *   线程2：也必须先锁A，再锁B。
        *   这样一来，如果线程1获取了A，线程2也想获取A，就会被阻塞，它根本没有机会去获取B。这就避免了线程1持有A等B，而线程2持有B等A的循环等待情况。
    *   这个“顺序”可以是基于资源的内存地址、哈希码、或者一个固定的ID。

### 死锁的检测

如果死锁已经不幸发生，如何去定位它？
*   使用JDK工具：
    *   `jstack`命令：这是定位Java应用死锁的最常用工具。在命令行中执行 `jstack <pid>`（pid是Java进程的ID），`jstack`会打印出所有线程的堆栈信息。如果存在死锁，它会在输出的末尾明确地指出“Found 1 deadlock”，并详细列出涉及死锁的线程、它们各自持有的锁以及正在等待的锁。
    *   `JConsole`或`VisualVM`：这些图形化工具也提供了线程监控功能，可以检测并显示死锁信息。

| 必要条件 | 避免策略 | 实用性 |
| :--- | :--- | :--- |
| 互斥条件 | 几乎无法破坏，因为很多资源本身就是独占的。 | 低 |
| 占有并等待 | 一次性申请所有资源。 | 中等，可能降低资源利用率。 |
| 不可剥夺 | 使用`tryLock`等带超时的机制，获取失败时释放已有资源。 | 高，编码较复杂。 |
| 循环等待 | 按固定顺序申请资源。 | 非常高，最常用的策略。 |
