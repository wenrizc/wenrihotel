
线程上下文切换（Thread Context Switching）是指CPU从一个正在运行的线程的执行，切换到另一个准备运行的线程的执行过程。这个过程涉及到保存当前线程的运行状态（即上下文），加载下一个线程的运行状态，以便CPU可以从新线程上次停止的地方继续执行。

上下文切换是操作系统实现多任务并发执行的核心机制之一。即使在单核CPU上，通过快速地在多个线程之间进行上下文切换，也能给用户一种多个程序同时运行的错觉。

线程上下文主要包括以下内容：

1.  CPU寄存器状态：
    *   通用寄存器 (General Purpose Registers)：如EAX, EBX, ECX, EDX (x86架构) 或 R0-R12 (ARM架构) 等，用于存储运算数据和地址。
    *   程序计数器 (Program Counter, PC / Instruction Pointer, IP)：指向当前线程下一条要执行的指令的地址。这是上下文切换后新线程能够从正确位置开始执行的关键。
    *   栈指针 (Stack Pointer, SP)：指向当前线程的调用栈的栈顶。每个线程都有自己的调用栈，用于存储函数调用的参数、局部变量、返回地址等。
    *   程序状态字 (Program Status Word, PSW) / 标志寄存器 (Flags Register)：包含CPU当前状态的信息，如条件码（零标志、进位标志、溢出标志等）、中断使能标志、特权级别等。

2.  线程栈 (Thread Stack)：
    虽然栈指针本身是寄存器的一部分，但线程栈的内容（局部变量、函数调用信息等）是线程上下文的重要组成部分。切换时，栈指针会指向新线程的栈。

3.  线程相关的内核数据结构：
    操作系统内核会为每个线程维护一些数据结构，记录线程的状态（如运行、就绪、阻塞）、优先级、线程ID、信号掩码、调度信息等。上下文切换时，内核可能需要更新这些信息。

4.  （某些情况下）其他特定于体系结构或操作系统的状态：
    例如，浮点寄存器、MMU（内存管理单元）的页表指针（如果线程属于不同进程，进程上下文切换时页表切换是核心，但同一进程内的线程切换通常共享同一地址空间，页表切换不是必须的，除非涉及到如ASID等优化）。

上下文切换的过程大致如下：

1.  中断或系统调用发生：
    上下文切换通常由以下几种情况触发：
    *   线程的时间片用完（被调度器抢占）。
    *   线程主动放弃CPU（例如，调用`sleep()`, `yield()`, 等待I/O操作完成，等待锁或信号量等）。
    *   更高优先级的线程变为就绪状态。
    *   硬件中断发生，中断处理程序执行完毕后可能需要调度新的线程。

2.  保存当前线程的上下文：
    操作系统内核介入，将当前正在CPU上运行的线程的上述寄存器值（PC, SP, 通用寄存器, PSW等）保存到该线程的内核数据结构中（通常是线程控制块 - Thread Control Block, TCB，或进程控制块 - Process Control Block, PCB 中的线程信息部分）。

3.  选择下一个要运行的线程：
    操作系统调度器根据其调度算法（如FIFO、轮转、优先级调度等）从就绪队列中选择一个合适的线程作为下一个要运行的线程。

4.  加载下一个线程的上下文：
    将选中的下一个线程之前保存的上下文信息从其TCB中加载到CPU的相应寄存器中。特别是PC寄存器会被设置为新线程上次被中断时的指令地址，SP寄存器指向新线程的栈。

5.  CPU执行新线程：
    CPU从新的PC值开始执行指令，新线程得以继续运行。

上下文切换的开销：
上下文切换并不是没有代价的，它会消耗CPU时间。开销主要来自：
*   直接开销：保存和加载寄存器状态、更新内核数据结构等操作本身需要CPU指令周期。
*   间接开销：
    *   CPU缓存失效：当切换到新的线程（尤其是属于不同进程的线程，或者即使是同一进程但数据访问模式差异大的线程），之前线程加载到CPU缓存（L1, L2, L3 cache）中的数据和指令可能对新线程无效，导致新线程在执行初期产生大量缓存未命中（cache miss），需要从较慢的内存中加载数据，降低了执行效率。
    *   TLB（Translation Lookaside Buffer）失效：TLB是MMU中用于缓存虚拟地址到物理地址映射的缓存。如果切换到不同进程的线程，通常需要刷新TLB或切换页表上下文，导致TLB miss增加。同一进程内的线程切换通常不涉及TLB刷新，因为它们共享地址空间。

频繁的上下文切换会导致系统将大量CPU时间花费在切换本身而不是实际的任务执行上，从而降低系统整体性能。因此，在并发编程和系统设计中，需要注意：
*   减少锁竞争，避免不必要的线程阻塞。
*   合理设置线程池大小，避免创建过多不必要的线程。
*   使用无锁数据结构或CAS操作等，在某些场景下可以减少或避免上下文切换。
*   对于CPU密集型任务，线程数不宜超过CPU核心数过多，以减少抢占式切换。

拓展延申：

1.  进程上下文切换 vs. 线程上下文切换：
    *   进程上下文切换：涉及到不同进程间的切换。除了保存和恢复CPU寄存器、栈指针等，还需要切换虚拟内存空间（即页表），刷新TLB。开销通常比线程上下文切换大得多。
    *   线程上下文切换：
        *   同一进程内的线程切换：由于共享同一地址空间，通常不需要切换页表，TLB的冲击也较小（但数据缓存仍可能失效）。开销相对较小。
        *   不同进程的线程切换（如果操作系统调度的是内核级线程）：这实际上等同于进程上下文切换。

2.  用户级线程 vs. 内核级线程的上下文切换：
    *   内核级线程 (Kernel-Level Threads, KLT)：线程的创建、调度和管理都由操作系统内核完成。KLT的上下文切换由内核触发和执行，如上所述。
    *   用户级线程 (User-Level Threads, ULT)：线程的管理（创建、调度、同步）完全在用户空间由线程库完成，内核对它们无感知。ULT的上下文切换不需要内核介入，速度非常快，因为它只涉及用户空间的数据结构和寄存器的保存/恢复（通常由线程库自己管理）。但是，如果一个ULT因为系统调用（如I/O）而阻塞，整个进程（包括该进程内的所有其他ULT）都会被阻塞。为了克服这个问题，出现了混合模型（如N:M模型，N个ULT映射到M个KLT）。现代操作系统如Linux、Windows主要使用内核级线程模型（或1:1模型，每个用户线程对应一个内核线程）。

3.  上下文切换的监控：
    在Linux系统中，可以使用`vmstat`命令（查看`cs`列，表示context switches per second）、`pidstat -w`命令（查看`cswch/s`和`nvcswch/s`，分别表示自愿和非自愿上下文切换）等工具来监控系统的上下文切换频率，这对于性能分析和调优很有帮助。过高的上下文切换次数往往意味着系统存在性能瓶颈。

