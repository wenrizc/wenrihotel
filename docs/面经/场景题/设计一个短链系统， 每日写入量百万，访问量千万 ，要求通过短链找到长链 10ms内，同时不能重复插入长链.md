
核心需求：
1.  功能：长链接转换为短链接；通过短链接访问时能重定向到原始长链接。
2.  性能：通过短链接找到长链（读操作）在10ms内。
3.  写入量：每日百万级别（约12次/秒）。
4.  访问量：每日千万级别（约120次/秒），读多写少。
5.  唯一性：同一个长链接不应重复生成新的短链接，应返回已有的。

设计思路：

1.  短链接生成策略：
    *   哈希算法：对长链接进行哈希（如 MD5, SHA1），然后取一部分作为短码。
        *   冲突：哈希冲突是可能发生的。需要设计冲突解决机制，例如在冲突时附加一个小的序列号或尝试不同的哈希种子。
        *   长度：通常选择6-8位字符，使用大小写字母和数字（62进制）可以表示大量的链接。例如，6位62进制可以表示 62^6 约等于 568亿个。7位则更多。
    *   自增ID转进制：
        *   使用一个全局唯一的自增ID（例如来自数据库的自增主键，或如 Snowflake 这样的分布式ID生成器）。
        *   将这个ID转换为62进制（0-9, a-z, A-Z）的字符串作为短码。
        *   优点：天然唯一，短码长度随ID增长而增长，但早期较短。
        *   缺点：ID的顺序性可能暴露一些信息。分布式ID生成器是必要的，以避免单点瓶颈。

    考虑到写入量是百万级别，几年下来ID会增长，6位可能不够，7-8位比较合适。自增ID转进制是目前业界比较主流的做法，因为它能保证生成的短码唯一。

2.  存储设计：
    我们需要至少两张表：
    *   `short_to_long`：存储短码到长链接的映射。
        *   `short_code` (主键/索引，用于快速查找)
        *   `long_url`
        *   `created_at`
        *   `visit_count` (可选，用于统计)
        *   ... 其他元数据
    *   `long_to_short`：存储长链接（或其哈希）到短码的映射，用于实现“不重复插入长链”的需求。
        *   `long_url_hash` (主键/索引，对长链接计算哈希值，如MD5，用于快速查找。注意，这里哈希是为了快速查找和索引，不是短码本身) 或者直接用 `long_url` 做索引（如果数据库支持长索引且性能可接受）。
        *   `short_code`

    数据库选型：
    *   读操作（短码 -> 长链接）要求10ms内：这通常指向内存数据库或高性能的KV存储。Redis 是一个非常好的选择，可以将 `short_code` 作为 key，`long_url` 作为 value。
    *   写操作和长链接去重：关系型数据库（如 MySQL, PostgreSQL）可以利用事务和唯一索引来保证数据一致性和长链接的唯一性。NoSQL 数据库（如 Cassandra, DynamoDB）也可以，但去重逻辑可能需要在应用层或通过其特性保证。

    一个常见的组合是：
    *   使用 Redis 作为主读缓存：`short_code -> long_url` 的映射存在 Redis 中，满足10ms的读取延迟。
    *   使用关系型数据库（如 MySQL）作为持久化存储和去重：存储完整的映射关系，并利用 `long_url` (或其哈希) 的唯一索引来防止重复。

3.  系统流程：

    a.  生成短链接（写流程）：
        1.  用户提交长链接。
        2.  计算长链接的哈希值（例如 MD5）。
        3.  查询 `long_to_short` 表（或其在 MySQL 中的对应表）看该 `long_url_hash` 是否已存在。
            *   如果存在，直接返回对应的 `short_code`。
            *   如果不存在：
                i.  生成一个新的全局唯一ID。
                ii. 将此ID转换为62进制的 `short_code`。
                iii.（重要）需要检查这个新生成的 `short_code` 是否已经偶然存在（虽然概率极低，但如果ID生成器不是严格递增映射到短码池，或者短码生成有其他随机性，就需要检查）。如果冲突，则重新生成或采用冲突解决策略。对于自增ID转进制，如果ID唯一，则短码也唯一，此步可简化。
                iv. 将 `(short_code, long_url)` 和 `(long_url_hash, short_code)` 存入持久化数据库（例如 MySQL）。
                v.  将 `(short_code, long_url)` 写入 Redis 缓存。
                vi. 返回 `short_code` 给用户。
        这个过程最好在一个事务中完成，保证数据一致性。

    b.  访问短链接（读流程）：
        4.  用户访问 `http://yourdomain.com/{short_code}`。
        5.  应用服务从请求路径中提取 `short_code`。
        6.  首先查询 Redis 缓存，尝试获取 `short_code` 对应的 `long_url`。
            *   如果命中缓存，直接获取 `long_url` 并返回301或302重定向。此过程非常快，满足10ms要求。
            *   如果未命中缓存（可能是新生成的链接，或者缓存失效）：
                i.  查询持久化数据库（如 MySQL）的 `short_to_long` 表。
                ii. 如果找到，获取 `long_url`，将其写回 Redis 缓存（设置合适的过期时间），然后返回重定向。
                iii.如果数据库中也找不到，则返回404错误。
        7.  （可选）异步更新访问计数。

4.  可扩展性和高可用性：
    *   应用服务层：可以水平扩展，无状态设计。
    *   Redis：可以使用 Redis Sentinel 或 Cluster 模式保证高可用和扩展性。
    *   MySQL：主从复制（读写分离），分库分表（如果数据量增长到非常大）。对于每日百万写入，初期单实例高性能MySQL配合良好索引可能可以支撑，但需要监控并规划扩展。
    *   ID生成器：需要一个高可用的分布式ID生成服务（如 Snowflake 算法的实现）。

5.  预估与优化：
    *   短码长度：每日百万，一年约3.6亿，十年36亿。62进制的7位长度（62^7 ≈ 3.5万亿）足够长时间使用。
    *   缓存策略：可以为热点链接设置更长的缓存时间，或者不设置过期时间，通过 LRU 策略淘汰。
    *   CDN：对于非常热门的短链接，可以在边缘节点缓存重定向响应，进一步降低延迟和源站压力。
    *   自定义短链：允许用户自定义短链字符串，这需要额外的检查和存储逻辑。
