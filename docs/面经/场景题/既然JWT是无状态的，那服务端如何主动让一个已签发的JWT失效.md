
### 方案一：将失效的JWT加入黑名单（Blocklist/Denylist）

这是最直观的一种方法。服务端在内存（如Redis、Memcached）或数据库中维护一个列表，专门存放那些已被主动声明失效的JWT。

- **工作流程**：
    
    1. 用户执行一个导致JWT应失效的操作（如修改密码、登出）。
        
    2. 服务端获取当前请求中的JWT。
        
    3. 服务端将该JWT的唯一标识（通常是`jti`声明）或者整个JWT本身，连同其过期时间`exp`一起，存入一个黑名单中。
        
    4. 对于后续的每一个请求，除了验证JWT的签名和过期时间外，服务端还需要额外检查该JWT是否存在于黑名单中。
        
    5. 如果存在，则拒绝该请求，视为未授权。
        
    6. 黑名单中的JWT条目可以等到其自然过期（`exp`时间点）后，通过定时任务自动清理，以防止黑名单无限增长。
        
- **优点**：
    
    - 逻辑简单直接，容易理解和实现。
        
    - 可以实现实时、精准的令牌失效控制。
        
- **缺点**：
    
    - 违背了JWT的“无状态”初衷。服务端为了验证令牌，又需要去查询一个外部存储（Redis等），增加了系统的复杂性和依赖。
        
    - 每次请求都需要额外查询黑名单，在高并发场景下可能会成为性能瓶颈。
        
    - 需要额外维护一个存储系统来存放黑名单。
        

### 方案二：缩短JWT的有效期 + 使用刷新令牌（Refresh Token）

这是目前业界最主流、也是被广泛推荐的最佳实践方案。它通过两种不同生命周期的令牌来平衡安全性和用户体验。

- **核心思想**：
    
    - **访问令牌（Access Token）**：即我们通常说的JWT，用于访问受保护的资源。它的生命周期设置得非常短，比如15分钟、30分钟或1小时。
        
    - **刷新令牌（Refresh Token）**：这是一个长生命周期的令牌（比如7天、30天），它不包含用户信息，只用于获取新的Access Token。Refresh Token本身是存储在服务端数据库中的，并且与用户关联。
        
- **工作流程**：
    
    1. 用户首次登录时，服务端同时签发一个短生命周期的Access Token和一个长生命周期的Refresh Token。
        
    2. 客户端在后续请求中携带Access Token访问API。服务端只需验证签名和`exp`，无需查询数据库，保持了无状态的优点。
        
    3. 当Access Token过期后，客户端使用Refresh Token去请求一个新的Access Token。
        
    4. 服务端接收到刷新请求时，会去数据库中验证这个Refresh Token是否有效（是否被撤销）。如果有效，就签发一个新的Access Token给客户端。
        
    5. 当用户修改密码或主动登出时，服务端只需要在数据库中将与该用户关联的所有Refresh Token标记为无效或直接删除。
        
    6. 这样一来，即使用户手中还有一个未过期的Access Token，但因为它生命周期很短，最多在几分钟或一小时内就会自然失效。之后当客户端尝试用旧的Refresh Token获取新Access Token时，服务端会因为Refresh Token已失效而拒绝请求，从而强制用户重新登录。
        
- **优点**：
    
    - 在Access Token的有效期内，服务端的验证过程是无状态的，性能高。
        
    - 通过撤销Refresh Token，可以有效地管理用户会话，实现了服务端的控制能力。
        
    - 安全性高。即使Access Token被截获，其有效期也很短，风险可控。
        
    - 在安全性和系统性能之间取得了很好的平衡。
        
- **缺点**：
    
    - 实现逻辑相对复杂，需要客户端和服务器端共同配合管理两种令牌。
        
    - 无法让一个未过期的Access Token _立即_ 失效，只能等待它自然过期。但这通常在可接受的风险范围内。
        

### 方案三：为每个用户维护一个全局的版本号或密钥盐

这种方法通过在JWT的载荷（Payload）中加入一个版本标识来实现。

- **工作流程**：
    
    1. 在用户数据表（或缓存）中为每个用户增加一个字段，例如 `token_version` 或 `token_secret_salt`。
        
    2. 在签发JWT时，将这个版本号或盐值包含在JWT的载荷（Payload）中。例如：`{"user_id": 123, "version": 1, ...}`。
        
    3. 服务端在验证JWT时，除了常规检查，还需要从数据库或缓存中读取该用户的当前`token_version`，并与JWT载荷中的`version`进行比对。
        
    4. 如果两者不一致，则说明这是一个旧版本的JWT，应予以拒绝。
        
    5. 当用户修改密码或需要让所有设备下线时，服务端只需将该用户的`token_version`加一即可。所有在此之前签发的JWT都会因为版本号不匹配而失效。
        
- **优点**：
    
    - 可以立即让某个用户的所有JWT失效。
        
    - 不需要维护一个可能不断增长的黑名单。
        
- **缺点**：
    
    - 同样违背了“无状态”原则，每次请求都需要查询数据库或缓存来获取当前的版本号。
        
    - 和黑名单方案一样，在高并发下可能会有性能问题。
        

### 总结与对比

|方案|核心思想|优点|缺点|适用场景|
|---|---|---|---|---|
|**黑名单机制**|维护一个失效JWT的列表|实现精准、实时的单点令牌吊销|破坏无状态特性，增加查询开销和系统复杂性|对安全性要求极高，需要立即撤销单个令牌的场景|
|**短有效期 + 刷新令牌**|用长效Refresh Token控制会话，短效Access Token访问资源|平衡了性能与安全，主流实践，服务端大部分时间无状态|实现相对复杂，令牌无法立即失效（但延迟很短）|绝大多数Web和移动应用的最佳选择|
|**版本号/密钥盐机制**|在JWT中嵌入版本号，通过递增版本号使旧令牌失效|可立即让用户所有令牌失效，存储开销小|破坏无状态特性，每次请求都需要额外查询|需要一次性让某个用户所有登录会话都失效的场景|

综上所述，**“缩短JWT有效期 + 使用刷新令牌”是目前最被推崇和广泛应用的方案**。它在很大程度上保留了JWT无状态带来的性能优势，同时通过管理Refresh Token，赋予了服务端撤销用户会话的能力，达到了安全性和易用性的最佳平衡。黑名单和版本号机制则作为特定场景下的补充方案，适用于对实时失效有更严苛要求的系统。