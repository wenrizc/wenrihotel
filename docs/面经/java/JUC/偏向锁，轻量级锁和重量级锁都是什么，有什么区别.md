
### 偏向锁 (Biased Locking)

#### 是什么

偏向锁是锁优化中级别最低的一种。它的核心思想是，在大多数情况下，一个锁不仅不存在多线程竞争，而且总是由同一个线程多次获得。因此，它可以“偏向”于第一个获取它的线程，后续这个线程再次进入同步块时，开销可以降到最低。

#### 适用场景

几乎没有竞争，锁总是被同一个线程反复获取的场景。

#### 区别与特点

- 实现机制：当第一个线程获取锁时，JVM会将对象头（Mark Word）中的锁标志位设为偏向模式，并记录下持有该锁的线程ID。之后，该线程每次进出同步块时，只需要检查一下Mark Word里的线程ID是否是自己，如果是，则无需任何同步操作（如CAS），直接获取锁。这是它与轻量级锁和重量级锁最核心的区别，开销极低。
    
- 目的：消除在无竞争情况下的同步原语开销，让加锁操作几乎等同于无锁。
    

### 轻量级锁 (Lightweight Locking)

#### 是什么

当偏向锁被另一个线程尝试获取时，它就会升级为轻量级锁。轻量级锁认为，虽然存在竞争，但这种竞争通常是交替发生的，即多个线程不会在同一时刻去争抢锁，并且每个线程持有锁的时间很短。

#### 适用场景

存在多线程竞争，但竞争程度较低，线程持有锁时间短的场景。

#### 区别与特点

- 实现机制：线程在尝试获取轻量级锁时，并不会立即向操作系统请求互斥量，而是采用CAS（Compare-And-Swap）操作来尝试获取锁。如果CAS成功，则获取锁。如果失败，说明锁已被其他线程持有，此时线程不会立即被阻塞挂起，而是会进行“自旋”。自旋就是执行一个忙等待的循环，期望在短时间内锁就会被释放。
    
- 目的：通过自旋代替线程阻塞，避免线程在用户态和内核态之间切换所带来的巨大开销。它相对于偏向锁，引入了CAS操作和自旋，开销更大；但相对于重量级锁，它避免了线程的实际挂起和唤醒。
    

### 重量级锁 (Heavyweight Locking)

#### 是什么

当轻量级锁的自旋无法获取到锁，或者竞争进一步加剧时，锁就会膨胀为重量级锁。这是`synchronized`最原始、也是最万能的一种锁形态。

#### 适用场景

存在激烈且持续的锁竞争，线程持有锁时间较长的场景。

#### 区别与特点

- 实现机制：重量级锁是基于对象的监视器（Monitor）实现的，而Monitor又依赖于操作系统底层的互斥量（Mutex Lock）来实现。当线程获取重量级锁失败时，它将不再自旋消耗CPU，而是会被操作系统挂起，进入阻塞状态，并被放入一个等待队列中。当持有锁的线程释放锁后，会唤醒等待队列中的线程，由操作系统来调度它们重新竞争。
    
- 目的：在高竞争环境下，通过让出CPU，避免无效的自旋等待，保证系统的整体性能和公平性。它的开销是三者中最大的，因为涉及到操作系统的介入和线程上下文切换。
    

### 总结与区别

这三种锁状态的核心区别可以归纳为以下几点：

- **解决的竞争级别不同**
    
    - 偏向锁：解决无竞争问题。
        
    - 轻量级锁：解决低度、交替性竞争问题。
        
    - 重量级锁：解决高度、持续性竞争问题。
        
- **实现机制不同**
    
    - 偏向锁：通过在对象头记录线程ID来实现。
        
    - 轻量级锁：通过CAS操作和自旋等待来实现。
        
    - 重量级锁：通过依赖操作系统的互斥量，让线程阻塞和唤醒来实现。
        
- **性能开销不同**
    
    - 从低到高依次是：偏向锁 < 轻量级锁 < 重量级锁。
        
- **状态转换**
    
    - 这是一个单向的升级过程：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁。一旦升级为重量级锁，通常就不会再降级回来了。
        

总的来说，JVM通过这套自适应的锁升级策略，使得`synchronized`在面对不同的并发场景时，能够自动选择开销最小的同步方案，从而在保证线程安全的前提下，最大限度地提升了程序的运行效率。