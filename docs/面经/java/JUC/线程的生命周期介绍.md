
1.  **新建状态 (New)**
    当使用 `new` 关键字创建一个线程对象后，但还未调用其 `start()` 方法时，该线程就处于新建状态。 此时，它仅仅是一个Java对象，操作系统还没有为其分配任何资源，因此它还不是一个活动的线程。

2.  **可运行状态 (Runnable)**
    一旦线程对象的 `start()` 方法被调用，线程就进入了可运行状态。 处于这个状态的线程已经具备了运行的条件，位于线程队列中，等待操作系统的线程调度器分配CPU时间片。 "可运行"状态实际上包含了就绪和运行两种子状态。就绪状态表示线程有资格运行，但CPU正在执行其他线程；运行状态表示线程已经获得了CPU时间，正在执行其 `run()` 方法中的代码。

3.  **阻塞状态 (Blocked)**
    当一个线程试图获取一个对象的监视器锁（例如，进入一个 `synchronized` 修饰的同步代码块或方法），而该锁此时被其他线程所持有时，该线程就会进入阻塞状态。 处于阻塞状态的线程会暂时停止活动，并且不会占用CPU资源，直到它成功获取到锁，才会转换回可运行状态。

4.  **等待状态 (Waiting)**
    处于等待状态的线程需要等待其他线程执行特定的操作来唤醒它。 线程进入此状态通常是由于调用了以下方法之一：
    *   `Object.wait()` (无超时设置)
    *   `Thread.join()` (无超时设置)
    *   `LockSupport.park()`
    进入等待状态的线程会释放CPU资源，并且只有在被其他线程显式地唤醒（例如通过调用 `notify()` 或 `notifyAll()`）后，才能重新回到可运行状态。

5.  **计时等待状态 (Timed Waiting)**
    这个状态与等待状态类似，不同之处在于它有一个指定的等待时间。 线程在等待一段时间后会自动唤醒，返回到可运行状态。 以下方法会使线程进入计时等待状态：
    *   `Thread.sleep(long millis)`
    *   `Object.wait(long timeout)`
    *   `Thread.join(long millis)`
    *   `LockSupport.parkNanos(long nanos)`
    *   `LockSupport.parkUntil(long deadline)`

6.  **终止状态 (Terminated)**
    线程的生命周期最终会走向终止。 当线程的 `run()` 方法执行完毕，或者因未捕获的异常而退出时，线程就进入了终止状态。 一旦进入终止状态，线程就结束了其生命周期，不能再被重新启动或转换到任何其他状态。 值得注意的是，直接调用线程的 `stop()` 方法也可以强制终止线程，但这种方法由于可能导致资源无法正常释放等问题，通常不被推荐使用。
