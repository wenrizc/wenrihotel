
### 1. 无锁状态 (No Lock)

一个对象在刚刚被创建出来，还没有任何线程试图获取它的锁时，它就处于无锁状态。此时，它的对象头Mark Word中存储的是对象的哈希码、GC分代年龄等信息，锁标志位是01。

### 2. 升级为偏向锁 (Biased Lock)

- 触发条件：当第一个线程（我们称之为线程A）来尝试获取这个对象的锁时，锁会从无锁状态升级为偏向锁。
    
- 升级过程：
    
    1. JVM会通过CAS（Compare-And-Swap）操作，尝试将这个线程A的ID记录到对象头的Mark Word中。
        
    2. 同时，将锁标志位从01（无锁）改为01（虽然标志位没变，但内部结构变了），并设置偏向锁标志位为1。
        
        . 如果CAS操作成功，线程A就获得了这个偏向锁。
        
- 偏向锁下的操作：
    
    此后，只要这个锁没有被其他线程竞争，线程A每次进入和退出同一个同步代码块时，都不需要再进行任何同步操作（如CAS或加锁）。它只需要简单地检查一下Mark Word中记录的线程ID是否是自己。如果是，就直接进入同步块。这极大地降低了在无竞争情况下的锁开销。
    

### 3. 升级为轻量级锁 (Lightweight Lock)

- 触发条件：偏向锁状态下，当有另一个线程（线程B）也来尝试获取这个锁时，偏向锁就会被撤销，并升级为轻量级锁。
    
- 升级过程：
    
    1. JVM首先会暂停持有偏向锁的线程A。
        
    2. 检查线程A是否还存活。如果线程A已经结束，那么锁对象恢复到无锁状态，然后线程B可以重新尝试获取偏向锁。
        
    3. 如果线程A还存活，JVM会撤销偏向锁。对象头的Mark Word不再存储线程ID，而是会指向线程A栈帧中的一个锁记录（Lock Record）。这个过程完成后，锁对象就进入了轻量级锁状态。
        
    4. 线程A被唤醒，继续执行。
        
    5. 此时，线程B开始通过自旋（Spinning）的方式尝试获取这个轻量级锁。它会通过CAS操作，尝试将对象头的Mark Word指向自己栈帧中的锁记录。
        
- 轻量级锁下的操作：
    
    当锁处于轻量级锁状态时，所有尝试获取锁的线程都会通过自旋的方式来竞争。自旋就是执行一个空循环，不让出CPU，期望在短时间内锁的持有者会释放锁。这种方式避免了线程在用户态和内核态之间切换所带来的开销，适用于锁竞争不激烈、且线程持有锁时间很短的场景。
    

### 4. 升级为重量级锁 (Heavyweight Lock)

- 触发条件：当锁的竞争变得激烈，自旋等待的线程长时间无法获取到锁时，轻量级锁就会升级为重量级锁。
    
- 升级过程：
    
    1. 当一个线程自旋了一定次数后（这个次数是JVM动态调整的，比如自适应自旋），仍然没有成功获取到锁。
        
    2. 或者，当一个线程正在自旋，同时又有新的线程加入竞争。
        
    3. JVM就会认为当前的锁竞争程度已经不适合再通过自旋来等待了。
        
    4. 锁会膨胀（inflate）为重量级锁。此时，对象头的Mark Word会被修改，指向一个真正的、与操作系统互斥量（Mutex）关联的Monitor对象。
        
    5. 所有后续等待锁的线程，以及当前正在自旋的线程，都将不再自旋，而是会被阻塞，并放入Monitor内部的等待队列中。
        
- 重量级锁下的操作：
    
    线程获取重量级锁失败后，会被挂起并进入阻塞状态，完全让出CPU。当持有锁的线程释放锁时，会唤醒等待队列中的一个或多个线程，由操作系统来调度它们重新竞争锁。这种方式虽然上下文切换开销大，但在高竞争环境下，它避免了CPU资源的空转，能保证系统的稳定和公平性。
    

### 总结

JVM的锁升级流程是一个非常精巧的自适应优化机制：

- 无锁到偏向锁：优化无竞争场景。
    
- 偏向锁到轻量级锁：优化线程交替执行的低竞争场景。
    
- 轻量级锁到重量级锁：适应高竞争场景，保证系统稳定。
    

这个单向的升级过程，使得synchronized关键字能够在不同的并发压力下，自动选择最合适的锁策略，从而在保证线程安全的同时，尽可能地提高程序的执行性能。