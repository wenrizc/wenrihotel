
### 1. 什么是Java线程

首先，一个程序在运行时至少会有一个进程（Process），进程是操作系统分配资源的基本单位。而线程（Thread）则是进程内部的一个执行单元，是CPU调度和分派的基本单位。

可以这样理解：一个进程好比一个工厂，拥有独立的资源（如厂房、电力、原材料）。而线程就像工厂里的工人或者生产线，多个线程可以共享同一个进程的资源（如内存空间、文件句柄），但每个线程又有自己独立的工作空间，比如程序计数器、虚拟机栈等。

在Java中使用多线程，主要目的是为了实现并发（Concurrency）和并行（Parallelism）。

- 并发：让程序看起来像是在同时处理多个任务，提高应用的响应速度和资源利用率。
    
- 并行：在多核CPU上，让多个任务真正地在同一时刻被不同的CPU核心执行，提升计算效率。
    

### 2. 创建线程的方式与区别

在Java中，创建线程通常有以下几种方式，它们在实现和应用上各有侧重。

#### 方式一：继承 Thread 类

这是最直接的一种方式。

- 实现：自定义一个类，让它继承自 `java.lang.Thread` 类，并重写父类的 `run()` 方法。`run()` 方法中定义的就是这个线程需要执行的任务逻辑。
    
- 使用：创建这个自定义类的实例，然后调用它的 `start()` 方法来启动线程。
    
- 区别与缺点：Java是单继承的，如果一个类已经继承了其他类，就无法再继承 `Thread` 类，这限制了它的使用。同时，这种方式将任务逻辑（`run`方法）和线程的创建与控制（`Thread`类）耦合在了一起，不符合面向对象中“单一职责”的设计原则。
    

#### 方式二：实现 Runnable 接口

这是更常用和推荐的一种方式。

- 实现：自定义一个类，让它实现 `java.lang.Runnable` 接口，并实现接口中的 `run()` 方法。
    
- 使用：创建这个实现了`Runnable`接口的类的实例，然后将其作为参数传递给 `Thread` 类的构造函数来创建一个`Thread`对象，最后调用这个`Thread`对象的 `start()` 方法。
    
- 区别与优点：这种方式实现了任务与线程的解耦。`Runnable`对象只负责定义任务，而`Thread`对象负责执行任务。这种分离使得代码结构更清晰，并且类可以自由地继承其他类，灵活性更高。
    

#### 方式三：实现 Callable 接口

这是对`Runnable`接口的增强，是Java 5引入的。

- 实现：自定义一个类，实现 `java.util.concurrent.Callable<V>` 接口，并实现其 `call()` 方法。
    
- 区别与优点：
    
    1. 可以有返回值：`call()` 方法可以返回一个结果，而 `Runnable` 的 `run()` 方法是`void`，没有返回值。
        
    2. 可以抛出异常：`call()` 方法可以声明抛出受检异常（Checked Exception），而`run()`方法不能。
        
- 使用：`Callable`通常不直接与`Thread`类配合使用，而是与线程池（ExecutorService）结合。通过 `executorService.submit(callableTask)` 提交任务，会返回一个 `Future<V>` 对象，通过这个`Future`对象可以异步地获取任务的执行结果。
    

#### 方式四：使用线程池

这是现代Java并发编程中最佳和最推荐的方式。

- 实现：通过 `java.util.concurrent.Executors` 工厂类或者直接创建 `ThreadPoolExecutor` 的实例来获得一个线程池。
    
- 使用：将实现了`Runnable`或`Callable`接口的任务，通过线程池的 `execute()` 或 `submit()` 方法提交即可。
    
- 区别与优点：
    
    1. 资源管理：线程池统一管理线程的生命周期，复用已创建的线程，避免了频繁创建和销毁线程带来的性能开销。
        
    2. 控制并发数：可以有效控制系统中并发线程的最大数量，防止因线程过多而耗尽系统资源。
        
    3. 功能更强：提供了更丰富的管理功能，如定时执行、任务队列、拒绝策略等。
        

总结来说，前两种是基础的创建方式，后两种是更高级、更强大的实践方式。实际开发中，我们应该优先考虑使用线程池来管理线程。

### 3. 线程的生命周期与状态

一个Java线程从创建到消亡，会经历不同的状态。在Java的`java.lang.Thread.State`枚举中，明确定义了线程的六种状态。

1. **NEW (新建)**
    
    - 描述：线程对象被创建后，但在调用 `start()` 方法之前，线程就处于这个状态。此时，它只是一个普通的Java对象，操作系统还未为其分配任何线程资源。
        
2. **RUNNABLE (可运行)**
    
    - 描述：当线程对象调用了 `start()` 方法后，线程就进入了这个状态。处于`RUNNABLE`状态的线程，可能正在CPU上执行，也可能正在等待操作系统的线程调度器分配CPU时间片。在操作系统的层面，这个状态包含了“就绪”（Ready）和“运行中”（Running）两种状态。
        
3. **BLOCKED (阻塞)**
    
    - 描述：线程正在等待获取一个监视器锁（monitor lock）。通常发生在线程试图进入一个`synchronized`修饰的同步代码块或方法，但该锁被其他线程持有时。当持有锁的线程释放锁后，这个线程会从`BLOCKED`状态转回`RUNNABLE`状态，参与锁的竞争。
        
4. **WAITING (无限期等待)**
    
    - 描述：线程进入无限期等待状态，需要等待另一个线程显式地唤醒。
        
    - 触发条件：调用了没有设置超时参数的 `Object.wait()`、`Thread.join()` 或 `LockSupport.park()` 等方法。
        
    - 唤醒条件：另一个线程调用了 `Object.notify()` 或 `Object.notifyAll()`，或者 `LockSupport.unpark()` 等。
        
5. **TIMED_WAITING (限期等待)**
    
    - 描述：与`WAITING`类似，但它不会无限等待。它会在指定的时间后，由系统自动唤醒，返回`RUNNABLE`状态。
        
    - 触发条件：调用了带有超时参数的方法，如 `Thread.sleep(long millis)`、`Object.wait(long timeout)`、`Thread.join(long millis)` 等。
        
6. **TERMINATED (终止)**
    
    - 描述：线程的 `run()` 方法执行完毕（无论是正常结束还是因异常退出），线程的生命周期结束，进入终止状态。这个状态的线程无法再被启动。
        

这些状态之间的转换，构成了Java线程完整的生命周期图。理解这些状态和转换条件，对于分析和解决多线程中的并发问题至关重要。