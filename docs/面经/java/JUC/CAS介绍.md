
CAS的全称是“比较并交换”（Compare-And-Swap）。它不是一种编程语言的特性，而是一种源自硬件层面的原子操作指令。这个操作保证了“读取-比较-修改”这三个步骤是作为一个不可分割的整体来执行的，中间不会被任何其他线程打断。

CAS操作包含三个核心操作数：
1.  **V**：要被更新的内存变量的地址。
2.  **A**：预期的旧值（Expected Value）。
3.  **B**：要更新成的新值（New Value）。

其核心思想是：**只有当内存地址V处的当前值与预期的旧值A相等时，才会将V处的值更新为新值B。无论更新成功与否，它都会返回V在操作执行前的那个时刻的真实值。**

这种机制本质上是一种“乐观锁”。它乐观地假设在它准备修改数据时，没有其他线程会来捣乱。它先在自己的工作空间里计算好新值，然后在提交更新时去“确认”一下，如果内存中的值还是它当初读取的那个旧值，就说明没人动过，可以安全更新；如果值变了，就说明有其他线程抢先修改了，那么本次更新失败，然后通常会选择重试。

---

### CAS的执行流程（结合一个经典例子）

CAS本身只是一次原子操作，但在实际应用中，它几乎总是被包裹在一个循环（通常是自旋循环）里使用，以应对更新失败后需要重试的场景。

我们以一个经典的并发场景为例：多个线程同时对一个共享整数进行加1操作（`i++`）。

**场景**: 共享变量 `int count = 0;`。两个线程（线程A和线程B）都想执行 `count++`。

如果不加锁，`count++`在底层至少分为三步：
1.  读取 `count` 的值到寄存器。
2.  在寄存器中将值加1。
3.  将新值写回 `count`。
这显然不是原子的，会导致更新丢失问题。

**使用CAS的执行流程如下：**

#### 初始状态
*   内存中 `count` 的值为 `0`。

#### 线程A的执行流程
1.  **第一步：读取旧值**
    *   线程A进入循环，首先从内存中读取 `count` 的当前值。
    *   它读到的值是 `0`。这个 `0` 现在就是线程A的“预期旧值A”。

2.  **第二步：计算新值**
    *   线程A在自己的工作内存中计算新值。
    *   新值B = 预期旧值A + 1 = 0 + 1 = `1`。

3.  **第三步：执行CAS原子操作**
    *   线程A发起CAS操作，请求将 `count` 的值从预期旧值 `0` 更新为新值 `1`。
    *   CPU执行 `CAS(count的地址, 预期旧值=0, 新值=1)`。
    *   CPU检查到内存中 `count` 的当前值确实是 `0`，与预期旧值相等。
    *   **条件满足**，CPU原子地将 `count` 的值更新为 `1`。
    *   CAS操作成功，并返回操作前的值 `0`。

4.  **第四步：判断并退出**
    *   线程A的CAS方法发现返回的值（`0`）与自己的预期旧值（`0`）相同，这通常表示更新成功。
    *   线程A退出循环，完成自己的`count++`操作。

#### 此时内存状态
*   内存中 `count` 的值为 `1`。

#### 线程B的执行流程 (假设它在线程A之后执行)
1.  **第一步：读取旧值**
    *   线程B进入循环，从内存中读取 `count` 的当前值。
    *   此时 `count` 已经被线程A更新为 `1`，所以线程B读到的值是 `1`。
    *   这个 `1` 就是线程B的“预期旧值A”。

2.  **第二步：计算新值**
    *   线程B计算新值。
    *   新值B = 预期旧值A + 1 = 1 + 1 = `2`。

3.  **第三步：执行CAS原子操作**
    *   线程B发起CAS操作，请求将 `count` 的值从预期旧值 `1` 更新为新值 `2`。
    *   CPU执行 `CAS(count的地址, 预期旧值=1, 新值=2)`。
    *   CPU检查到内存中 `count` 的当前值确实是 `1`，与预期旧值相等。
    *   **条件满足**，CPU原子地将 `count` 的值更新为 `2`。
    *   CAS操作成功。

4.  **第四步：判断并退出**
    *   线程B的CAS方法判断操作成功，退出循环。

#### 假设发生冲突的执行流程
1.  线程A和线程B **同时** 读取 `count`，都读到 `0`。
2.  它们各自计算出的新值都是 `1`。
3.  线程A **先** 执行CAS操作 `CAS(count地址, 0, 1)`。CPU检查 `count` 值是 `0`，更新成功，`count` 变为 `1`。
4.  紧接着，线程B 执行CAS操作 `CAS(count地址, 0, 1)`。CPU检查 `count` 的值，发现它现在是 `1`，与线程B的预期旧值 `0` **不相等**。
5.  **条件不满足**，CAS操作失败。CPU不会修改 `count` 的值。`count` 仍然是 `1`。
6.  线程B的CAS方法判断操作失败了。
7.  **进入下一次循环（重试）**:
    *   线程B重新从内存读取 `count` 的值，这次读到的是 `1`。
    *   计算新值为 `2`。
    *   再次尝试CAS操作 `CAS(count地址, 1, 2)`。
    *   这一次，内存值和预期值相等，操作成功。`count` 变为 `2`。
    *   线程B退出循环。

最终结果 `count` 是 `2`，数据保持了一致性。

### Java中的应用

*   **优点**：
    *   **无锁化**：相比于`synchronized`等悲观锁，CAS不会使线程进入阻塞状态，没有线程切换和调度的开销，因此在低到中等并发冲突下，性能非常高。
    *   **避免死锁**：由于没有锁，也就不存在死锁问题。

*   **缺点**：
    *   **ABA问题**：如果一个值从A变为B，又变回了A，CAS会认为它没有变过，但实际上中间发生了变化。解决方案是使用带版本号的CAS，如Java中的`AtomicStampedReference`。
    *   **自旋开销**：如果并发冲突严重，大量线程会反复重试，这会持续消耗CPU资源。
    *   **单一变量原子性**：CAS只能保证一个共享变量的原子操作。若要对多个变量进行原子操作，就需要将它们封装成一个对象，然后使用`AtomicReference`。

在Java中，`java.util.concurrent.atomic`包下的所有类，如`AtomicInteger`, `AtomicLong`, `AtomicReference`等，都是基于CAS原理实现的。它们的`compareAndSet()`方法就是CAS操作的直接体现。