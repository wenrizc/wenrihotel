
Spring的代理机制是其整个AOP（面向切面编程）功能的核心，也是实现诸如声明式事务（@Transactional）、缓存（@Cacheable）、安全等横切关注点的基础。简单来说，Spring不是直接将Bean实例返回给我们，而是返回一个该Bean的代理对象。当我们调用代理对象的方法时，Spring就有机会在方法执行前后插入我们定义的切面逻辑。

Spring主要使用两种动态代理技术来创建这些代理对象，分别是JDK动态代理和CGLIB代理。

### JDK动态代理 (JDK Dynamic Proxy)

这是Java语言自带的一种代理机制，Spring利用它来实现AOP功能。

1. 核心原理：基于接口。
    
    JDK动态代理的核心要求是，目标对象（也就是我们自己编写的业务类）必须至少实现一个接口。代理工厂在运行时会动态地创建一个新的代理类，这个代理类会实现目标对象所实现的所有接口，并将方法调用转发到一个统一的处理器，即InvocationHandler接口的实现类。
    
2. 工作流程：
    
    当我们通过代理对象调用一个方法时，这个调用实际上被分派到了InvocationHandler的invoke方法。在这个invoke方法内部，Spring就可以控制整个调用流程，比如：
    
    - 在调用原始方法之前，执行“前置通知”（Before Advice）。
        
    - 通过Java的反射机制，调用目标对象的原始方法。
        
    - 在调用原始方法之后，执行“后置通知”（After Advice）或“返回通知”（After Returning Advice）。
        
    - 如果原始方法抛出异常，执行“异常通知”（After Throwing Advice）。
        
3. 优点与局限：
    
    - 优点：它是JDK原生支持的，不需要引入任何第三方库。
        
    - 局限：它最大的限制就是只能代理实现了接口的类。如果一个类没有实现任何接口，那么JDK动态代理就无法为它创建代理。
        

---

### CGLIB代理 (Code Generation Library)

为了弥补JDK动态代理的局限性，Spring引入了CGLIB这个强大的第三方代码生成库。

1. 核心原理：基于继承。
    
    CGLIB代理的核心思想是通过动态生成一个目标类的子类来创建代理。这个子类会重写目标类中所有非final的公共方法。
    
2. 工作流程：
    
    当调用代理对象（即子类对象）的方法时，调用会被CGLIB的MethodInterceptor拦截。与JDK的InvocationHandler类似，MethodInterceptor同样可以控制整个调用流程，在方法执行前后织入增强逻辑。当需要执行原始方法时，它会调用父类（即目标类）的相应方法。
    
3. 优点与局限：
    
    - 优点：它可以代理没有实现接口的普通类，这极大地扩展了Spring AOP的应用范围。
        
    - 局限：因为它基于继承，所以它无法代理`final`类（因为final类不能被继承），也无法代理被`final`关键字修饰的方法（因为final方法不能被重写）。
        

---

### Spring的选择策略与对比

那么，在一个具体的应用中，Spring是如何决定使用哪种代理机制的呢？

1. 默认选择策略：
    
    Spring框架会智能地进行判断。
    
    - 如果一个Bean实现了至少一个接口，Spring默认会使用JDK动态代理。
        
    - 如果一个Bean没有实现任何接口，Spring会选择使用CGLIB代理。
        
2. 配置修改策略：
    
    我们也可以通过配置来强制Spring使用CGLIB代理。例如，在Spring Boot中，可以在application.properties或application.yml中设置spring.aop.proxy-target-class=true。这样一来，无论目标Bean是否实现接口，Spring都会使用CGLIB来创建代理。
    
    为什么要这样做呢？一个常见的场景是为了解决“方法内调用”时代理失效的问题。如果使用JDK基于接口的代理，一个对象在内部调用自己的另一个方法，这个调用是直接通过`this`引用进行的，它会绕过代理对象，导致AOP（比如事务）不生效。而如果强制使用CGLIB，代理的是目标类本身，这个问题在一定程度上可以得到解决。
    
3. 总结对比：
    
    - 实现方式：JDK代理基于接口，CGLIB代理基于继承。
        
    - 代理对象：JDK代理创建的是接口的实现类，CGLIB代理创建的是目标类的子类。
        
    - 性能：随着JDK版本的迭代，两者的性能差距已经非常微小，在现代JVM上基本可以忽略不计。
        
    - 适用范围：JDK代理必须有接口，CGLIB则不需要，但不能代理final类或方法。
        