
HashMap是一个基于哈希表（Hash Table）实现的、用于存储键值对（Key-Value）的集合类。它允许键和值为null，并且是非线程安全的。其核心特点是能够根据键（Key）快速地定位到对应的值（Value）。

### 底层是如何实现的 (以JDK 1.8+为例)

HashMap的底层数据结构可以概括为：数组 + 链表 / 红黑树。

1.  主体结构是一个数组：
    这个数组在源码中被称为`table`，它的每一个元素都是一个“桶（bucket）”，存储的是一个节点的引用。
    `transient Node<K,V>[] table;`

2.  每个桶里是什么？
    在没有哈希冲突时，每个桶里只存放一个`Node`节点。这个`Node`节点包含了key, value, hash值以及指向下一个节点的`next`指针。
    当发生哈希冲突时（即多个不同的Key计算出的哈希值落在了同一个数组索引上），这些`Node`节点就会以链表的形式串联起来。

3.  何时出现红黑树？
    当某个桶里的链表长度过长时，为了优化查询性能，这个链表会从O(n)的查询效率，动态地转换成一个查询效率为O(log n)的红黑树。

所以，当我们执行`put(key, value)`时，大致流程如下：
1.  首先判断`table`数组是否初始化，如果没有，则进行初始化。
2.  调用`key.hashCode()`计算出哈希码，然后通过一个“扰动函数”进行再处理。
3.  将处理后的哈希值与数组长度减1进行按位与运算 (`&`)，得到该键值对在`table`数组中的索引位置。
4.  检查该索引位置是否已有节点：
    *   如果没有，直接创建一个新节点存入。
    *   如果有，说明发生了哈希冲突。此时会遍历这个位置的链表或红黑树：
        *   如果找到了一个Key与当前Key相同（通过`equals()`方法判断），则用新的Value覆盖旧的Value。
        *   如果遍历完都没有找到相同的Key，则将新的节点添加到链表的末尾（尾插法）或插入到红黑树中。
5.  在添加新节点后，会检查链表的长度。如果长度达到了树化的阈值（默认为8），并且数组的长度也达到了另一个阈值（默认为64），就会触发链表到红黑树的转换。

### 怎么哈希扰动的？

哈希扰动是HashMap设计中的一个精妙之处，目的是为了让哈希值分布得更均匀，从而减少哈希冲突。

在JDK 1.8中，扰动函数非常简洁：
`static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); }`

它的作用是：
1.  获取原始的`hashCode()`值，这是一个32位的int。
2.  将这个哈希值的高16位与低16位进行异或（XOR）运算。

为什么这么做？
因为计算数组索引的公式是 `(n - 1) & hash`。如果数组长度`n`比较小（比如16或32），那么只有`hash`值的低几位会参与运算，高位的变化对最终结果完全没有影响。这会导致，即使两个Key的`hashCode()`值差异很大，但只要它们的低几位相同，就一定会发生哈希冲突。

通过将高16位“扰动”到低16位，可以让哈希值的每一位都参与到最终索引的计算中，即使数组长度很小，也能充分利用`hashCode()`的全部分布特性，使得最终的索引位置更加随机和离散，有效减少了冲突的概率。

### 链表怎么转红黑树的？(树化)

树化过程有明确的触发条件：
1.  链表的长度必须达到8。
2.  同时，HashMap的`table`数组的长度必须达到64。

为什么需要第二个条件？
这是一个权衡。如果数组长度还很小，说明当前哈希冲突的主要原因可能是数组容量不足，而不是哈希函数本身不好。此时，HashMap会优先选择对数组进行扩容（resize），而不是立即树化。因为扩容后，所有节点会重新计算索引位置，冲突自然就可能减少了。只有在数组容量已经足够大（64）的情况下，仍然出现长链表，HashMap才认为有必要进行树化来优化查询。

当满足条件时，HashMap会调用`treeifyBin()`方法，这个方法会创建一个`TreeNode`节点，并将链表中的所有`Node`转换成`TreeNode`，构建成一个标准的红黑树结构，以保持树的平衡。

### 怎么退化的？(红黑树转链表)

退化过程发生在HashMap进行扩容（resize）或者`remove()`操作时。

当HashMap进行扩容时，它会创建一个新的、更大的数组，然后将旧数组中的所有节点重新计算位置并迁移到新数组中。在这个过程中，如果发现某个桶里的节点是一个红黑树，它会去检查这棵树的节点数量。

触发退化的条件是：红黑树的节点数量减少到了一个阈值，这个阈值是6。

为什么是6而不是7？
这是一个缓冲机制，避免在链表长度为8和7之间频繁地进行树化和退化操作，造成不必要的性能开销。

当满足退化条件时，HashMap会调用`untreeify()`方法，将这棵红黑树重新转换回一个普通的链表结构。

总结来说，HashMap通过数组+链表/红黑树的动态结构，以及精巧的哈希扰动和扩容机制，在空间和时间效率之间取得了非常好的平衡，是Java开发者必须掌握的核心数据结构。