
### 1. HashMap 是什么？

**答案**：  
HashMap 是 Java 集合框架中的一种 **键值对（Key-Value）存储结构**，位于 java.util 包，实现 Map 接口。它允许快速存取数据，支持 null 键和值，键唯一，基于哈希表实现。

**特点**：

- 无序（JDK 8 前后插入顺序不保证）。
- 高效查询、插入、删除，平均时间复杂度 O(1)。
- 非线程安全。

### 2. HashMap 的底层原理

**答案**：  
HashMap 的底层基于 **哈希表**，使用 **数组 + 链表 + 红黑树（JDK 8+）** 实现。键通过哈希函数映射到数组索引，冲突通过链表或红黑树解决。

#### 核心原理

1. **数据结构**：
    - **数组（Node[] table）**：主存储结构，初始容量 16。
    - **链表**：解决哈希冲突，同一桶内元素用链表连接。
    - **红黑树（JDK 8+）**：链表长度超 8（且数组容量 ≥ 64）时，转为红黑树。
2. **存储过程**：
    - **哈希计算**：hash(key) 计算键的哈希值，取模数组长度定位桶。
    - **放入桶**：
        - 无冲突：直接存入数组。
        - 有冲突：加入链表或红黑树。
    - **扩容**：负载因子（默认 0.75）超限时，数组翻倍（resize）。
3. **查询过程**：
    - 计算 hash(key)，定位桶。
    - 在链表或红黑树中查找键。

#### 关键点

- **哈希函数**：(key.hashCode() ^ (key.hashCode() >>> 16)) & (n-1)，减少冲突。
- **负载因子**：loadFactor = 0.75，平衡空间和性能。
- **树化阈值**：链表长度 > 8 且容量 ≥ 64，转红黑树。

### 3. HashMap 的底层是线程安全的吗？

**答案**：  
**不，HashMap 的底层不是线程安全的**。多线程环境下，put、get 等操作可能导致数据不一致或死循环（如 JDK 7 扩容时的环形链表）。

#### 原因

- **无同步机制**：内部无锁或原子操作。
- **并发问题**：
    - **覆盖**：线程 A 和 B 同时 put，可能覆盖彼此数据。
    - **扩容**：JDK 7 中多线程 resize 可能形成环形链表，死循环。
    - **脏读**：线程 A 修改时，线程 B 读到中间状态。

#### 线程安全解决

1. **Collections.synchronizedMap**：
    - 包装 HashMap，方法加 synchronized。
2. **Hashtable**（不推荐）：
    - 全方法加锁，性能差。

### 4.HashMap如何扩容？

**答案**：  
HashMap 的扩容是指当元素数量超过容量阈值时，增加底层数组大小并重新分配元素的过程。JDK 1.8 中：

- **触发条件**：size > threshold（默认负载因子 0.75）。
- **扩容方式**：数组容量翻倍（2^n），元素按新哈希重新分布。
- **核心优化**：链表或红黑树节点拆分，高低位分离，避免全重新计算哈希。
### 延伸与面试角度

- **JDK 7 vs JDK 8**：
    - **JDK 7**：数组 + 链表，扩容易死循环。
    - **JDK 8**：链表转红黑树，扩容优化，性能提升。
- **红黑树作用**：
    - 链表过长（O(n)）转为 O(log n)，优化极端冲突。
- **为什么非线程安全？**：
    - 追求性能，牺牲一致性，适合单线程或外部同步。
- **实际应用**：
    - 单线程缓存（如配置加载）。
    - 多线程用 ConcurrentHashMap（如微服务共享数据）。
- **面试点**：
    - 问“底层实现”时，提数组 + 链表/红黑树。
    - 问“线程安全”时，提问题和解决方案。

### 总结

HashMap 是基于哈希表的键值存储，底层用数组 + 链表 + 红黑树（JDK 8+），高效但非线程安全。线程安全需用 ConcurrentHashMap 或同步包装。面试时，可画桶结构或写并发问题示例，展示深入理解。