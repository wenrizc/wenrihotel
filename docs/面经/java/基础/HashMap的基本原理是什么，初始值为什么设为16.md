
HashMap在Java中是用于存储键值对（Key-Value）的核心集合类。它的底层实现原理可以概括为数组加链表或红黑树的结构。

#### 核心数据结构

1. 数组（Array）：HashMap内部维护一个数组，这个数组的每个元素被称为一个桶（Bucket）。这个数组是HashMap的主体结构，用于存放数据节点。
    
2. 节点（Node）：每个存入HashMap的数据，无论是键、值还是指向下一个节点的引用，都会被封装成一个内部节点对象（Node）。
    
3. 链表（Linked List）：当多个不同的键，经过哈希计算后，被定位到数组的同一个桶中时，就会发生哈希冲突。HashMap使用拉链法来解决冲突，即将这些冲突的节点以链表的形式存放在同一个桶中。
    
4. 红黑树（Red-Black Tree）：这是Java 8引入的一个重要优化。当某个桶中的链表长度达到一个特定的阈值（默认为8）时，为了提高查询效率，这个链表会自动转换成一个红黑树结构。
    

Put操作（存入数据）：

1. 计算哈希值：首先，调用键（Key）的hashCode()方法得到一个哈希码。
    
2. 计算数组索引：HashMap并不会直接用哈希码，而是会通过一个扰动函数对哈希码进行再处理，然后用这个最终的哈希值与（数组长度 - 1）进行按位与运算（&），得到该键值对应在数组中的索引位置。
    
3. 存放数据：
    
    - 如果计算出的索引位置没有任何元素（桶是空的），则直接创建一个新节点存入即可。
        
    - 如果该位置已经有元素（发生哈希冲突），则需要遍历这个桶中的链表或红黑树。
        
    - 在遍历过程中，会使用键的equals()方法来判断是否存在相同的键。
        
    - 如果找到了相同的键，则用新的值（Value）覆盖旧的值。
        
    - 如果遍历完整个链表或树都没有找到相同的键，则将新节点添加到链表的末尾，或者插入到红黑树中。
        
4. 检查并转换/扩容：
    
    - 在添加新节点后，如果链表长度达到树化阈值8，并且HashMap的总容量大于64，链表会转换为红黑树。
        
    - 每次成功添加元素后，都会检查当前已存储的元素数量是否超过了容量乘以负载因子所计算出的阈值。如果超过，就会触发扩容（resize），创建一个容量为原先两倍的新数组，并将所有元素重新计算哈希和索引后，迁移到新数组中。
        

Get操作（获取数据）：

1. 获取数据的流程与存放类似。首先也是通过键的哈希值计算出在数组中的索引。
    
2. 定位到指定的桶后，如果桶为空，则返回null。
    
3. 如果桶不为空，则遍历桶中的链表或红黑树，逐个用equals()方法比较键是否相同。
    
4. 如果找到了匹配的键，则返回其对应的值；如果遍历完也没找到，则返回null。
    


HashMap的初始容量被设为16（如果没有在构造函数中指定），并且其容量总是保持为2的幂次方（如16, 32, 64...），这背后有非常重要的性能考量。

核心原因是为了实现快速、均匀的哈希分布。

我们先来看一下前面提到的，如何通过哈希值计算数组索引：

index = (capacity - 1) & hash

这里的capacity就是HashMap的容量。当capacity是一个2的幂次方时，capacity - 1在二进制表示下，会是一个全为1的数字。

- 例如，当capacity = 16，其二进制是 10000。
    
- 那么 capacity - 1 = 15，其二进制是 01111。
    

此时，hash & 15 这个位运算，就等价于 hash % 16 这个取模运算。但是，位运算（&）的执行效率要比取模运算（%）高得多。JVM执行位运算只需要几个时钟周期，而取模运算涉及到除法，会慢很多。

为什么选择16，而不是8或32？

将容量设计为2的幂次方，是为了性能。而具体选择16作为初始值，则是一个在空间开销和时间开销之间的权衡，是JDK开发者根据通用场景做出的一个经验选择。

- 如果设置得太小（如2或4），那么即便是存放少量数据，也很容易触发扩容，而扩容是一个非常耗时的操作，这会增加时间开销。
    
- 如果设置得太大（如64或128），那么在只存放少量数据时，会预先分配一块很大的内存空间，造成不必要的空间浪费。
    

因此，16被认为是一个比较合理的折中值。它不大不小，对于绝大多数日常使用场景，既能减少初始阶段频繁扩容的次数，又不至于在map很小的时候浪费过多内存。当然，如果我们能够预估到要存放的数据量，最佳实践是在创建HashMap时就指定一个合适的初始容量，以获得最佳性能。