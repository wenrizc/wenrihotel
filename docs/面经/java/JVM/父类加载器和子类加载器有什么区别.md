
在Java虚拟机（JVM）中，类加载器（Class Loader）负责加载类的字节码文件（.class文件）到内存中，并生成对应的 `java.lang.Class` 对象。JVM的类加载机制采用了双亲委派模型（Parents Delegation Model），在这个模型中，父类加载器和子类加载器之间存在特定的关系和区别。

这里的“父”和“子”并非指面向对象继承关系中的父类和子类，而是指类加载器之间的层级委派关系。

主要区别如下：

1.  层级关系与委派顺序：
    *   父类加载器：在双亲委派模型中，一个类加载器（子类加载器）在尝试加载一个类之前，会首先将加载请求委派给其父类加载器去尝试加载。只有当父类加载器无法加载该类时（即在其搜索路径下找不到对应的.class文件），子类加载器才会自己尝试去加载。
    *   子类加载器：负责在父类加载器未能成功加载类之后，自己尝试从其特定的类路径（如应用程序的classpath、自定义的加载路径等）中查找并加载类。

2.  加载范围与职责：
    *   父类加载器通常负责加载更基础、更核心的Java类库。JVM中内建的类加载器层次结构如下（从顶层到底层）：
        *   启动类加载器（Bootstrap Class Loader）：这是最顶层的类加载器，通常由C++实现，是JVM自身的一部分。它负责加载Java的核心类库，如 `JAVA_HOME/jre/lib/rt.jar`、`resources.jar` 或 `sun.boot.class.path` 路径下的内容（Java 8及以前）。在Java 9及以后，由于模块化系统的引入，它主要加载 `java.base` 等核心模块。它没有“父加载器”的概念（或者说其父加载器为null）。
        *   扩展类加载器（Extension Class Loader）：它的父加载器是启动类加载器。它负责加载 `JAVA_HOME/jre/lib/ext` 目录下的JAR包，或者由 `java.ext.dirs` 系统属性指定的路径中的类库。
        *   应用程序类加载器（Application Class Loader，也称系统类加载器 System Class Loader）：它的父加载器是扩展类加载器。它负责加载用户类路径（`CLASSPATH`环境变量、`-cp` 或 `-classpath` 命令行参数、`java.class.path`系统属性）上指定的类库。应用程序中开发者自己编写的类通常由它加载。
    *   子类加载器（特别是自定义类加载器）：通常用于加载特定来源的类，例如从网络下载的类、从特定目录或JAR包动态加载的类、加密的类文件等。它们可以有自己的加载逻辑和搜索范围。

3.  可见性与隔离性：
    *   由父类加载器加载的类对于其所有子类加载器都是可见的。也就是说，子类加载器加载的类可以访问父类加载器加载的类。
    *   反之，由子类加载器加载的类对于其父类加载器是不可见的（除非通过反射等特殊手段）。这意味着父类加载器不能直接引用或加载由其子类加载器加载的类。
    *   这种单向的可见性有助于实现类加载的隔离，例如在Web容器（如Tomcat）中，每个Web应用都有自己的类加载器（通常是WebAppClassLoader），它加载应用自身的类，而这些类对于其他应用或容器的核心类加载器是隔离的，避免了类名冲突。

4.  双亲委派模型的目的：
    *   避免类的重复加载：当一个类需要被加载时，请求会逐级向上传递给父加载器。如果父加载器已经加载过这个类，它会直接返回已加载的 `Class` 对象，而不会再次加载，保证了内存中类的唯一性。
    *   保证Java核心库的安全性：核心类库（如 `java.lang.Object`）总是由启动类加载器加载。这可以防止用户编写的恶意代码通过自定义同名类来替换核心API，从而破坏Java的安全性。例如，用户无法自己写一个 `java.lang.String` 并让系统加载它，因为启动类加载器会优先加载JDK自带的 `java.lang.String`。

5.  破坏双亲委派：
    在某些特定场景下，双亲委派模型可能不适用，例如：
    *   SPI（Service Provider Interface）机制：如JDBC驱动加载。核心API（如 `java.sql.DriverManager`）由启动类加载器加载，但它需要加载由应用程序类加载器或扩展类加载器加载的具体数据库驱动实现。这时会用到线程上下文类加载器（Thread Context Class Loader）来反向委派。
    *   热部署、热插拔：OSGi、JPMS（Java Platform Module System）等模块化框架有更复杂的类加载需求，可能需要打破双亲委派来实现模块间的隔离和依赖管理。

总结来说，父类加载器和子类加载器的区别主要体现在它们在双亲委派模型中的层级、负责加载的类的范围和来源、以及它们加载的类之间的可见性规则。父类加载器通常负责加载更底层的、共享的类库，而子类加载器则在其父加载器无法满足加载请求时，从更具体的路径加载类，并实现了一定程度的隔离。

