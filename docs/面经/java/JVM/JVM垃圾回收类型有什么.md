
### JVM垃圾回收的分类

Java虚拟机（JVM）的垃圾回收（Garbage Collection, GC）是其自动内存管理的核心功能。根据不同的划分标准，JVM的垃圾回收可以分为几种不同的类型。

#### 1. 按回收区域划分

根据垃圾回收器作用的内存区域，GC可以主要分为以下几种类型：

*   **部分收集 (Partial GC)**：指不是完整收集整个Java堆的垃圾回收。
    *   **新生代收集 (Minor GC / Young GC)**：只针对新生代（Eden区和两个Survivor区）进行的垃圾回收。当新生代的Eden区满时，会触发Minor GC。由于新生代中的对象大多生命周期很短，因此Minor GC非常频繁，回收速度也较快。
    *   **老年代收集 (Major GC / Old GC)**：只针对老年代的垃圾回收。目前只有CMS收集器会有单独收集老年代的行为。 很多时候Major GC会由Minor GC触发。
    *   **混合收集 (Mixed GC)**：收集整个新生代以及部分老年代的垃圾回收，这在G1收集中是一种独特的行为。

*   **整堆收集 (Full GC)**：收集整个Java堆（包括新生代和老年代）和方法区的垃圾回收。 当老年代空间不足、方法区空间不足或开发者显式调用`System.gc()`时，都可能触发Full GC。Full GC的速度通常比Minor GC慢很多，因为它需要处理更多的对象和更大的内存空间，并且常常会导致较长时间的“Stop-The-World”（STW），即程序执行会暂停。

#### 2. 按垃圾收集器实现划分

随着JVM技术的发展，出现了多种具体的垃圾收集器实现，它们在单线程/多线程、并发/并行以及针对的内存区域上有所不同。主要的垃圾收集器包括：

**新生代收集器：**
*   **Serial 收集器**：一个单线程的收集器，进行垃圾回收时，必须暂停所有其他工作线程（Stop-The-World）。它是最基本的、发展历史最悠久的收集器。
*   **ParNew 收集器**：Serial收集器的多线程版本，除了使用多条线程进行垃圾收集外，其余行为与Serial收集器完全一样。它是许多运行在Server模式下的虚拟机的首选新生代收集器，因为它可以与CMS收集器配合工作。
*   **Parallel Scavenge 收集器**：一个新生代的多线程收集器，其目标是达到一个可控制的吞吐量（即CPU用于运行用户代码的时间与CPU总消耗时间的比值）。

**老年代收集器：**
*   **Serial Old 收集器**：Serial收集器的老年代版本，同样是单线程的，使用“标记-整理”算法。
*   **Parallel Old 收集器**：Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。
*   **CMS (Concurrent Mark Sweep) 收集器**：一种以获取最短回收停顿时间为目标的收集器。它在工作时，大部分时间垃圾收集线程可以与用户线程并发执行。它基于“标记-清除”算法实现。

**整堆收集器：**
*   **G1 (Garbage-First) 收集器**：一款面向服务端应用的垃圾收集器，它将整个Java堆划分为多个大小相等的独立区域（Region），并跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的区域。
*   **ZGC (Z Garbage Collector)**：一款在JDK 11中引入的、以低延迟为目标的垃圾收集器。它的设计目标是停顿时间不超过10毫秒，并且停顿时间不会随着堆的大小或存活对象数量的增加而增加。

这些收集器通常需要配对使用（新生代收集器 + 老年代收集器），例如`ParNew + CMS`或`Parallel Scavenge + Parallel Old`的组合。 而G1和ZGC等现代收集器则统一管理整个堆的回收。