
1.  类加载检查（Class Loading Check）：
    *   当JVM遇到一条 `new` 指令时，它首先会检查这条指令的参数（即要创建的对象的类）是否能在常量池中定位到一个类的符号引用。
    *   然后，检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，JVM必须先执行相应的类加载过程（加载、验证、准备、解析、初始化）。

2.  分配内存（Memory Allocation）：
    *   类加载检查通过后，JVM接下来会为新对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。
    *   分配内存的方式主要有两种，取决于Java堆是否规整（即已用内存和空闲内存是否泾渭分明）：
        *   指针碰撞（Bump the Pointer）：如果Java堆是规整的（通常在使用带有压缩整理功能的垃圾收集器如Serial, ParNew时），JVM会维护一个指针，指向已用内存和空闲内存的分界线。分配内存时，只需把该指针向空闲空间那边挪动一段与对象大小相等的距离即可。
        *   空闲列表（Free List）：如果Java堆不是规整的（通常在使用如CMS这种基于标记-清除算法的收集器时，会产生内存碎片），JVM就需要维护一个列表，记录哪些内存块是可用的。分配时，从列表中找到一块足够大的空间划分给对象实例，并更新列表记录。
    *   并发处理：在并发环境下，对象创建是非常频繁的行为。仅仅修改指针或查找空闲列表都可能存在线程安全问题。JVM通常采用以下两种方式解决：
        *   CAS（Compare-And-Swap）配上失败重试：CAS是一种乐观锁技术，JVM采用CAS操作来保证更新操作的原子性。
        *   TLAB（Thread Local Allocation Buffer，本地线程分配缓冲）：为每个线程在Java堆的Eden区预先分配一小块私有内存。当线程需要分配内存时，优先在自己的TLAB中分配。只有当TLAB用完并分配新的TLAB时，才需要同步锁定。通过 `-XX:+UseTLAB` 参数可以开启（默认是开启的）。

3.  初始化零值（Zero Initialization）：
    *   内存分配完成后，虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值（例如，数值类型为0，布尔类型为false，引用类型为null）。
    *   这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
    *   如果使用了TLAB，这个过程也可以在TLAB分配时顺便完成。

4.  设置对象头（Object Header Setup）：
    *   接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息（指向方法区中类信息的指针）、对象的哈希码（实际上是延迟计算，但也预留了空间）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）中。
    *   对象头还可能包含锁状态标志、偏向锁线程ID、偏向时间戳等，这取决于锁优化策略。

5.  执行`<init>`方法（Instance Initialization）：
    *   从JVM的视角看，以上步骤完成后，一个新的对象已经产生了。但从Java程序的视角来看，对象创建才刚刚开始——构造函数（或者说`<init>()`方法）还没有执行。
    *   执行 `new` 指令之后，会接着执行对象的`<init>()`方法，按照程序员的意愿对对象进行初始化。这包括执行实例变量的赋值语句、实例代码块，以及调用构造器。
    *   `<init>()`方法是由编译器收集类中所有实例初始化代码（包括实例变量的显式赋值、实例初始化块）和构造函数中的代码，按它们在源代码中出现的顺序组织而成的。如果存在继承关系，会先调用父类的`<init>()`方法。

总结来说，JVM创建一个对象的完整流程是：
1.  检查类是否已加载。
2.  为对象分配内存空间（使用指针碰撞或空闲列表，并处理并发问题如CAS或TLAB）。
3.  将分配到的内存空间初始化为零值（赋予字段默认值）。
4.  设置对象头信息（元数据、哈希码、GC信息、锁信息等）。
5.  执行对象的`<init>()`方法（实例变量赋值、实例代码块、构造函数调用）。
