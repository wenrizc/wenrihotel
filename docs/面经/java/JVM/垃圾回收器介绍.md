
垃圾回收器（Garbage Collector, GC）是Java虚拟机（JVM）中一项至关重要的自动内存管理机制。它的主要职责是自动识别并回收Java堆（Heap）中不再被程序使用的对象（即“垃圾”），从而释放内存空间，供新的对象分配使用，防止内存泄漏和内存溢出。

垃圾回收器的工作可以大致分为两个主要方面：

1.  如何判断对象是“垃圾”？
    常见的判断算法有两种：
    *   引用计数法（Reference Counting）：
        *   原理：给每个对象添加一个引用计数器，当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。任何时刻计数器为0的对象就是不可能再被使用的。
        *   优点：实现简单，判定效率高，大部分情况下是个不错的算法。
        *   缺点：难以解决对象之间循环引用的问题（例如对象A引用对象B，对象B也引用对象A，但没有其他外部引用指向它们，此时它们的计数器都不为0，但实际上它们是垃圾）。主流的Java虚拟机一般不采用这种算法。
    *   可达性分析算法（Reachability Analysis）：
        *   原理：这是目前主流JVM采用的算法。它通过一系列称为“GC Roots”的根对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到任何GC Roots之间都没有引用链相连时（即从GC Roots到这个对象不可达），则证明此对象是不可用的，即为垃圾。
        *   GC Roots对象包括：
            *   虚拟机栈（栈帧中的本地变量表）中引用的对象。
            *   方法区中类静态属性引用的对象。
            *   方法区中常量引用的对象。
            *   本地方法栈中JNI（即Native方法）引用的对象。
            *   JVM内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象等。
            *   被同步锁（`synchronized`关键字）持有的对象。

2.  如何回收“垃圾”？
    当确定了哪些对象是垃圾之后，垃圾回收器会采用不同的回收算法来清理这些垃圾对象所占用的内存。常见的回收算法有：
    *   标记-清除算法（Mark-Sweep）：
        *   过程：首先标记出所有需要回收的对象（或者标记出所有存活的对象），在标记完成后统一回收所有被标记（或未被标记）的对象。
        *   缺点：效率不高（标记和清除两个过程效率都不高）；会产生大量不连续的内存碎片，导致后续分配大对象时可能找不到足够的连续内存而提前触发另一次GC。
    *   标记-复制算法（Mark-Copy，通常称为复制算法）：
        *   过程：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
        *   优点：实现简单，运行高效，不会产生内存碎片。
        *   缺点：将可用内存缩小为了原来的一半，代价较高。对于存活对象较多的情况，复制开销会比较大。
        *   常用于新生代的回收，因为新生代中对象特点是“朝生夕死”，每次回收只有少量对象存活。
    *   标记-整理算法（Mark-Compact）：
        *   过程：标记过程与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。
        *   优点：解决了标记-清除算法的内存碎片问题，也避免了复制算法的空间浪费。
        *   缺点：移动对象是一个相对耗时的操作，尤其是在存活对象较多且需要移动时。
        *   常用于老年代的回收，因为老年代对象存活率高，不适合复制算法。

JVM中的分代垃圾回收策略：
现代JVM通常采用分代收集（Generational Collection）的策略。它根据对象存活周期的不同将Java堆划分为不同的区域（代）：
*   新生代（Young Generation）：绝大多数新创建的对象都分配在这里。新生代又可以细分为Eden区和两个Survivor区（通常称为From区和To区，或S0和S1）。
    *   回收特点：新生代中的对象生命周期短，每次GC都有大量对象被回收。因此新生代GC（Minor GC / Young GC）通常采用复制算法，效率较高。
    *   对象晋升：经过多次Minor GC后仍然存活的对象，或者某些大对象（例如通过`-XX:PretenureSizeThreshold`设置），会被晋升到老年代。
*   老年代（Old Generation / Tenured Generation）：存放生命周期较长的对象，以及从新生代晋升过来的对象。
    *   回收特点：老年代对象存活率高，GC频率相对较低。老年代GC（Major GC / Full GC，严格来说Full GC还包括方法区/元空间的回收）通常采用标记-清除或标记-整理算法。

主要的垃圾回收器介绍：
JVM提供了多种垃圾回收器，它们针对不同的应用场景和性能目标进行了优化，可以根据需要进行选择和配置。

*   Serial收集器：
    *   单线程收集器，进行垃圾回收时，必须暂停所有其他工作线程（Stop-The-World, STW）。
    *   新生代采用复制算法，老年代采用标记-整理算法。
    *   优点：简单高效（对于单核CPU或内存较小的环境），无线程交互开销。
    *   缺点：STW时间长，不适合对响应时间要求高的服务端应用。
    *   通常用于Client模式下的JVM。

*   ParNew收集器：
    *   Serial收集器的多线程版本，主要工作在新生代。
    *   新生代采用复制算法，在GC时多个GC线程并行工作，但用户线程仍然需要暂停（STW）。
    *   是许多Server模式下JVM首选的新生代收集器，常与CMS收集器配合使用。

*   Parallel Scavenge收集器：
    *   新生代收集器，多线程，采用复制算法。
    *   特点：关注点是达到一个可控制的吞吐量（Throughput = CPU运行用户代码时间 / (CPU运行用户代码时间 + CPU垃圾收集时间)）。它提供了参数来精确控制最大垃圾收集停顿时间（`-XX:MaxGCPauseMillis`）和直接设置吞吐量大小（`-XX:GCTimeRatio`）。
    *   也称为“吞吐量优先”收集器。
    *   其老年代版本是Parallel Old收集器（采用标记-整理算法）。

*   CMS（Concurrent Mark Sweep）收集器：
    *   老年代收集器，目标是获取最短回收停顿时间，适合对响应时间有高要求的应用。
    *   基于标记-清除算法实现。
    *   特点是大部分GC过程（初始标记、并发标记、重新标记、并发清除）可以与用户线程并发执行，从而减少STW时间。初始标记和重新标记仍然需要STW，但时间很短。
    *   缺点：
        *   对CPU资源敏感（并发阶段会占用一部分CPU）。
        *   无法处理浮动垃圾（Floating Garbage），可能导致Full GC提前。
        *   使用标记-清除算法会产生内存碎片，可能需要配合参数（如`-XX:+UseCMSCompactAtFullCollection`和`-XX:CMSFullGCsBeforeCompaction`）进行碎片整理。
        *   在JDK 9中被标记为废弃，JDK 14中被移除。

*   G1（Garbage-First）收集器：
    *   面向服务端应用的垃圾收集器，设计目标是替换CMS。在JDK 9之后成为默认的垃圾收集器。
    *   特点：
        *   并行与并发：能充分利用多CPU、多核环境下的硬件优势。
        *   分代收集：保留了分代思想，但不再是物理上连续的新生代和老年代。整个堆被划分为多个大小相等的独立区域（Region），每个Region可以扮演Eden、Survivor或Old的角色。
        *   空间整合：从整体上看是基于标记-整理算法，从局部（两个Region之间）看是基于复制算法。这意味着G1运行时不会产生内存碎片。
        *   可预测的停顿时间模型：用户可以指定期望的最大GC停顿时间（通过`-XX:MaxGCPauseMillis`），G1会尽力满足。它通过维护一个优先列表，优先回收那些价值（回收后能获得最多空闲空间）最大的Region。

*   Shenandoah收集器（JDK 12引入，Open JDK项目）：
    *   目标是实现与应用程序几乎同时运行的GC，停顿时间与堆大小无关。
    *   通过连接矩阵（Connection Matrix）、转发指针（Forwarding Pointers）等技术，在并发阶段完成对象的移动和整理。

*   ZGC（Z Garbage Collector）（JDK 11引入实验性，JDK 15正式可用）：
    *   目标也是极低的停顿时间（亚毫秒级），与堆大小无关，可管理非常大的堆（TB级别）。
    *   采用染色指针（Colored Pointers）和读屏障（Load Barriers）技术，使得几乎所有的GC工作（标记、转移、重定位）都能并发执行。
