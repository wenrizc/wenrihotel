
设计模式是在软件工程中，针对在软件开发过程中普遍存在的问题所提出的解决方案。 经过长时间的试验和错误总结，这些模式成为了许多软件开发人员的最佳实践。 使用设计模式可以重用代码、让代码更容易被他人理解、并保证代码可靠性。

设计模式通常分为三大类：创建型模式、结构型模式和行为型模式。

### 创建型模式 (Creational Patterns)
这类模式主要解决对象创建的问题，将对象的创建和使用分离。

#### 1. 单例模式 (Singleton Pattern)
**介绍**：
单例模式确保一个类只有一个实例，并提供一个全局访问点来访问这个实例。 当系统中某个类只需要一个实例时，例如全局缓存或设备管理器，就可以使用单例模式。

**生活举例**：
一个国家只有一个政府，无论何时提及“某国政府”，指的都是同一个权力机构。 同样地，一个班级通常只有一个班主任。

**代码举例 (懒汉式 - 线程安全)**:
```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
**说明**：
上述代码通过双重检查锁定（Double-Checked Locking）确保了在多线程环境下也只创建一个实例，并且在首次调用`getInstance()`方法时才创建对象，实现了懒加载。 `volatile` 关键字确保了 `instance` 变量在多线程环境下的可见性。

---

#### 2. 工厂模式 (Factory Pattern)
**介绍**：
工厂模式提供了一种创建对象的最佳方式，它定义了一个创建对象的接口，但让子类决定实例化哪一个类。 这样，客户端代码就不需要知道具体要创建哪个类的实例，降低了耦合度。 工厂模式主要分为简单工厂、工厂方法和抽象工厂。

**生活举例**：
当你想吃饭时，你只需要去餐厅（工厂）告诉服务员你要吃什么（例如鱼香肉丝），而不需要关心这道菜具体是怎么做的。 餐厅就是一个工厂，根据你的需求生产不同的菜品。

**代码举例 (简单工厂)**:
```java
public interface Shape {
   void draw();
}

public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}

public class Circle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}

public class ShapeFactory {
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      }
      return null;
   }
}
```
**说明**：
客户端可以通过 `ShapeFactory` 的 `getShape` 方法传入不同的类型来获取相应的形状对象，而无需关心 `Circle` 或 `Rectangle` 是如何被实例化的。

---

### 结构型模式 (Structural Patterns)
这类模式关注如何将类或对象组合成更大的结构，同时保持结构的灵活和高效。

#### 3. 装饰器模式 (Decorator Pattern)
**介绍**：
装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。 它通过将对象包装在装饰器类中，来动态地修改其行为。

**生活举例**：
给一杯咖啡（原始对象）加糖、加奶（装饰器），每一层添加都增加了新的风味，但咖啡本身并没有改变。你可以动态地选择添加不同的调料。

**代码举例**:
```java
public interface Coffee {
    String getDescription();
    double getCost();
}

public class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Simple coffee";
    }

    @Override
    public double getCost() {
        return 1.0;
    }
}

public abstract class CoffeeDecorator implements Coffee {
    protected final Coffee decoratedCoffee;

    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }

    public String getDescription() {
        return decoratedCoffee.getDescription();
    }

    public double getCost() {
        return decoratedCoffee.getCost();
    }
}

public class WithMilk extends CoffeeDecorator {
    public WithMilk(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return super.getDescription() + ", with milk";
    }

    @Override
    public double getCost() {
        return super.getCost() + 0.5;
    }
}

public class WithSugar extends CoffeeDecorator {
    public WithSugar(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return super.getDescription() + ", with sugar";
    }

    @Override
    public double getCost() {
        return super.getCost() + 0.2;
    }
}
```
**说明**：
`WithMilk` 和 `WithSugar` 是具体的装饰器类，它们包装了一个 `Coffee` 对象，并在不改变 `SimpleCoffee` 类的情况下为其添加了新的描述和成本。

---

### 行为型模式 (Behavioral Patterns)
这类模式主要负责对象间的高效沟通和职责委派。

#### 4. 观察者模式 (Observer Pattern)
**介绍**：
观察者模式定义了对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并被自动更新。 这也被称为发布-订阅模式。

**生活举例**：
当你订阅了一个视频博主（被观察者），当这个博主发布新视频时（状态改变），你（观察者）就会收到通知。

**代码举例**:
```java
import java.util.ArrayList;
import java.util.List;

public interface Subject {
    void registerObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObservers();
}

public interface Observer {
    void update(String message);
}

public class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private String message;

    public void setMessage(String message) {
        this.message = message;
        notifyObservers();
    }

    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        observers.remove(o);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}

public class ConcreteObserver implements Observer {
    private String name;

    public ConcreteObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + " received message: " + message);
    }
}
```
**说明**：
当 `ConcreteSubject` 的状态（`message`）通过 `setMessage` 方法改变时，它会调用 `notifyObservers` 方法，遍历所有已注册的 `ConcreteObserver` 并调用它们的 `update` 方法，从而通知它们发生了变化。