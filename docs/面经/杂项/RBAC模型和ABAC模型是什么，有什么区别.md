
### 1. RBAC (Role-Based Access Control) 基于角色的访问控制

RBAC的核心思想是，访问权限不直接授予用户，而是授予“角色”（Role）。然后，将用户分配到相应的角色中。这样，用户就通过其所属的角色，间接地拥有了该角色所包含的所有权限。

它的关系可以简化为：用户-角色-权限 (Who -> What roles -> What permissions)。权限的集合是静态地绑定在角色上的。


让我们以一个常见的内容管理系统（CMS）为例：

- 用户 (Users): 张三、李四、王五
    
- 角色 (Roles):
    
    - 管理员 (Admin): 拥有系统的所有权限。
        
    - 编辑 (Editor): 可以创建、修改和发布文章。
        
    - 撰稿人 (Contributor): 只能创建和修改自己的文章草稿，不能发布。
        
- 权限 (Permissions):
    
    - post:create (创建文章)
        
    - post:edit (修改文章)
        
    - post:publish (发布文章)
        
    - user:manage (管理用户)
        

在这个模型中，我们的授权逻辑如下：

1. 我们将权限分配给角色：
    
    - 管理员角色 拥有 post:create, post:edit, post:publish, user:manage 权限。
        
    - 编辑角色 拥有 post:create, post:edit, post:publish 权限。
        
    - 撰稿人角色 拥有 post:create, post:edit 权限。
        
2. 我们将用户分配给角色：
    
    - 张三是管理员。
        
    - 李四是编辑。
        
    - 王五是撰稿人。
        

现在，当王五尝试发布文章时，系统会检查：王五是“撰稿人”角色 -> “撰稿人”角色没有 post:publish 权限 -> 拒绝操作。

RBAC的优点是模型清晰，易于理解和管理。在用户和权限数量众多时，通过角色这个中间层，极大地简化了授权管理。

---

### 2. ABAC (Attribute-Based Access Control) 基于属性的访问控制


ABAC是一种更为灵活和精细的访问控制模型。它的核心思想是基于一系列“属性”（Attribute）来动态地决定是否授予访问权限。这些属性可以来自任何地方。

通常，ABAC的决策逻辑基于一个“策略”（Policy），这个策略会评估以下四类属性：

- 主体属性 (Subject attributes): 关于发起请求的用户的信息，如年龄、部门、安全等级、职位等。
    
- 客体/资源属性 (Object/Resource attributes): 关于被访问资源的信息，如文件类型、敏感度、所属项目、创建时间等。
    
- 操作属性 (Action attributes): 关于正在执行的操作的信息，如读取、写入、删除、审批等。
    
- 环境属性 (Environment attributes): 关于访问发生时的上下文信息，如时间、地点（IP地址）、设备类型等。
    

它的决策可以表述为：当主体的属性、客体的属性、操作和环境属性满足某个策略时，允许或拒绝访问。


我们以一个企业报销系统为例，这个场景用RBAC会非常复杂：

假设有一个策略 (Policy)：  
“允许一个用户审批报销单，当且仅当：

1. 该用户的角色是‘经理’ (主体属性)
    
2. 并且报销单的金额小于该用户自身的‘审批额度’属性 (主体属性 vs 客体属性)
    
3. 并且报销单的类型不是‘特殊报销’ (客体属性)
    
4. 并且当前时间是工作日的9点到18点 (环境属性)”
    

在这个模型下：

- 用户A: 角色是经理，审批额度是5000元。
    
- 用户B: 角色是经理，审批额度是10000元。
    
- 报销单C: 金额4000元，类型是差旅费。
    
- 报销单D: 金额8000元，类型是差旅费。
    

当用户A尝试审批报销单C时，系统评估：

- 角色是经理？是。
    
- 4000 < 5000？是。
    
- 类型不是特殊报销？是。
    
- 当前是工作时间？是。
    
- 结论：允许操作。
    

当用户A尝试审批报销单D时，因为 8000 不小于 5000，操作将被拒绝。而用户B则可以审批报销单D。

可以看到，ABAC不需要为“5000元额度经理”和“10000元额度经理”创建两个不同的角色，而是通过动态评估属性来实现更细粒度的控制。

---

### 3. RBAC 与 ABAC 的核心区别

|       |                                    |                                       |
| ----- | ---------------------------------- | ------------------------------------- |
| 特性    | RBAC (基于角色的访问控制)                   | ABAC (基于属性的访问控制)                      |
| 核心思想  | 以“角色”为中心，权限静态地赋予角色。                | 以“策略”和“属性”为中心，权限是动态计算出来的。             |
| 授权粒度  | 较粗。权限控制到角色级别。                      | 非常精细。可以控制到每一次具体访问的上下文。                |
| 灵活性   | 较低。对于超出角色定义的场景，需要创建新角色，可能导致“角色爆炸”。 | 极高。可以组合无限的属性来定义复杂的访问规则，无需修改主体或客体。     |
| 管理复杂度 | 概念简单，易于上手。但在复杂场景下，角色管理会变得困难。       | 初期设置复杂，需要设计策略引擎和属性来源。但对于复杂规则，长期维护更清晰。 |
| 适用场景  | 适用于企业内部系统、CMS等权限结构稳定、分层明确的场景。      | 适用于金融、云计算、物联网等需要高度灵活、动态和上下文感知权限控制的场景。 |

---

### 4. 拓展与延伸

在实际的大型互联网公司项目中，我们很少会极端地只选择一种模型。

#### 混合模型 (RBAC + ABAC)

这是一种非常常见的实践。我们用RBAC来解决大部分通用的、粗粒度的权限问题，比如“这个用户是不是我们支付系统的管理员”。这可以快速地过滤掉大量不相关的请求。

然后，在通过了RBAC检查后，再用ABAC进行细粒度的、动态的检查。例如，“这个支付管理员能否操作一笔超过100万的交易？”，这时就需要检查管理员的级别（主体属性）、交易的风险等级（客体属性）、操作时间（环境属性）等。

这种混合模型兼顾了RBAC的简洁性和ABAC的灵活性。

#### 实现层面的考量

- RBAC的实现相对直接，通常在数据库中建立 users, roles, permissions 以及两张中间表 user_roles 和 role_permissions 即可。
    
- ABAC的实现则更复杂，通常需要一个独立的“策略引擎”（Policy Engine），比如开源的 OPA (Open Policy Agent)。应用服务在收到请求时，会将相关的各类属性打包，发送给策略引擎去评估，然后根据返回的 allow/deny 结果来执行业务逻辑。这带来了额外的网络开销和延迟，是系统设计时需要权衡的。
    

#### 其他模型

除了RBAC和ABAC，还有像ReBAC（Relationship-Based Access Control），它在社交网络、云盘分享等场景中非常有用，比如“A能访问B，因为B把文档分享给了A”，这里的“分享”就是一种关系。

总而言之，选择哪种模型并没有绝对的优劣，而是取决于具体的业务场景、未来的扩展性需求以及团队对复杂度的接受程度。我的分享就到这里，希望能解答您的问题，也欢迎您提出更多深入的问题。