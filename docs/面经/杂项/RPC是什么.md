
RPC，全称是Remote Procedure Call，也就是远程过程调用。通俗地讲，它是一种技术，允许一台计算机上的程序调用另一台计算机上的函数或方法，而代码的编写方式和调用本地函数几乎一样。程序员不需要关心底层网络通信的复杂细节，比如如何建立连接、如何打包和传输数据等。

它的核心目标是让分布式系统中的服务间通信变得像单体应用内部调用一样简单、透明。这在当下的微服务架构中是至关重要的基础组件。

一个完整的RPC调用过程，虽然对开发者是透明的，但其内部通常包含以下几个关键步骤和组件：

- Client (客户端/服务调用方): 发起调用的服务。
    
- Server (服务端/服务提供方): 提供实际功能的服务。
    
- Stub (存根): 这是RPC框架的核心。它分为客户端存根 (Client Stub) 和服务端存根 (Server Stub)。
    
    - 客户端存根：它伪装成一个本地对象，供客户端直接调用。当客户端调用它的方法时，它负责将方法名、参数等信息进行打包和序列化，然后通过网络发送给服务端。
        
    - 服务端存根：接收到来自客户端的数据后，它负责解码和反序列化，然后根据解码出的信息，去调用本地的、真正的业务逻辑方法。
        

一次完整的RPC调用流程可以概括为：

1. `客户端调用`: 服务调用方像调用本地方法一样，调用客户端存根。
    
2. `序列化与打包`: 客户端存根将调用的接口、方法、参数等信息序列化成二进制流。
    
3. `网络传输`: 客户端通过网络库（例如Netty）将打包好的数据发送给服务提供方。
    
4. `接收与解码`: 服务端的网络监听器接收到数据，服务端存根进行解码和反序列化，还原出请求的详细信息。
    
5. `服务端执行`: 服务端存根根据解码后的信息，调用本地的真实业务方法来执行。
    
6. `编码与返回`: 执行结果被序列化打包，通过网络回传给客户端。
    
7. `解码与返回`: 客户端存根接收到响应数据，解码反序列化后，将最终结果返回给调用方，完成整个调用。
    

在这个过程中，服务注册与发现也扮演着重要角色。服务提供方启动时会将自己的服务地址注册到注册中心（如Zookeeper, Consul, Nacos），调用方在调用前会去注册中心拉取可用的服务地址列表，从而实现动态的服务发现和负载均衡。

RPC与RESTful API的对比：

|特性|RPC (以gRPC为例)|RESTful API|
|---|---|---|
|设计理念|面向过程/动作 (Action-Oriented)|面向资源 (Resource-Oriented)|
|协议|通常基于TCP，也可以使用HTTP/2 (如gRPC)|主要基于HTTP/1.1或HTTP/2|
|数据格式|通常是二进制协议 (如Protobuf)，效率高，体积小|通常是JSON或XML，可读性好，但相对冗长|
|性能|性能更高，因为二进制协议和长连接减少了网络开销|相对较低，HTTP/1.1的请求头较大，且多是短连接|
|耦合度|客户端和服务端通过IDL（接口定义语言）文件强耦合|耦合度较低，通过URL和HTTP方法定义操作，更灵活|
|规范性|依赖具体框架，百花齐放|有统一的HTTP标准，如状态码、请求方法等|
|适用场景|公司内部服务间的高性能调用，对性能要求高的场景|对外开放的API，需要良好可读性和浏览器兼容性的场景|

