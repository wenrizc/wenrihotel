
与精准的教科书式实现不同，Redis 出于对性能和内存占用的极致追求，采用了一种 **近似 LRU (Approximated LRU)** 算法。

一个精准的 LRU 实现通常需要一个双向链表和一个哈希表。当数据被访问时，需要将其从链表中间移动到表头，这个操作是 O(1) 的。但这种实现有两个对于 Redis 来说难以接受的缺点：
1.  **内存开销大**：为每一个键值对维护一个链表节点会带来额外的指针开销，当键数量巨大时，这部分内存占用非常可观。
2.  **操作有开销**：虽然是 O(1)，但每次访问都需要进行链表操作，在高并发下仍会影响性能。

因此，Redis 选择了一种内存占用极低且执行速度很快的近似算法。

### Redis LRU 的实现机制

Redis 的 LRU 实现核心依赖于每个 Redis 对象（`redisObject`）头部的一个元数据字段。

#### 1. `redisObject` 中的 `lru` 字段

每个 Redis 对象（无论是 String, List, Hash 等）的内部结构 `redisObject` 中，都有一个 24 位的 `lru` 字段。

*   **它的作用**：这个字段用于记录该对象 **最后一次被访问的时间戳**。

*   **时间戳的来源**：Redis 服务器内部维护一个全局的 `server.lruclock` 时钟。当一个键被访问时（如 `GET`、`SET` 等命令），Redis 会将当前 `server.lruclock` 的值更新到该键对应的 `redisObject` 的 `lru` 字段中。

*   **时钟精度**：这个 `server.lruclock` 并不需要是高精度的。它通常以秒或更低的频率更新，这足以区分出哪些键是“最近”被访问的。

有了这个时间戳，Redis 就能知道每个键的“空闲时间”（Idle Time）了。
`空闲时间 = 当前服务器时钟 (server.lruclock) - 对象的 lru 字段值`
**空闲时间越长，代表这个键越久没有被访问，也就越符合被淘汰的条件。**

#### 2. 淘汰过程：采样淘汰 (Sampling Eviction)

当 Redis 内存使用达到 `maxmemory` 限制时，淘汰过程被触发。但 Redis **不会遍历所有的键** 去寻找那个空闲时间最长的键，因为这将是一个非常耗时的 O(N) 操作，会阻塞整个服务。

取而代之，Redis 采用以下采样策略：

1.  **随机采样**：Redis 会从所有设置了过期时间的键（对于 `volatile-lru`）或所有键（对于 `allkeys-lru`）中，随机挑选出 `N` 个键。这个 `N` 的值由配置参数 `maxmemory-samples` 决定（默认值为 5）。

2.  **构建候选池**：Redis 会遍历这 `N` 个被采样的键，计算出每一个键的空闲时间。

3.  **淘汰最优者**：在 `N` 个样本中，找到那个 **空闲时间最长**（也就是 `lru` 值最小）的键，并将其淘汰。

4.  **循环检查**：这个过程会循环执行，直到释放了足够的内存，使内存使用降到 `maxmemory` 限制以下。

### 图解采样过程

想象一下 Redis 内存中有成千上万个键，每个键都有一个“最后访问时间”标签。

1.  **内存满了！**
2.  Redis 随机抓取 5 个键（假设 `maxmemory-samples=5`）。
3.  检查这 5 个键的标签：
    *   Key-A: 10:05
    *   Key-B: 10:15
    *   Key-C: 10:02  <-- **最旧的**
    *   Key-D: 10:11
    *   Key-E: 10:14
4.  Redis 发现 Key-C 的时间最久远，于是将 Key-C 删除。
5.  如果内存还不够，就重复第 2-4 步。

### 配置参数

你可以通过 `redis.conf` 文件或 `CONFIG SET` 命令来调整 LRU 的行为：

*   **`maxmemory-policy`**: 设置为以下两种之一来启用 LRU。
    *   `volatile-lru`: 只在设置了过期时间的键中进行 LRU 淘汰。
    *   `allkeys-lru`: 在所有键中进行 LRU 淘汰，无论是否设置了过期时间。

*   **`maxmemory-samples [count]`**: 设置每次淘汰时采样的键数量，默认为 5。
    *   **值越大**：LRU 的近似程度就越高，结果越接近真实的 LRU，但消耗的 CPU 时间也越多。
    *   **值越小**：执行速度越快，但淘汰的精确度会降低，可能会错误地淘汰掉不是最旧的键。

### 总结：Redis LRU 策略的特点

*   **优点**：
    *   **内存高效**：不需要额外的链表结构，只在对象头中增加了一个小字段。
    *   **性能高**：淘汰过程不需全局扫描，通过小范围的采样快速完成，对主流程影响小。

*   **缺点**：
    *   **非精确**：由于是基于采样的近似算法，它不能保证 100% 淘汰掉那个最久未被访问的键。一个非常“冷”的数据有可能因为一直没被采样到而“幸存”下来。

但在绝大多数实际应用中，Redis 的这种近似 LRU 算法已经足够好用，并且在性能和内存占用上取得了绝佳的平衡。