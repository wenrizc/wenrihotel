关于Redis的过期删除策略，涉及到两个层面：一个是删除策略，即决定何时去删除那些已经过期的key；另一个是淘汰策略，即当内存满了之后，如何选择key来释放空间。我先来谈谈过期删除策略。

Redis并不会在key的过期时间一到就立刻删除它，而是采用了一种组合策略来处理，主要包括两种方式：惰性删除和定期删除。

惰性删除 (Lazy Deletion / Passive Deletion)：

惰性删除是指，Redis平时不会主动去检查和删除过期的key。只有当客户端尝试访问某个key时（比如执行GET命令），Redis才会先检查这个key是否已经设置了过期时间，以及这个过期时间是否已到。如果确认已过期，Redis就会执行删除操作，并且返回一个空值给客户端，就好像这个key一开始就不存在一样。

- 优点: 这种策略对CPU非常友好。删除操作只在key被访问时才触发，不会将CPU时间浪费在检查那些可能永远不会再被访问的过期key上。
    
- 缺点: 如果一个key过期后，一直没有被访问，那么它就会一直占用着内存，永远不会被删除。这相当于一种内存泄漏。如果这样的key大量存在，会造成严重的内存浪费。
    

定期删除 (Active Deletion)：

为了弥补惰性删除的不足，Redis引入了定期删除策略。它会在后台启动一个定时任务，周期性地执行删除操作。

- 工作方式: Redis会定期（默认每秒10次，这个频率hz可以配置）从设置了过期时间的key集合中，随机抽取一部分key（默认是20个）进行检查。如果发现其中有已过期的key，就将它们删除。
    
- 智能调整: 这个过程还有一个优化。如果在一轮抽查中，被删除的过期key的比例超过了25%（即超过5个），Redis会认为当前过期的key还很多，于是会立即再进行下一轮抽cha，直到过期key的比例低于25%，或者这次任务的执行时间超过了某个阈值，才会停止。这样做是为了在清理内存和避免长时间占用CPU之间取得平衡。
    
- 优点: 通过周期性地、随机地清理过期key，可以有效地回收被占用的内存，很大程度上避免了因惰性删除导致的内存泄漏问题。
    
- 缺点:
    
    - 内存清理不及时: 这种删除是随机抽样的，而不是对所有key进行轮询，所以总会有一些过期key被遗漏掉，无法被及时删除。
        
    - CPU占用: 虽然有保护机制，但在业务高峰期，如果过期key很多，定期删除任务仍然会占用一定的CPU资源。
        

Redis最终采用的是惰性删除和定期删除相结合的策略。这两种策略互为补充：

- 定期删除作为主要手段，持续地、主动地清理大部分过期key，回收内存。
    
- 惰性删除作为最后一道防线，确保了即使某个过期key在定期删除中被遗漏了，当它被访问时也一定会被清理掉，并且不会返回脏数据给客户端。
    

