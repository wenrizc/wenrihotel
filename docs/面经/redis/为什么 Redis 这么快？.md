
**1. 完全基于内存的操作**
这是 Redis 高性能最根本的原因。所有数据都存储在内存中，内存的读写速度比磁盘快几个数量级。 这使得 Redis 能够以微秒级的延迟处理请求。

**2. 高效的 I/O 模型**
如上文所述，通过 I/O 多路复用技术，Redis 用单个线程就能高效处理大量并发连接，避免了因等待 I/O 而造成的阻塞。

**3. 单线程模型的优势**
虽然 Redis 6.0 引入了 I/O 多线程，但其核心数据操作仍然是单线程的。这带来了两大好处：
*   **无上下文切换成本**：避免了多线程模型中频繁切换线程带来的性能开销。
*   **无锁竞争**：不需要为数据操作加锁，简化了实现并提高了执行效率。

**4. 精心设计的数据结构**
Redis 提供了多种高效的数据结构，并且会根据存储数据的特点选择最优的内部编码，以在效率和内存使用之间取得平衡。
*   **字符串 (String)**: 使用称为简单动态字符串 (SDS) 的结构，而非 C 语言原生字符串，可以 O(1) 复杂度获取字符串长度，并有效防止缓冲区溢出。
*   **哈希 (Hash)**: 当元素较少时使用 `ziplist` (压缩列表)，元素多时使用 `hashtable` (哈希表)，哈希表的插入和查找操作平均时间复杂度为 O(1)。
*   **列表 (List)**: 早期版本在数据量少时使用 `ziplist`，后来升级为 `quicklist`，它是 `ziplist` 和 `linkedlist` 的结合，在空间和时间效率上做了很好的权衡。
*   **集合 (Set)**: 当元素都是整数且数量不多时使用 `intset`，否则使用 `hashtable`。
*   **有序集合 (Sorted Set)**: 同时使用 `skiplist` (跳表) 和 `hashtable`。跳表保证了元素有序，并使得范围查询和节点查找的平均时间复杂度达到 O(logN)；哈希表则保证了 O(1) 的成员分数查找。

