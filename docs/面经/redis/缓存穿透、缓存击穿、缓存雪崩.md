
缓存穿透、缓存击穿和缓存雪崩是使用缓存系统（如Redis、Memcached）时常见的三种问题，它们都可能导致大量请求直接打到后端数据库，造成数据库压力过大甚至宕机。

缓存穿透（Cache Penetration）

1.  定义：
    缓存穿透是指客户端请求查询一个在缓存中和数据库中都不存在的数据。由于缓存中没有命中，请求会转向数据库查询，数据库中也查不到该数据，因此不会将空结果写入缓存（除非有特殊处理）。这样，每次对这类不存在的数据的请求都会直接打到数据库，如果被恶意用户利用（例如，构造大量不存在的ID进行攻击），就会给数据库带来巨大压力。

2.  解决思路：
    *   缓存空对象（Cache Null Objects / Cache Empty Results）：
        *   当数据库查询不到数据时，仍然将一个约定的“空对象”或“空标记”（例如，一个特殊字符串如 "NULL_VALUE"，或者一个具有特定字段值的对象）缓存起来，并设置一个较短的过期时间（例如几分钟）。
        *   下次再有请求查询这个不存在的数据时，缓存会命中这个空对象，直接返回，从而避免了再次查询数据库。
        *   缺点：需要缓存额外的空对象，占用一定缓存空间；如果“空”状态会改变（即原本不存在的数据后来被创建了），需要考虑如何更新这个空缓存。
    *   布隆过滤器（Bloom Filter）：
        *   布隆过滤器是一种空间效率极高的概率型数据结构，用于判断一个元素是否可能存在于一个集合中。它可以准确地判断一个元素“一定不存在”，或者“可能存在”。
        *   在数据写入数据库的同时，将数据的标识（如ID）存入布隆过滤器。
        *   当查询请求到来时，先去布隆过滤器查询该数据的标识：
            *   如果布隆过滤器判断“一定不存在”，则直接返回，不查询缓存和数据库。
            *   如果布隆过滤器判断“可能存在”，则继续查询缓存，缓存未命中再查询数据库。
        *   优点：空间效率高，可以有效拦截大量对不存在数据的查询。
        *   缺点：存在一定的误判率（false positive，即判断一个不存在的元素“可能存在”），但不会漏判（false negative，即不会把存在的元素判断为“一定不存在”）。需要维护布隆过滤器与数据库数据的同步。布隆过滤器本身不支持删除元素（有变种支持，但更复杂）。
    *   接口层参数校验与限制：
        *   对用户请求的参数进行合法性校验，例如ID格式是否正确、是否在合理范围内等，提前拦截非法请求。
        *   对恶意攻击行为进行识别和限制，如IP限流、用户行为分析等。

缓存击穿（Cache Breakdown / Hotspot Invalid）

1.  定义：
    缓存击穿是指一个热点Key（访问非常频繁的Key）在缓存中失效（过期或被剔除）的瞬间，同时有大量的并发请求访问这个Key。由于缓存未命中，这些并发请求会同时穿透到数据库去查询数据，并可能同时回写缓存，对数据库造成瞬时的高并发压力。它与缓存穿透的区别在于，击穿的数据在数据库中是存在的，只是缓存暂时失效了。

2.  解决思路：
    *   设置热点数据永不过期（或较长过期时间）：
        *   对于一些访问极其频繁且数据相对稳定的核心热点数据，可以考虑不设置过期时间，或者设置一个非常长的过期时间。数据的更新可以通过其他机制（如手动刷新、消息队列通知更新）来保证。
        *   缺点：如果数据会变化，需要有可靠的更新机制。
    *   加互斥锁（Mutex Lock / Distributed Lock）：
        *   当缓存未命中时，不是所有请求都去查数据库，而是先尝试获取一个互斥锁。
        *   只有获取到锁的那个请求（线程/进程）去查询数据库，并将结果写入缓存，然后释放锁。
        *   其他未获取到锁的请求，则进行等待（可以设置超时时间），或者直接返回一个默认值/提示信息，或者在锁释放后再去尝试读取缓存（此时数据可能已被加载）。
        *   优点：有效防止了大量并发请求同时打到数据库。
        *   缺点：引入了锁的开销和复杂性；需要选择合适的锁粒度和超时机制；如果获取锁的线程处理失败或时间过长，可能影响其他请求。
    *   异步构建缓存（后台更新）：
        *   对于热点数据，不依赖于请求来触发缓存加载。而是通过后台任务定期更新缓存，或者在数据变更时通过消息通知来主动更新缓存。
        *   这样，当缓存过期时，新的缓存数据可能已经由后台任务准备好了。

缓存雪崩（Cache Avalanche）

1.  定义：
    缓存雪崩是指在某个时间段内，缓存集中地、大规模地失效（例如，大量Key在同一时间点过期，或者缓存服务自身宕机），导致所有或大部分请求都直接涌向数据库，造成数据库压力剧增，甚至崩溃。

2.  解决思路：
    针对缓存中大量Key同时过期的情况：
    *   设置随机过期时间（Randomized Expiration Times）：
        *   在给缓存数据设置过期时间时，不要都设置成固定的时长，而是在基础过期时间上增加一个随机值（例如，过期时间 = 基础时间 + random(0, 300)秒）。这样可以使得Key的过期时间点分散开，避免集中失效。
    *   多级缓存（Multi-level Cache）：
        *   使用多级缓存架构，例如本地缓存（如Caffeine, Guava Cache）+ 分布式缓存（如Redis）。即使分布式缓存雪崩，本地缓存可能仍然能挡住一部分请求。
    *   热点数据永不过期（或双Key策略）：
        *   同缓存击穿的策略，对核心热点数据设置永不过期或通过主动更新机制保持其有效性。
        *   双Key策略：主Key设置正常过期时间，备份Key设置更长的过期时间。访问时先查主Key，未命中则查备份Key，如果备份Key命中则异步更新主Key。

    针对缓存服务宕机的情况：
    *   缓存服务高可用（High Availability for Cache Service）：
        *   使用主从复制、哨兵（Sentinel）模式或集群（Cluster）模式来部署缓存服务（如Redis Sentinel或Redis Cluster），确保当某个节点宕机时，能够自动故障转移，保证缓存服务的可用性。
    *   服务降级（Service Degradation）：
        *   当检测到缓存服务不可用或数据库压力过大时，可以通过开关或配置，暂时关闭部分非核心功能，或者返回一些默认的、静态的、或者允许一定程度过时的数据，以保证核心服务的可用性。
    *   限流（Rate Limiting）：
        *   在应用层或网关层对访问数据库的请求进行限流，当请求量超过阈值时，直接拒绝部分请求或使其排队，防止所有请求都打到数据库。
    *   熔断（Circuit Breaker）：
        *   当依赖的数据库持续出现大量错误或超时时，熔断器会打开，后续请求在一段时间内直接返回错误或默认值，不再访问数据库，给数据库恢复的时间。当熔断器进入半开状态后，会尝试放行少量请求，如果成功则关闭熔断器恢复正常。

| 问题          | 定义                                                                    | 核心原因                                 | 解决思路示例                                                                    |
| ------------- | :---------------------------------------------------------------------- | :--------------------------------------- | :------------------------------------------------------------------------------ |
| 缓存穿透      | 查询不存在的数据，缓存和DB都没有                                          | 请求的数据本身非法或不存在               | 缓存空对象、布隆过滤器、参数校验                                                  |
| 缓存击穿      | 热点Key失效瞬间，大量并发请求打到DB                                       | 单个热点Key过期，并发量大                | 设置永不过期、互斥锁/分布式锁、异步构建缓存                                       |
| 缓存雪崩      | 大量Key集中过期 或 缓存服务宕机，导致大量请求打到DB                       | 缓存大面积失效 或 缓存服务不可用         | 随机过期时间、多级缓存、缓存高可用、服务降级、限流、熔断                          |



