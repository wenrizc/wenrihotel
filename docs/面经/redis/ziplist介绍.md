
### Ziplist (压缩列表) 深度解析

Ziplist（压缩列表）是 Redis 为了极致地节约内存而设计的一种紧凑型、顺序性数据结构。 它并非像 LZF 压缩那样通过算法减少数据体积，而是通过将所有元素以及元数据存放在一块连续的内存中，并配合特殊的编码方式来减少内存开销。

在 Redis 的早期版本中，当列表（List）、哈希（Hash）或有序集合（Zset）的元素数量较少且单个元素体积较小时，就会采用 Ziplist 作为其底层实现。 尽管在新版本中，List 的底层实现已被 `quicklist` 替代，但 `quicklist` 的节点内部依然使用了 `ziplist`。

---

### Ziplist 的核心结构

Ziplist 本质上是一个字节数组，其内部结构精密地划分为多个部分，存储在一整块连续的内存上。 其布局如下：

`<zlbytes><zltail><zllen><entry-1><entry-2>...<entry-N><zlend>`

*   **`zlbytes` (4 字节):** 一个 `uint32_t` 整数，记录了整个 Ziplist 所占用的总字节数。这个字段使得在不遍历整个列表的情况下就能知道其大小，便于内存的重分配。
*   **`zltail` (4 字节):** 一个 `uint32_t` 整数，记录了从 Ziplist 起始地址到最后一个元素（entry）的偏移量。 这使得在列表尾部进行操作（如 `RPOP`）的时间复杂度可以达到 O(1)，无需从头遍历。
*   **`zllen` (2 字节):** 一个 `uint16_t` 整数，记录了 Ziplist 中元素的数量。 需要注意的是，由于它只有 16 位，最大只能表示 65535。如果元素数量超过 65534，该字段会被设置为 65535，此时若要获取真实数量，就必须遍历整个列表，时间复杂度会从 O(1) 退化到 O(N)。
*   **`entry` (不定长):** 列表中的每一个元素节点。每个 entry 的长度由其存储的内容决定。
*   **`zlend` (1 字节):** 一个固定的结束标记，其值为 `0xFF` (二进制的 `11111111`)，用于标记 Ziplist 的末端。

---

### Entry 的内部结构

Ziplist 最精妙的设计在于其元素节点（entry）的结构，它同样是变长的，由三部分组成：

`<prevlen><encoding><content>`

*   **`prevlen` (1 或 5 字节):** 记录了 **前一个 entry** 的长度。这个字段是实现从后向前遍历 Ziplist 的关键。
    *   如果前一个 entry 的长度小于 254 字节，`prevlen` 会用 1 个字节来存储这个长度值。
    *   如果前一个 entry 的长度大于或等于 254 字节，`prevlen` 会用 5 个字节来存储，其中第一个字节固定为 `0xFE` (254) 作为标记，后四个字节用于存储实际长度。
    通过当前 entry 的地址减去 `prevlen` 的值，就可以得到前一个 entry 的起始地址，从而实现反向遍历。

*   **`encoding` (不定长):** 描述了 `content` 部分的数据类型和长度。 编码方式非常灵活，可以用于存储字符串或整数。
    *   **存储字符串:** `encoding` 的前几位用于标识是字符串类型，后续位则用于表示字符串的长度。根据长度不同，`encoding` 自身可能占用 1、2 或 5 个字节。
    *   **存储整数:** `encoding` 会直接使用特定的编码来表示不同范围的整数值，例如 4 位的小整数、1 字节或 3 字节的有符号整数等，`content` 部分就不再需要了，数据直接编码在 `encoding` 字段中。

*   **`content` (不定长):** 实际存储的数据，可以是字节数组（字符串）或整数。

---

### Ziplist 的优缺点

#### 优点：
*   **内存效率高:** 连续的内存布局避免了传统链表中指针带来的额外开销，同时紧凑的编码方式也大大节省了存储空间。
*   **操作高效:** 对于两端的操作（push/pop），时间复杂度为 O(1)。

#### 缺点：
*   **不适合存储大元素:** Ziplist 被设计用于存储小整数和短字符串。如果元素过大，其内存效率优势会减弱。
*   **修改操作可能很慢:** 由于 Ziplist 存储在连续内存中，任何插入或删除操作都可能需要移动之后的所有数据，这会导致性能下降，尤其是在列表较长时。
*   **连锁更新 (Cascading Updates):** 这是 Ziplist 最严重的一个潜在问题。当在一个 Ziplist 中间插入或删除一个元素时，可能会导致其后所有元素的 `prevlen` 字段发生变化。例如，如果一个 entry 的长度从 253 字节增加到 254 字节，它的 `prevlen` 编码会从 1 字节变为 5 字节。这使得该 entry 自身的总长度增加了 4 字节，又可能导致其 **后一个** entry 的 `prevlen` 也需要更新，如此循环下去，最坏情况下会导致整个列表进行空间重分配，严重影响性能。
