
### LFU (最不经常使用) 策略简介

LFU 策略的核心思想是：**淘汰在过去一段时间内被访问次数最少的数据**。它认为，如果一个数据在最近被频繁访问，那么它在将来也很有可能被再次访问。这与 LRU (Least Recently Used - 最近最少使用) 策略不同，LRU 关注的是最后一次访问时间，而 LFU 关注的是访问的频率。

LFU 能更好地处理某些特殊场景。例如，一个数据在很久之前被访问过一次（导致其在 LRU 队列中位置靠后），但随后被大量、频繁地访问。在 LRU 策略下，它仍然可能因为最初的“最近未使用”而被淘汰。但在 LFU 策略下，由于其访问频率很高，它会被保留下来。

### Redis 中 LFU 的实现机制

在 Redis 中，一个精准的 LFU 实现需要为每个键维护一个精确的访问计数器，这会消耗大量内存且更新开销大。因此，Redis 采用了一种基于概率和时间衰减的近似 LFU 实现方式，它既高效又节省内存。

该实现主要依赖于 Redis 对象结构（`redisObject`）中的 `lru` 字段。这个 24 位的字段在 LFU 模式下被巧妙地分割为两部分：

1.  **高 16 位：Last Decrement Time (ldt)**
    *   存储的是一个以分钟为单位的时间戳，记录了计数器最后一次衰减的时间。

2.  **低 8 位：Logistic Counter (counter)**
    *   存储的是一个对数形式的访问计数器，最大值为 255。

#### 1. 访问计数器的增加

当一个键被访问时，Redis 会增加它的 `counter` 值。但这个增加不是简单的 `+1`，而是基于概率的对数增长：

*   首先，会计算一个 0 到 1 之间的随机数 `r`。
*   然后，计算出一个概率值 `p`。这个 `p` 取决于当前 `counter` 的值和一个可配置的因子 `lfu-log-factor`。当前 `counter` 越大，`p` 就越小。
*   只有当 `r < p` 时，`counter` 才会加 1。

这种机制的目的是让计数器的增长呈现对数曲线。也就是说，当访问次数从 10 增加到 100 时，`counter` 可能会显著增长；但当访问次数从 1000 万增加到 1100 万时，`counter` 的增长就会变得非常缓慢甚至停滞。这使得 8 位（0-255）的 `counter` 就能表示非常大的访问频率范围，从而节省了内存。

#### 2. 访问计数器的衰减（时间衰减）

如果一个键长时间没有被访问，那么它过去的高频率访问记录就不应永久有效。为此，Redis 引入了时间衰减机制：

*   当 Redis 需要检查一个键的 `counter` 值时（例如在进行内存淘汰扫描时），它会先检查当前时间与该键的 `ldt`（最后衰减时间）的差值。
*   这个时间差（以分钟为单位）除以一个可配置的衰-减因子 `lfu-decay-time`，得到需要衰减的量。
*   `counter` 会减去这个衰减量。如果计算出的衰减量很大，`counter` 可能会直接降为 0。

通过这种方式，一个曾经非常热门但现在不再被访问的数据，其 `counter` 值会随着时间的推移而逐渐降低，最终有机会被淘汰。

### 如何配置 LFU 策略

要在 Redis 中启用 LFU 策略，需要修改 `redis.conf` 文件或通过 `CONFIG SET` 命令设置以下参数：

1.  **设置淘汰策略 `maxmemory-policy`**
    *   `volatile-lfu`: 在设置了过期时间的键中，淘汰访问频率最低的键。
    *   `allkeys-lfu`: 在所有键中，淘汰访问频率最低的键。

2.  **调整 LFU 相关参数 (可选)**
    *   `lfu-log-factor [factor]`: 默认为 10。这个因子用于调整计数器增长的对数曲线。**值越大，计数器增长越慢**，需要更多的访问次数才能达到较高的计数值。
    *   `lfu-decay-time [minutes]`: 默认为 1。这是一个分钟数，用于控制计数器衰减的速度。**值越大，衰减越慢**，旧的访问记录影响越久。

### LFU 策略的优势

*   **更优的命中率**：相比 LRU，LFU 能够更好地识别出真正“热门”的数据，而不是那些仅仅被“最近”访问过一次的数据，从而在很多场景下能提供更高的缓存命中率。
*   **抗污染能力强**：能有效防止因一次性批量扫描或偶然访问大量冷数据而导致热数据被淘汰的“缓存污染”问题。
*   **高效实现**：Redis 采用的概率性对数计数器和时间衰减机制，在保证策略效果的同时，极大地降低了内存和计算开销。