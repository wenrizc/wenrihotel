
Redis是一个高性能的键值存储系统，它支持多种数据类型。这些对外暴露的数据类型（如String, List, Hash, Set, Sorted Set）在底层并非直接使用我们熟知的简单数据结构，而是通过一些精心设计和优化的内部数据结构来实现的，以达到空间和时间效率的最佳平衡。

以下是Redis中一些核心的底层数据结构：

1.  简单动态字符串（SDS）：
    *   用途：SDS是Redis用来表示字符串的主要方式，它被用于键（key）和值（value）中的字符串内容，也被用作各种缓冲区。
    *   结构：SDS不仅仅是一个C语言风格的字符数组（以`\0`结尾）。它包含以下几个部分：
        *   `len`：记录字符串实际已用长度（不包括末尾的`\0`）。
        *   `alloc`（或`free`）：记录分配给字符数组的总空间长度（不包括末尾的`\0`和头部长度信息）。Redis 6及以后版本中，SDS头部设计有多种类型（sdshdr5, sdshdr8, sdshdr16, sdshdr32, sdshdr64），根据字符串长度选择不同大小的头部，以节省空间。在旧版本中，`free`表示剩余可用空间。
        *   `flags`：一个字节，低3位存类型，高5位未使用（Redis 6+）。
        *   `buf[]`：实际存储字符串内容的字符数组，总是以`\0`结尾。
    *   优点：
        *   常数时间获取字符串长度（O(1)），因为有`len`字段。
        *   杜绝缓冲区溢出：在修改SDS时，会先检查空间是否足够，不够则先扩展。
        *   减少修改字符串时内存重分配次数：通过空间预分配（分配时比实际需要多一些）和惰性空间释放（缩短字符串时不立即回收多余空间）策略。
        *   二进制安全：可以存储任意二进制数据，因为`len`字段记录长度，不依赖`\0`作为结束符。
        *   兼容部分C字符串函数：因为末尾总有`\0`。

2.  链表（Linked List）：
    *   用途：链表在Redis中被广泛使用，例如列表键（List）的底层实现之一，发布与订阅、慢查询、监视器等功能的实现也用到了链表。
    *   结构：Redis的链表是双向无环链表。每个链表节点包含：
        *   `prev`：指向前一个节点的指针。
        *   `next`：指向后一个节点的指针。
        *   `value`：指向实际存储数据的指针（可以是任意类型）。
        链表本身还带有一个`list`结构体，包含头指针、尾指针、链表长度以及一些操作链表的函数指针（如复制、释放、比较节点值等）。
    *   优点：
        *   节点插入和删除效率高（O(1)），尤其是在链表两端。
        *   灵活存储不同类型数据。
    *   缺点：
        *   内存开销相对较大（每个节点都有前后指针）。
        *   按索引访问元素效率低（O(N)）。

3.  字典（Dictionary），也称哈希表（Hash Table）：
    *   用途：字典是Redis中实现哈希键（Hash）的底层数据结构，也被用来存储数据库中所有的键值对（即Redis的顶层数据库本身就是一个字典）。
    *   结构：Redis的字典实现类似于Java中的HashMap，采用拉链法解决哈希冲突。其核心是一个哈希表数组，每个数组元素（哈希桶）指向一个链表，链表中的节点存储了键值对。
        *   为了支持渐进式rehash（在字典扩展或缩容时，避免一次性移动大量数据导致阻塞），Redis的字典结构（`dict`）内部通常包含两个哈希表（`dictht ht[2]`）。平时只使用`ht[0]`，在rehash过程中，`ht[0]`和`ht[1]`会同时使用，数据会逐步从`ht[0]`迁移到`ht[1]`。
        *   哈希表的每个节点（`dictEntry`）包含：`key`（通常是SDS）、`value`（可以是任意类型，用`union v`存储）、指向下一个哈希冲突节点的`next`指针。
    *   优点：
        *   查找、插入、删除操作的平均时间复杂度为O(1)（最坏情况下为O(N)，如果哈希冲突严重）。
    *   缺点：
        *   在哈希冲突严重或rehash时性能可能下降。

4.  跳跃表（Skip List）：
    *   用途：跳跃表是Redis中实现有序集合键（Sorted Set）的底层数据结构之一（当元素较多或成员是较长字符串时）。它也被用于集群节点中管理槽（slot）信息。
    *   结构：跳跃表是一种有序的、多层链表结构。每个节点除了包含数据和指向同一层下一个节点的指针外，还可能包含指向更高层链表中对应节点的指针（跨度指针，`level[]`数组）。
        *   通过多层级的“跳跃”指针，可以实现快速查找，平均时间复杂度为O(log N)。
        *   每个节点还包含一个分值（`score`）用于排序，以及一个后退指针（`backward`）用于从表尾向前遍历。
        *   Redis的跳跃表实现中，节点可以存储成员对象（`ele`，通常是SDS）和分值。
    *   优点：
        *   支持高效的范围查询和按序遍历。
        *   插入和删除操作的平均时间复杂度为O(log N)。
        *   实现相比平衡树（如红黑树）更简单一些。
    *   缺点：
        *   内存开销比普通链表大，因为每个节点需要存储多个层级指针。

5.  整数集合（Integer Set, intset）：
    *   用途：当一个集合键（Set）只包含整数值元素，并且元素数量不多时，Redis会使用整数集合作为Set的底层实现，以节省内存。
    *   结构：整数集合是一个有序的、不重复的整数数组。它可以存储 `int16_t`, `int32_t`, 或 `int64_t` 类型的整数。
        *   根据集合中元素的最大值，整数集合会自动升级存储类型（例如，从`int16_t`升级到`int32_t`），以容纳更大的整数，同时保持有序。
    *   优点：
        *   内存效率高，因为是紧凑的数组结构，且针对整数优化。
        *   由于有序，支持二分查找，查找效率较高。
    *   缺点：
        *   只适用于存储整数。
        *   插入或删除元素可能导致后续元素的移动，在集合很大时开销可能增加（但Redis通常在元素过多时会转换为字典实现）。

6.  压缩列表（Compressed List, ziplist）：
    *   用途：当列表键（List）或哈希键（Hash）包含的元素数量较少，并且每个元素（或键值对的键和值）都是小整数值或短字符串时，Redis会使用压缩列表作为其底层实现，以极大地节省内存。有序集合在元素少且小的情况下也可能用到ziplist。
    *   结构：压缩列表是一块连续的内存区域，它将所有元素紧凑地存储在一起，而不是像普通链表那样每个节点都有单独的指针开销。
        *   ziplist内部由一系列特殊编码的节点（entry）组成。每个节点可以存储字节数组（字符串）或整数。
        *   为了节省空间，节点根据其存储内容的长度或大小采用不同的编码方式。
        *   ziplist包含头部信息（总字节数、尾部偏移量、节点数量）和一系列entry，以及一个列表末端标记。
    *   优点：
        *   内存占用极小，非常节省空间。
    *   缺点：
        *   查找元素需要逐个遍历，时间复杂度为O(N)。
        *   插入或删除元素可能引发连锁更新（Cascade Update）：如果在一个较小的节点后插入或删除一个较大的节点（或反之），导致后续节点的偏移量需要改变，可能会级联地更新多个后续节点的长度编码，最坏情况下时间复杂度是O(N^2)，但实际发生概率不高且影响通常有限。
        *   不适合存储大量元素或大字符串。当元素过多或过大时，Redis会自动将ziplist转换为更合适的结构（如链表或字典）。

7.  快速列表（Quicklist）（Redis 3.2 引入）：
    *   用途：是列表键（List）新的底层实现，结合了链表和压缩列表的优点。
    *   结构：一个快速列表是一个双向链表，但链表中的每个节点不再是一个单独的元素，而是一个压缩列表（ziplist）。
        *   这样，对于少量元素的List，它可能只有一个ziplist节点。对于大量元素的List，它是由多个ziplist节点组成的链表。
        *   可以配置每个ziplist的最大大小（字节数或元素个数）。
    *   优点：
        *   在空间效率（得益于ziplist）和时间效率（两端操作快，中间操作通过遍历ziplist节点链表）之间取得了很好的平衡。
        *   避免了纯链表过多的指针开销和纯ziplist在大量数据时连锁更新的风险。

8.  Streams（流）（Redis 5.0 引入）的底层结构：
    *   Streams是一种新的数据类型，类似于日志文件，可以追加消息，并支持消费组。
    *   底层主要使用基数树（Radix Tree，也称PATRICIA trie或crit-bit tree的变种）来存储消息（按ID索引），以及使用类似于前面提到的链表和字典结构来管理消费者组和待处理消息等元数据。

Redis会根据存储的数据类型、大小和数量，动态地选择最合适的底层数据结构（对象编码，Object Encoding），以在时间和空间效率上达到最佳。例如，一个哈希键在元素少且都是短字符串时可能用ziplist编码，当元素增多或变大时会自动转换为字典编码。这种机制称为对象的类型特定编码。

