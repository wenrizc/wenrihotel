
## 一、JVM 内存结构概览

JVM 内存分为线程私有和线程共享两类区域：
- **线程私有**：程序计数器、Java 虚拟机栈、本地方法栈。
- **线程共享**：堆、方法区（JDK 1.8 后方法区的实现为元空间）。

**JDK 1.8 vs JDK 1.7**：
- 最大的变化是**元空间（Metaspace）取代了永久代（Permanent Generation）**。
- 元空间使用本地内存（Native Memory），不再受 JVM 堆内存限制，减少了 `OutOfMemoryError: PermGen` 的风险。

---

## 二、内存区域详解

### 1. 程序计数器（PC 寄存器）
- **定义**：记录当前线程执行的字节码指令地址，占用较小内存空间。若执行本地方法，则值为 `Undefined`。
- **作用**：
  - 字节码解释器通过改变程序计数器实现代码流程控制（如循环、跳转）。
  - 多线程场景下记录线程执行位置，支持线程切换后恢复执行。
- **特点**：
  - 线程私有，每线程独有一份。
  - 生命周期随线程创建而生，随线程结束而销毁。
  - **唯一不会抛出 `OutOfMemoryError` 的内存区域**。
  - 内存占用小，运行效率高。

### 2. Java 虚拟机栈（Java 栈）
- **定义**：描述 Java 方法执行的内存模型，线程私有。
- **栈帧**：每个方法执行时创建一块栈帧，包含：
  - **局部变量表**：存储方法参数、局部变量（基本数据类型、对象引用等）。
  - **操作数栈**：用于计算的临时数据存储。
  - **动态链接**：将符号引用转为直接引用。
  - **方法出口**：记录方法返回地址。
- **运行机制**：
  - 方法执行时，栈帧压入栈顶，成为活动栈帧；方法结束时，栈帧出栈。
  - 栈顶的栈帧对应当前执行的方法，PC 寄存器指向其地址。
- **局部变量表**：
  - 以 **Slot** 为单位，32 位类型占 1 个 Slot，64 位（long、double）占 2 个 Slot。
  - 编译期确定大小，运行时不可变。
  - **Slot 复用**：过期局部变量的 Slot 可被新变量复用，节省空间。
  - **性能调优**：局部变量表是垃圾回收的根节点，直接或间接引用的对象不会被回收。
- **操作数栈**：
  - 采用栈顶缓存技术，将栈顶数据缓存到 CPU 寄存器，提升执行效率。
  - 数据访问仅通过入栈、出栈操作，32 位数据占 1 个栈单位，64 位占 2 个。
- **方法调用与绑定**：
  - **静态链接**：编译期确定目标方法，运行时不变。
  - **动态链接**：运行期根据实际类型确定方法引用。
  - **绑定类型**：
    - **早期绑定**：编译期确定（如静态方法、final 方法）。
    - **晚期绑定**：运行期确定（如虚方法）。
  - **虚方法表**：类加载时创建，存储方法实际入口，提升动态调用的效率。
- **异常**：
  - **`StackOverflowError`**：栈深度超过最大限制。
  - **`OutOfMemoryError`**：动态扩展时内存不足。
- **特点**：
  - 运行速度快，仅次于程序计数器。
  - 数据线程私有，无需同步锁。
  - 出现 `StackOverflowError` 时，内存可能仍有剩余。

### 3. 本地方法栈（C 栈）
- **定义**：为 Native 方法（通常由 C/C++ 实现）提供内存空间，功能类似 Java 虚拟机栈。
- **运行机制**：
  - 执行 Native 方法时，创建栈帧，存储局部变量表、操作数栈等。
  - 方法结束时，栈帧出栈，释放内存。
- **异常**：可能抛出 `StackOverflowError` 和 `OutOfMemoryError`。
- **特点**：
  - 线程私有，随线程分配。
  - 部分 JVM 可能不提供本地方法栈，取决于实现。

### 4. 堆
- **定义**：存储几乎所有对象实例，是 JVM 最大的内存区域。
- **特点**：
  - **线程共享**：所有线程访问同一堆。
  - 在 JVM 启动时创建。
  - **垃圾回收的主要场所**。
  - 可动态扩展，内存不足时抛出 `OutOfMemoryError`。
  - 物理内存不要求连续，逻辑上视为连续。
- **分代管理**：
  - **新生代**：
    - 包含 **Eden 区** 和两个 **Survivor 区（S0、S1）**，默认比例 8:1:1。
    - 新对象优先分配在 Eden 区，大对象直接进入老年代。
  - **老年代**：存储生命周期长的对象，默认占堆的 2/3（新生代占 1/3，参数 `-XX:NewRatio=2`）。
- **对象分配与垃圾回收**：
  - **分配流程**：
    1. 新对象分配到 Eden 区。
    2. Eden 满时触发 **Minor GC**，清理无用对象，将存活对象移至 S0。
    3. 下次 Minor GC 时，Eden 和 S0 的存活对象移至 S1，S0 清空。
    4. S0 和 S1 角色互换（空闲区为 To 区）。
    5. 对象经历多次 GC 后（默认 15 次，参数 `-XX:MaxTenuringThreshold`）移至老年代。
  - **垃圾回收**：
    - **Minor GC**：清理新生代，触发于 Eden 满时，清理 Eden 和一个 Survivor 区。
    - **Major GC / Full GC**：清理整个堆，触发条件包括：
      - 显式调用 `System.gc()`。
      - 老年代或方法区空间不足。
      - Minor GC 后老年代空间不足。
    - Full GC 的 **STW（Stop The World）** 时间长，应尽量避免。
- **逃逸分析**：
  - 通过分析对象引用范围，优化内存分配：
    - **同步省略**：单线程访问的对象无需同步。
    - **栈上分配**：未逃逸的对象分配在栈上，减少堆压力。
    - **标量替换**：将对象分解为基本类型，存储在寄存器或栈上。
  - 参数：`-XX:+DoEscapeAnalysis`（JDK 1.7 起默认开启）。
- **TLAB（Thread Local Allocation Buffer）**：
  - Eden 区的线程私有分配区域，避免多线程分配冲突。
  - 默认开启（参数 `-XX:+UseTLAB`），分配失败时通过加锁保证原子性。
  - 提升对象分配效率，适合小对象分配。

### 5. 方法区
- **定义**：堆的逻辑部分，存储：
  - 已加载的类信息。
  - 常量（运行时常量池）。
  - 静态变量。
  - 即时编译器（JIT）编译后的代码。
- **实现变化**：
  - **JDK 1.7 及之前**：方法区以永久代（PermGen）形式实现，位于堆中。
  - **JDK 1.8 及之后**：以元空间（Metaspace）实现，使用本地内存。
- **特点**：
  - 线程共享，JVM 中只有一个方法区。
  - 信息长期存在，回收效率低，主要回收常量池和卸载的类型。
  - 允许固定大小或动态扩展，可不实现垃圾回收。
- **运行时常量池**：
  - 存储 `.class` 文件中的常量，运行时可动态添加（如 `String.intern()`）。
  - 是方法区的一部分，管理字符串常量等。

### 6. 直接内存（堆外内存）
- **定义**：JVM 之外的内存，通过 `DirectByteBuffer` 操作。
- **用途**：用于 NIO，基于通道和缓冲区的 IO 操作，避免数据在堆和本地内存间的复制。
- **特点**：
  - 不受 JVM 堆大小限制，但内存不足时抛出 `OutOfMemoryError`。
  - 申请空间性能开销较高，IO 操作效率优于堆内存。
  - 配置时需考虑直接内存，避免总内存超限。

---

## 三、四种引用类型
JVM 中的引用类型影响垃圾回收行为：
1. **强引用**：`new` 创建的对象，永不回收，除非引用置为 `null`。
2. **软引用**：内存充足时不回收，内存不足时回收，适合缓存场景。
3. **弱引用**：GC 时无条件回收，适合临时性对象。
4. **虚引用**：不影响对象生命周期，随时可能被回收，常用于跟踪对象回收状态。

---

## 四、常见异常
- **栈相关**：
  - `StackOverflowError`：栈深度超限。
  - `OutOfMemoryError`：栈内存不足。
- **堆相关**：
  - `OutOfMemoryError`：堆内存不足。
- **运行时异常**：
  - `NullPointerException`：空指针。
  - `ClassCastException`：类型转换错误。
  - `IndexOutOfBoundsException`：数组越界。
  - `ArithmeticException`：算术错误（如除零）。

---

## 五、调优与扩展
- **堆内存调优**：
  - 参数：`-Xms`（初始堆大小）、`-Xmx`（最大堆大小）、`-XX:NewRatio`（新生代与老年代比例）。
  - 调整 Survivor 区比例（`-XX:SurvivorRatio`）和晋升阈值（`-XX:MaxTenuringThreshold`）。
- **垃圾回收优化**：
  - 减少 Full GC，使用 CMS 或 G1 收集器。
  - 开启逃逸分析（`-XX:+DoEscapeAnalysis`）和 TLAB（`-XX:+UseTLAB`）。
- **元空间管理**：
  - 参数：`-XX:MetaspaceSize`、`-XX:MaxMetaspaceSize`。
  - 监控类加载和常量池使用，避免元空间溢出。
- **直接内存监控**：
  - 配置 `-XX:MaxDirectMemorySize`，避免忽略直接内存导致的 OOM。

---

## 六、总结
JVM 内存结构通过分区域管理线程私有和共享数据，优化程序执行效率和内存使用。**程序计数器**确保线程切换的正确性，**Java 虚拟机栈**和**本地方法栈**支持方法执行，**堆**存储对象实例并进行垃圾回收，**方法区**（元空间）管理类信息和常量。**直接内存**扩展了 JVM 的 IO 能力。通过合理的配置和调优（如逃逸分析、TLAB、引用类型），可显著提升程序性能并减少内存异常。
