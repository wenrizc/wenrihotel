
## 一、 类与类加载器的关系：类的唯一性

在 Java 虚拟机 (JVM) 中，一个类的**唯一身份**是由**加载它的类加载器**和这个**类本身**共同确立的。这意味着：

1.  **独立命名空间**：每个类加载器都拥有一个独立的类名称空间。
2.  **判断类“相等”的前提**：
    *   比较两个类是否“相等”（包括使用 `equals()` 方法、`isInstance()` 方法判断，以及 `instanceof` 关键字检查），**前提条件**是这两个类必须由**同一个类加载器**加载。
    *   如果两个类来源于同一个 `.class` 文件，甚至被同一个 JVM 加载，但只要加载它们的类加载器不同，那么这两个类在 JVM 中就被视为**完全不同、不相等**的两个类。

**核心要点**：类的身份 = 类本身 + 加载它的 ClassLoader。

## 二、 类加载器的种类

Java 系统中主要提供了三种类加载器：

1.  **启动类加载器 (Bootstrap ClassLoader)**：
    *   **职责**：加载 Java 核心类库，通常位于 `<JAVA_HOME>\lib` 目录下，且能被虚拟机识别（按文件名识别，如 `rt.jar`）。
    *   **特点**：通常由 C++ 实现，是 JVM 自身的一部分。Java 程序**无法直接引用**到启动类加载器。它的父加载器是 `null` (在 Java 层面)。
2.  **扩展类加载器 (Extension ClassLoader)**：
    *   **职责**：加载位于 `<JAVA_HOME>\lib\ext` 目录下的扩展类库。
    *   **特点**：由 Java 语言实现 (`sun.misc.Launcher$ExtClassLoader`)。开发者可以**直接使用**。其父加载器是启动类加载器。
3.  **应用程序类加载器 (Application ClassLoader)**：
    *   **职责**：加载用户**类路径 (Classpath)** 上指定的类库。它是程序中**默认**的类加载器。
    *   **特点**：由 Java 语言实现 (`sun.misc.Launcher$AppClassLoader`)。开发者可以**直接使用**，通过 `ClassLoader.getSystemClassLoader()` 获取。其父加载器是扩展类加载器。

**此外**：开发者可以通过继承 `java.lang.ClassLoader` 类来自定义自己的类加载器，以实现特定的类加载逻辑（如网络加载、加密解密加载、热部署等）。

## 三、 双亲委派模型 (Parents Delegation Model)

**定义**：描述类加载器之间**层次关系**的一种机制。它规定了类加载的**工作流程**。

**核心思想**：除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。（这种父子关系通常通过**组合**而非继承实现）。

**工作过程**（体现在 `ClassLoader` 的 `loadClass` 方法中）：

1.  **委派**：当一个类加载器收到加载类的请求时，它**首先不会自己尝试加载**。
2.  **向上传递**：它会将这个请求**委派给父类加载器**去执行。
3.  **递归委派**：每一层级的类加载器都会重复这个过程，请求最终会传递到最顶层的**启动类加载器**。
4.  **尝试加载**：只有当**父加载器反馈无法完成加载请求**（在其搜索范围内找不到所需的类）时，**子加载器才会尝试自己去加载**这个类。

**为什么需要双亲委派模型？**

*   **保证类的唯一性和一致性**：
    *   确保 Java 核心类库（如 `java.lang.Object`）无论被哪个类加载器加载，最终都会被委派给顶层的**启动类加载器**加载。
    *   这保证了像 `Object` 这样的基础类在 JVM 中只有**唯一一个版本**，避免了混乱和类型不兼容问题。
*   **安全机制**：
    *   防止核心 API 库被用户自定义的同名类所覆盖或篡改。
    *   例如，即使用户自己写一个 `java.lang.String` 类并放在 Classpath 中，由于双亲委派模型，加载请求最终会到达启动类加载器，它会加载系统自带的 `String` 类，而不是用户编写的那个，从而保护了 Java 核心库的安全。

**总结**：双亲委派模型是 Java 类加载器架构的核心，它通过明确的委派机制，保证了 Java 平台基础类型的统一性和安全性。