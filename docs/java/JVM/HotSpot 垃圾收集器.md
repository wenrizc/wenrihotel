
## 一、新生代垃圾收集器

新生代垃圾收集器主要处理生命周期较短的对象，采用“复制”算法以高效回收内存。以下是三种常见的新生代垃圾收集器：

### 1. Serial 垃圾收集器（单线程）

- **特点**：
    - 单线程执行垃圾回收，回收期间会“Stop The World”（暂停所有用户线程）。
    - 适合客户端应用（如桌面应用），内存需求较小，堆内存不大，回收时间短，用户感知不明显。
    - 避免线程切换开销，简单高效。
- **适用场景**：
    - 单核 CPU 或内存较小的客户端应用。
- **优缺点**：
    - **优点**：实现简单，单线程避免上下文切换，效率高。
    - **缺点**：在多核 CPU 环境下无法充分利用硬件资源，停顿时间可能较长。

### 2. ParNew 垃圾收集器（多线程）

- **特点**：
    - Serial 的多线程版本，多条 GC 线程并行回收，仍需“Stop The World”。
    - 追求低停顿时间，适合交互式应用。
    - 在多核 CPU 环境下性能优于 Serial，但在单核环境下因线程切换开销可能不如 Serial。
- **适用场景**：
    - 多核 CPU 环境下的交互式应用（如 Web 应用）。
- **优缺点**：
    - **优点**：多线程并行回收，适合多核 CPU，停顿时间较 Serial 短。
    - **缺点**：线程切换增加开销，单核环境下性能可能不如 Serial。

### 3. Parallel Scavenge 垃圾收集器（多线程）

- **特点**：
    - 多线程新生代收集器，追求高吞吐量（吞吐量 = 用户代码运行时间 / (用户代码运行时间 + 垃圾收集时间)）。
    - 适合无交互的后台计算任务（如批处理、科学计算）。
    - 提供自适应调节策略，通过参数控制垃圾收集行为：
        - `-XX:GCTimeRatio`：设置垃圾收集时间占总 CPU 时间的百分比。
        - `-XX:MaxGCPauseMillis`：设置最大停顿时间。
        - `-XX:+UseAdaptiveSizePolicy`：开启自适应策略，自动调整新生代大小、Eden 和 Survivor 比例、晋升老年代的年龄。
- **适用场景**：
    - 高吞吐量需求的后台任务。
- **优缺点**：
    - **优点**：高吞吐量，适合后台任务；自适应策略简化配置。
    - **缺点**：停顿时间可能较长，不适合对响应时间敏感的应用。

---

## 二、老年代垃圾收集器

老年代垃圾收集器处理生命周期较长的对象，通常采用“标记-整理”或“标记-清除”算法。以下是三种常见的老年代垃圾收集器：

### 1. Serial Old 垃圾收集器（单线程）

- **特点**：
    - Serial 的老年代版本，单线程执行，采用“标记-整理”算法。
    - 适合客户端应用，回收期间需“Stop The World”。
- **适用场景**：
    - 单核 CPU 或内存较小的客户端应用。
- **优缺点**：
    - **优点**：实现简单，单线程高效。
    - **缺点**：停顿时间长，多核 CPU 利用率低。

### 2. Parallel Old 垃圾收集器（多线程）

- **特点**：
    - Parallel Scavenge 的老年代版本，多线程执行，采用“标记-整理”算法。
    - 追求高吞吐量，与 Parallel Scavenge 配合使用，适合后台计算任务。
- **适用场景**：
    - 高吞吐量需求的服务器应用。
- **优缺点**：
    - **优点**：高吞吐量，适合多核 CPU。
    - **缺点**：停顿时间可能较长。

### 3. CMS 垃圾收集器（Concurrent Mark Sweep）

- **特点**：
    - 追求最短停顿时间，适合交互式应用（如 Web 服务）。
    - 采用“标记-清除”算法，GC 线程与用户线程并发执行，减少用户感知的卡顿。
    - 工作步骤：
        1. **初始标记**：Stop The World，单线程标记 GC Roots 直接关联对象，速度快。
        2. **并发标记**：多线程与用户线程并发，标记所有可达对象，耗时长。
        3. **重新标记**：Stop The World，多线程修正并发标记期间的漏标对象。
        4. **并发清除**：单线程与用户线程并发，清除标记的废弃对象，耗时长。
- **适用场景**：
    - 对响应时间敏感的服务器应用。
- **优缺点**：
    - **优点**：低停顿时间，用户体验好。
    - **缺点**：
        - 吞吐量低，GC 线程与用户线程竞争 CPU 资源。
        - 无法处理浮动垃圾（并发标记期间产生的新垃圾）。
        - “标记-清除”算法导致内存碎片，需通过参数 `-XX:+UseCMSCompactAtFullCollection` 和 `-XX:CMSFullGCsBeforeCompaction` 触发内存整理。
        - 频繁 Full GC 可能影响性能。

---

## 三、G1 通用垃圾收集器

G1（Garbage First）是一款面向服务端应用的垃圾收集器，兼顾低停顿时间和高吞吐量，适用于大内存、多核 CPU 环境。G1 将堆内存划分为多个独立 Region，不区分新生代和老年代，通过优先回收垃圾最多的 Region 提高效率。

### 1. 特点

- **内存划分**：堆被划分为多个 Region，每个 Region 可以是 Eden、Survivor 或老年代。
- **算法**：
    - 整体采用“标记-整理”算法，避免碎片。
    - 局部（Region 间）采用“复制”算法，高效回收。
- **Remembered Set**：每个 Region 维护一个 Remembered Set，记录本 Region 对象引用的外部对象所在区域，避免全堆扫描。
- **回收策略**：优先回收垃圾最多的 Region，获得最大回收效率。

### 2. 工作步骤

1. **初始标记**：Stop The World，单线程标记 GC Roots 直接关联对象。
2. **并发标记**：单线程与用户线程并发，分析对象可达性，耗时长。
3. **最终标记**：Stop The World，多线程修正并发标记期间的漏标对象。
4. **筛选回收**：Stop The World，多线程根据回收价值排序 Region，回收垃圾最多的区域。

### 3. 解答问题：对象引用跨 Region 的可达性分析

- **问题**：一个对象引用的对象可能位于不同 Region，垃圾回收时是否需要扫描整个堆？
- **答案**：不需要。G1 通过 **Remembered Set** 记录每个 Region 中对象引用的外部对象所在区域。可达性分析时，只需将 GC Roots 和 Remembered Set 结合，无需遍历全堆，大幅提高效率。

### 4. 适用场景

- 大内存、多核 CPU 的服务端应用。
- 要求低停顿时间和高吞吐量的场景。

### 5. 优缺点

- **优点**：
    - 兼顾低停顿和高吞吐量。
    - 无内存碎片，整体“标记-整理”+局部“复制”算法。
    - 灵活的 Region 划分，优先回收高价值区域。
- **缺点**：
    - Remembered Set 维护增加内存和计算开销。
    - 复杂性较高，配置和调优成本高。

---

## 四、总结与对比

|收集器|类型|算法|特点|适用场景|
|---|---|---|---|---|
|Serial|新生代|复制|单线程，简单高效|客户端应用，单核 CPU|
|ParNew|新生代|复制|多线程，低停顿|交互式应用，多核 CPU|
|Parallel Scavenge|新生代|复制|多线程，高吞吐量，自适应策略|后台计算任务，多核 CPU|
|Serial Old|老年代|标记-整理|单线程，简单高效|客户端应用，单核 CPU|
|Parallel Old|老年代|标记-整理|多线程，高吞吐量|后台计算任务，多核 CPU|
|CMS|老年代|标记-清除|并发执行，低停顿，易产生碎片|交互式应用，响应时间敏感|
|G1|新生代+老年代|标记-整理+复制|Region 划分，兼顾低停顿和高吞吐量|大内存服务端应用，多核 CPU|

---

## 五、拓展与延伸

1. **垃圾收集器的选择**：
    
    - **低停顿时间**：优先选择 CMS 或 G1，适合 Web 应用、实时系统。
    - **高吞吐量**：选择 Parallel Scavenge + Parallel Old，适合批处理、科学计算。
    - **小内存客户端**：Serial + Serial Old 简单高效。
    - **大内存服务端**：G1 是未来趋势，逐渐取代 CMS。
2. **调优建议**：
    
    - 使用 `-XX:+PrintGCDetails` 和 `-Xlog:gc*` 分析 GC 日志，了解停顿时间和吞吐量。
    - 根据业务需求调整 `-XX:MaxGCPauseMillis`、`-XX:GCTimeRatio` 等参数。
    - 对于 CMS，合理设置 `-XX:CMSFullGCsBeforeCompaction` 减少碎片。
    - G1 需关注 Region 大小（`-XX:G1HeapRegionSize`）和混合 GC 频率。
3. **未来趋势**：
    
    - G1 已成为 Java 9+ 的默认垃圾收集器，逐步取代 CMS。
    - 更新的 Shenandoah 和 ZGC 收集器进一步优化了低停顿性能，适合超大规模应用。

---

## 六、参考资料

- 《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》（周志明）
- Oracle 官方文档：Java HotSpot VM Garbage Collection
- OpenJDK 源码及相关技术博客