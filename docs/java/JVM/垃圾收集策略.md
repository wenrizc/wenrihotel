
## 一、垃圾收集概述

垃圾收集（Garbage Collection，GC）是 Java 虚拟机（JVM）内存管理的重要组成部分，负责自动回收不再使用的内存空间。垃圾收集器主要关注 **Java 堆** 和 **方法区**，因为这两部分内存的分配和回收是动态的，而程序计数器、虚拟机栈、本地方法栈因其生命周期与线程绑定，具有确定性回收机制。

### 内存区域特性

- **程序计数器、虚拟机栈、本地方法栈**：随线程创建和销毁，栈帧随方法调用和结束而入栈出栈，内存回收确定性强，无需过多考虑。
- **Java 堆和方法区**：运行时才能确定创建的对象，内存分配和回收动态，需垃圾收集器管理。

## 二、判定对象是否存活

垃圾收集的核心是识别哪些对象是“无效对象”（即不被任何对象或变量引用），需要回收。以下是两种主要判定方法：

### 1. 引用计数法

- **原理**：在对象头维护一个计数器，对象被引用时计数器 +1，引用失效时 -1。计数器为 0 时，对象视为无效。
- **优点**：实现简单，判定效率高。
- **缺点**：
    - 无法解决**循环引用**问题。例如，对象 A 和 B 互相引用，导致计数器不为 0，无法回收。
    - 多线程环境下，计数器变更需昂贵的同步操作，性能较低。
- **现状**：主流 JVM 未采用引用计数法，早期编程语言常用。

### 2. 可达性分析法

- **原理**：从一组称为 **GC Roots** 的根对象开始，追踪所有直接或间接引用的对象，标记为存活；未被标记的对象为无效。
- **GC Roots** 包括：
    - 虚拟机栈（栈帧本地变量表）中引用的对象。
    - 本地方法栈中引用的对象。
    - 方法区中常量引用的对象。
    - 方法区中类静态属性引用的对象。
- **优点**：有效解决循环引用问题，GC Roots 不包括堆中对象引用。
- **应用**：主流 JVM 采用此方法。

## 三、引用的种类

引用类型影响对象的可达性状态和垃圾回收行为。JDK 1.2 后，Java 将引用分为四种：

### 1. 强引用（Strong Reference）

- **定义**：如 `Object obj = new Object()`，只要强引用存在，对象不会被回收。
- **问题**：若强引用被错误保留（如赋值给 static 变量），可能导致内存泄漏。
- **场景**：常见于核心数据结构。

### 2. 软引用（Soft Reference）

- **定义**：内存充足时保留对象，内存不足时（抛出 OutOfMemoryError 前）回收。
- **用途**：实现内存敏感的缓存，确保缓存使用不耗尽内存。
- **实现**：通过 `SoftReference` 类。

### 3. 弱引用（Weak Reference）

- **定义**：无论内存是否充足，垃圾回收时都会回收只被弱引用关联的对象。
- **强度**：比软引用更弱。
- **实现**：通过 `WeakReference` 类。
- **用途**：适合临时性对象存储。

### 4. 虚引用（Phantom Reference）

- **定义**：最弱的引用，不影响对象生存时间，仅用于对象 finalize 后执行清理机制。
- **用途**：Post-Mortem 清理，如资源释放。
- **实现**：通过 `PhantomReference` 类。

## 四、回收堆中无效对象

可达性分析中不可达的对象并非立即回收，可能经历以下过程：

### 1. 判定 finalize() 是否执行

- **条件**：
    - 如果对象未覆盖 `finalize()` 方法，或 `finalize()` 已执行过，则无需执行，直接回收。
    - 否则，对象放入 **F-Queue** 队列，由低优先级线程执行 `finalize()`。
- **注意**：JVM 不保证所有 `finalize()` 方法执行完成，若耗时过长，对象可能被直接清除。

### 2. 对象重生或死亡

- **重生**：在 `finalize()` 中将对象重新关联到引用（如 `this` 赋值给某变量），对象可“自救”。
- **死亡**：未自救的对象被回收。
- **限制**：`finalize()` 仅执行一次，后续回收不再调用。

## 五、回收方法区内存

方法区存储类信息、常量、静态变量，垃圾回收效率较低，主要清除：

### 1. 废弃常量

- **条件**：常量池中的常量（如字符串 "bingo"）无任何引用。
- **过程**：清理出常量池。

### 2. 无用的类

- **判定条件**：
    - 该类的所有对象已被清除。
    - 加载该类的 ClassLoader 已回收。
    - 该类的 `java.lang.Class` 对象无引用，无法通过反射访问。
- **过程**：清除方法区中的类信息及堆中的 `java.lang.Class` 对象。

## 六、垃圾收集算法

垃圾收集算法负责回收无效对象、无用类和废弃常量。常见算法包括：

### 1. 标记-清除算法

- **过程**：
    - **标记**：遍历 GC Roots，标记存活对象。
    - **清除**：遍历堆，清除未标记对象，并清除标记。
- **缺点**：
    - 效率低：标记和清除过程耗时。
    - 内存碎片：产生不连续内存，影响大对象分配。
- **适用场景**：对象存活率较高时。

### 2. 复制算法（新生代）

- **过程**：
    - 将内存分为两块（或 Eden、From Survivor、To Survivor，比例 8:1:1），每次使用一块。
    - 垃圾回收时，将存活对象复制到另一块，清除原块。
- **优点**：无内存碎片。
- **缺点**：
    - 内存利用率低（浪费 50% 或 10%）。
    - 若存活对象过多，复制效率下降。
- **改进**：Eden 和 Survivor 空间分配，剩余对象通过**分配担保**进入老年代。
- **适用场景**：新生代，对象存活率低。

### 3. 标记-整理算法（老年代）

- **过程**：
    - **标记**：同标记-清除算法，标记存活对象。
    - **整理**：将存活对象按内存地址顺序移动，回收末端内存。
- **优点**：无内存碎片，适合存活对象多的场景。
- **缺点**：整理过程增加开销。
- **适用场景**：老年代，对象存活率高。

### 4. 分代收集算法

- **原理**：根据对象存活周期，将堆分为新生代和老年代，采用不同算法：
    - **新生代**：复制算法，适合短生命周期对象。
    - **老年代**：标记-清除或标记-整理算法，适合长生命周期对象。
- **优点**：结合各算法优势，提高效率。
- **应用**：现代 JVM 普遍采用。

## 七、分配担保机制

- **场景**：新生代 Minor GC 后，存活对象超过 Survivor 空间容量。
- **过程**：
    - 存活对象通过分配担保进入老年代。
    - 新对象继续分配到 Eden 区。
- **作用**：保证新生代内存分配的稳定性。

## 八、总结与拓展

### 总结

- 垃圾收集是 JVM 内存管理的核心，重点关注堆和方法区的动态内存。
- **对象存活判定**：引用计数法（简单但有循环引用问题）、可达性分析法（主流）。
- **引用类型**：强引用、软引用、弱引用、虚引用，影响对象回收时机。
- **回收过程**：涉及 finalize() 自救、方法区常量和无用类清理。
- **垃圾收集算法**：
    - 标记-清除：简单但有碎片。
    - 复制：高效但浪费空间，适合新生代。
    - 标记-整理：无碎片，适合老年代。
    - 分代收集：结合优势，广泛应用。

### 拓展

- **垃圾收集优化**：
    - **并行 GC**：多线程执行垃圾收集，提高吞吐量。
    - **并发 GC**：如 CMS、G1，允许 GC 与应用线程并发，降低停顿时间。
    - **ZGC、Shenandoah**：低延迟垃圾收集器，适合大型应用。
- **实际应用**：
    - 内存敏感缓存使用软引用或弱引用。
    - 避免强引用导致的内存泄漏（如 static 变量）。
    - 监控 GC 性能，调整堆大小和分代比例。
- **未来趋势**：
    - 更智能的 GC 算法，结合机器学习预测对象生命周期。
    - 跨语言内存管理（如 GraalVM），提升多语言环境性能。