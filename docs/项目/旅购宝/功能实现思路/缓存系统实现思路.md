
## 1. 统一缓存管理

项目通过 [UnifiedCache] 组件实现了统一的缓存管理框架，集中处理各类业务缓存需求，主要包括以下设计思路：

### 核心架构

采用了分层架构设计，将缓存操作的各个环节进行解耦：

- **接口层**：提供简洁统一的缓存访问接口，隐藏底层实现复杂度
- **管理层**：统一协调多级缓存、布隆过滤器、分布式锁等组件
- **存储层**：支持本地缓存和分布式缓存两级存储

### 统一缓存接口

设计了一套通用的缓存访问接口，所有业务模块通过统一入口访问缓存：

- [queryWithHeatAware]：支持热点识别的缓存查询
- [queryWithBloomFilter]：结合布隆过滤器的查询方法
- [setWithRandomExpire]：带随机过期时间的缓存写入
- [setWithLogicalExpire]：使用逻辑过期机制的缓存写入
- [deleteCache]：缓存删除操作

这种统一接口设计实现了缓存逻辑与业务逻辑的分离，降低了业务代码对缓存实现的感知，方便后续缓存策略的调整。

### 缓存同步机制

利用 Rabbitmq 的消息队列功能，实现了分布式环境下的缓存一致性：

- 当一个服务实例更新缓存时，会发布一条缓存变更消息
- 其他服务实例订阅这些消息并更新自己的本地缓存
- 支持 "更新" 和 "删除" 两种操作类型

## 2. 多级缓存策略

系统设计了本地缓存和分布式缓存两级结构，结合各自优势提供更高效的缓存服务：

### 本地缓存（一级缓存）

使用 Caffeine 实现高效的本地内存缓存：

- **容量限制**：设置最大缓存条目数（10000）避免内存溢出
- **过期机制**：本地缓存项默认60秒过期
- **自动加载**：缓存项过期或不存在时自动从二级缓存加载
- **统计功能**：记录缓存命中率、加载时间等性能指标

本地缓存访问路径短、速度快，能够显著减轻 Redis 的访问压力。

### 分布式缓存（二级缓存）

使用 Redis 实现分布式缓存，解决集群环境下的数据共享问题：

- **数据格式**：使用 JSON 序列化缓存对象，保持可读性和通用性
- **过期策略**：针对不同业务场景采用不同的过期策略
- **原子操作**：利用 Redis 事务确保复杂缓存操作的原子性

### 缓存访问流程

完整的缓存访问流程包括以下步骤：

1. **查询本地缓存**：首先尝试从本地 Caffeine 缓存获取数据
2. **布隆过滤器校验**：使用布隆过滤器快速判断 key 是否可能存在
3. **查询分布式缓存**：从 Redis 中查询数据
4. **缓存未命中**：查询数据库并更新缓存
5. **返回结果**：将结果返回给调用方并在本地缓存中保存一份

## 3. 布隆过滤器

系统使用布隆过滤器有效防止缓存穿透问题，实现思路如下：

### 设计原理

布隆过滤器用于快速判断一个元素是否可能存在于集合中：

- **业务隔离**：为不同业务类型创建独立的布隆过滤器
- **容错机制**：记录误判情况，支持动态调整过滤器参数
- **持久化**：使用 Redisson 实现的分布式布隆过滤器，确保集群环境下的一致性

### 关键操作

- **添加元素**：缓存写入时同步添加到布隆过滤器
- **查询判断**：查询缓存前先检查布隆过滤器
- **批量重建**：系统启动时预加载所有业务数据到布隆过滤器
- **删除记录**：使用额外集合记录已删除的项，解决布隆过滤器不支持删除的缺陷

### 动态适应

系统会定期统计布隆过滤器的误判率，并在必要时进行重建：

// 记录统计指标

queries: 布隆过滤器查询总次数

positives: 布隆过滤器返回可能存在的次数

falsePositives: 误判次数（布隆过滤器说存在但实际不存在）

falsePositiveRate: 误判率 = falsePositives / queries

## 4. 缓存击穿保护

对于热点数据，使用逻辑过期机制防止缓存击穿：

### 热点识别

系统通过多种方式识别热点数据：

- **访问频率统计**：记录和分析数据访问频率
- **业务标记**：根据业务特性预设热点数据
- **定时评估**：定期评估数据热度变化

### 逻辑过期实现

热点数据使用逻辑过期机制，具体实现包括：

1. **数据结构设计**：使用 `RedisData` 封装实际数据和逻辑过期时间
    
    public class RedisData {
    
        private Object data;        // 实际数据
    
        private LocalDateTime expireTime;  // 逻辑过期时间
    
    }
    
2. **双重检查机制**：获取缓存时检查逻辑过期时间
    
    // 检查是否过期
    
    if (redisData.getExpireTime().isAfter(LocalDateTime.now())) {
    
        // 未过期，直接返回
    
        return data;
    
    }
    
3. **异步更新策略**：当发现数据已过期时，返回旧数据的同时异步更新
    
    // 获取互斥锁，防止多线程重复更新
    
    String lockKey = LOCK_PREFIX + key;
    
    boolean isLockSuccess = distributedLock.tryLock(lockKey, 10);
    
    if (isLockSuccess) {
    
        // 成功获取锁，启动异步更新
    
        CACHE_REBUILD_EXECUTOR.submit(() -> {
    
            try {
    
                // 重建缓存的逻辑
    
                rebuildCache(key, timeout, timeUnit);
    
            } finally {
    
                // 释放锁
    
                distributedLock.unlock(lockKey);
    
            }
    
        });
    
    }
    
    // 不管是否获取到锁，都返回旧数据
    
    return data;
    

## 5. 缓存雪崩保护

系统采取多种措施防止缓存雪崩：

### 随机过期时间

设置带随机偏移的过期时间，避免大量缓存同时失效。这种设计使相同时间设置的缓存项在 ±20% 的时间范围内随机过期，有效分散了过期时间。

### 多级缓存备份

即使 Redis 缓存出现问题，系统仍可通过本地缓存提供部分服务：

1. **本地缓存独立过期**：本地缓存与 Redis 缓存使用不同的过期策略
2. **降级机制**：Redis 不可用时，可临时增加本地缓存的有效期

### 系统负载保护

结合 Sentinel 实现系统过载保护：
当系统负载过高时，会触发限流和熔断机制，防止系统崩溃。

## 6. 缓存维护任务

系统实现了定时任务自动维护缓存健康。

### 缓存清理任务

定期清理过期的逻辑键，避免存储空间浪费。

### 热点数据预热

系统启动或定期执行热点数据预热。

预热过程会根据业务类型加载不同的热点数据到缓存中，确保系统启动后立即就能高效响应热点查询。

总之，这套缓存系统通过统一缓存管理、多级缓存策略、布隆过滤器、逻辑过期机制和随机过期时间等技术手段，构建了高性能、高可靠性的缓存体系，有效解决了缓存穿透、缓存击穿和缓存雪崩等经典缓存难题。