
## 整体架构设计

项目采用了基于Redis的分布式登录认证机制，采用token替代传统session的方式实现用户身份验证。这种设计适合分布式系统和前后端分离的应用场景。

## 核心组件

### 1. 登录拦截器
实现了HandlerInterceptor接口，在请求处理前检查用户是否已登录。通过判断ThreadLocal中是否存在用户信息来确定登录状态，未登录则拦截请求并返回401未授权状态码。

### 2. 用户信息持有器(UserHolder)
使用ThreadLocal保存当前请求线程的用户信息，实现了线程隔离，避免并发请求间用户信息相互干扰。提供了设置、获取和清除用户信息的静态方法。

### 3. Redis会话存储
使用Redis存储用户会话信息，采用哈希结构(Hash)保存用户数据，以特定前缀加token作为key。通过设置过期时间实现会话的自动失效机制。

## 认证流程

1. **用户登录阶段**
   - 用户提交账号密码
   - 系统验证身份信息
   - 验证通过后，生成随机UUID作为token
   - 将用户信息对象转换为Map结构并存储到Redis中
   - 设置会话过期时间
   - 将token返回给客户端(通常通过Cookie或响应头)

2. **请求鉴权阶段**
   - 前置拦截器从请求中提取token
   - 使用token作为key从Redis查询用户信息
   - 如果找到有效信息，将用户数据反序列化并存入ThreadLocal
   - 刷新Redis中token的过期时间，实现"滑动过期"
   - 请求继续传递给下一个拦截器

3. **访问控制阶段**
   - 登录拦截器从ThreadLocal获取用户信息
   - 如果存在用户信息则允许访问
   - 否则拦截请求并返回401状态码

4. **请求完成阶段**
   - 请求处理完毕后，清理ThreadLocal中的用户信息，防止内存泄漏

## 特点与优势

1. **分布式兼容性**：采用Redis集中存储会话信息，解决了分布式系统下session共享问题
2. **无状态设计**：基于token的认证机制，使服务端无需保存状态，有利于系统扩展
3. **性能优化**：使用Redis哈希结构存储用户数据，相比字符串序列化更节省内存
4. **安全性**：会话有明确的过期机制，减少未授权访问风险
5. **用户体验**：实现了"滑动过期"机制，活跃用户无需频繁重新登录
6. **易维护性**：认证逻辑集中在拦截器中，业务代码无需关注认证细节

这种认证方案摒弃了传统session机制，更适合现代分布式微服务架构，同时通过ThreadLocal实现了高效的请求上下文传递。