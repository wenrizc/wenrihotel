
在 InnoDB 存储引擎中，几种 `count` 用法的性能排行如下：

`count(*)` ≈ `count(1)` > `count(主键字段)` > `count(非索引字段)`

- `count(*)` 和 `count(1)` 的性能基本没有差异。
- 效率最差的是 `count(非索引字段)`。
- `count(字段)` 的效率优劣取决于该字段是否建立了索引。

####  count() 函数的定义

- `count()` 是一个聚合函数。
- 它的作用是统计符合查询条件的记录中，其参数值不为 NULL 的记录数量。
- `select count(name) from t_order;` 会统计 `t_order` 表中 `name` 字段不为 NULL 的行数。
- `select count(1) from t_order;` 会统计 `t_order` 表中表达式 `1` 不为 NULL 的行数。因为 `1` 永远不为 NULL，所以这条语句实际上是在统计表中的总行数。

#### 不同 count 用法的执行过程 (基于 InnoDB)

MySQL Server 层会维护一个名为 `count` 的变量，循环从存储引擎层（InnoDB）读取记录，然后根据 `count` 函数的参数判断是否累加计数。

1.  `count(主键字段)` 的执行过程
    -   Server 层向 InnoDB 请求记录。
    -   InnoDB 遍历索引来读取记录。
    -   优化器会优先选择二级索引进行遍历，因为二级索引树通常比聚簇索引（主键索引）树更小，IO成本更低。
    -   如果不存在二级索引，则会遍历聚簇索引。
    -   InnoDB 将记录返回给 Server 层。
    -   Server 层获取记录后，会读取其中的主键ID，判断其不为 NULL，然后将 `count` 变量加 1。

2.  `count(1)` 的执行过程
    -   与 `count(主键字段)` 类似，InnoDB 会优先遍历最小的二级索引。
    -   关键区别：InnoDB 将记录返回给 Server 层后，Server 层不需要读取记录中的任何字段值。它知道参数 `1` 不可能为 NULL，因此每接收到一条记录，就直接将 `count` 变量加 1。
    -   这个过程比 `count(主键字段)` 少了一步“解析记录并获取字段值”的操作，因此效率稍高。

3.  `count(*)` 的执行过程
    -   `count(*)` 中的 `*` 并不代表读取所有字段。
    -   MySQL 在处理 `count(*)` 时，会将其转化为 `count(0)` 来对待。
    -   因此，`count(*)` 的执行过程与 `count(1)` 基本完全相同。
    -   MySQL 官方手册明确指出：InnoDB 以相同的方式处理 `SELECT COUNT(*)` 和 `SELECT COUNT(1)`，两者没有性能差异。
    -   优化器同样会选择 `key_len` 最小的二级索引进行扫描以提升效率。

4.  `count(字段)` 的执行过程
    -   如果该字段没有建立索引，这将是效率最低的方式。
    -   InnoDB 会进行全表扫描（遍历聚簇索引）。
    -   对于每一条记录，都需要读取并返回给 Server 层。
    -   Server 层获取记录后，需要读取指定字段的值，并判断其是否为 NULL，如果不为 NULL 才将 `count` 变量加 1。
    -   如果想用此方法统计，建议为该字段建立一个二级索引。

#### 为什么 InnoDB 需要遍历计数

1.  MyISAM 的计数方式
    -   MyISAM 存储引擎在表的元数据（meta information）中直接存储了 `row_count` 值。
    -   对于不带 `WHERE` 条件的 `count(*)` 查询，MyISAM 可以直接返回这个 `row_count` 值，时间复杂度是 O(1)，速度极快。
    -   这是因为 MyISAM 使用表级锁，可以保证 `row_count` 值的准确性。

2.  InnoDB 的计数方式
    -   InnoDB 支持事务和多版本并发控制（MVCC）。
    -   由于 MVCC 的存在，在同一时间点，不同的事务查询同一张表，看到的记录行数可能是不同的。
    -   例如，一个事务删除了数据但未提交，另一个事务在此时进行 `count(*)`，就不应该包含被删除的行。
    -   因为无法确定一个对所有事务都可见的、准确的行数，所以 InnoDB 不能像 MyISAM 那样维护一个简单的全局计数器。
    -   因此，InnoDB 必须通过扫描当前事务可见的记录来进行精确计数。

3.  带 WHERE 条件的情况
    -   当查询带有 `WHERE` 条件时，MyISAM 和 InnoDB 的行为是一样的，都需要扫描表来统计符合条件的记录数。

#### 如何优化大表的 count(*)

对于千万级别的大表，即使有二级索引，`count(*)` 的执行时间也可能很长（文中例子为5秒）。

1.  方法一：获取近似值
    -   如果业务场景不需要绝对精确的计数值（如搜索引擎显示结果数量），可以使用估算值。
    -   可以通过 `EXPLAIN SELECT * FROM table;` 命令查看。输出结果中的 `rows` 字段就是 MySQL 对表行数的估算值。
    -   也可以使用 `SHOW TABLE STATUS;` 命令，它也会提供一个估算的行数。
    -   这些命令执行效率非常高。

2.  方法二：使用额外的计数表
    -   如果需要精确计数值，可以创建一张专门的计数表。
    -   这张表可以只有一个字段，用来存储目标表的总行数。
    -   在对原表进行 `INSERT` 操作时，同时对计数表的计数值加 1。
    -   在对原表进行 `DELETE` 操作时，同时对计数表的计数值减 1。
    -   这样，获取总行数只需要查询这张计数表即可，速度极快。
    -   缺点是增加了业务代码的复杂性，需要在写操作时额外维护这张计数表。