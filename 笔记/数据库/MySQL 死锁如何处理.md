
#### 死锁案例复现

1. 背景
    
    - 业务场景：为保证订单不重复，在新增订单前使用 `select ... for update` 检查订单号是否存在，若不存在则插入。
        
    - 环境：InnoDB引擎，可重复读（RR）隔离级别。
        
    - 表结构：`t_order` 表，`id` 为主键，`order_no` 为普通二级索引。
        
2. 死锁过程
    
    - 事务A：执行 `select * from t_order where order_no = 1007 for update;`
        
    - 事务B：执行 `select * from t_order where order_no = 1008 for update;`
        
    - 事务A：执行 `insert into t_order (order_no) values (1007);` -> 被阻塞
        
    - 事务B：执行 `insert into t_order (order_no) values (1008);` -> 被阻塞，发生死锁
        
    - 两个事务都在等待对方释放锁，形成循环等待。
        

#### 死锁原因分析

1. 加锁分析
    
    - `select ... for update` 在可重复读隔离级别下，会使用 Next-Key Lock（记录锁 + 间隙锁）来防止幻读。
        
    - 事务A查询 `order_no = 1007` (一个不存在的值)，根据加锁规则，会在 `order_no` 这个二级索引上加一个 Next-Key Lock，锁定的范围是 `(1006, +∞]`。
        
    - 同理，事务B查询 `order_no = 1008`，也会在二级索引上加一个范围为 `(1006, +∞]` 的 Next-Key Lock。
        
2. 锁的兼容性与冲突
    
    - 间隙锁（Gap Lock）的特性：间隙锁之间是互相兼容的。一个事务持有的间隙锁不会阻止另一个事务在同一个间隙上获得间隙锁。其唯一目的是阻止其他事务向间隙中插入记录。
        
    - 案例中的兼容性：事务A和B的 `select ... for update` 语句都成功执行，是因为它们加的 Next-Key Lock `(1006, +∞]` 的间隙部分是兼容的，而记录锁部分由于 `+∞` 是一个伪记录，并不产生冲突。因此两个事务可以同时持有这个锁。
        
    - 插入意向锁（Insert Intention Lock）：
        
        - 它是一种特殊的间隙锁，只在并发插入时使用。它锁的是一个“点”，而不是一个“区间”。
            
        - 一个事务想要在某个间隙内插入数据，必须先获得插入意向锁。
            
        - 关键冲突点：插入意向锁与间隙锁（或包含间隙锁的Next-Key Lock）是不兼容的。
            
3. 死锁形成
    
    - 事务A执行 `insert` 时，需要在 `(1006, +∞]` 的间隙内插入数据，它试图获取插入意向锁，但这个间隙已被事务B的Next-Key Lock锁定，所以事务A等待事务B释放锁。
        
    - 事务B执行 `insert` 时，也需要在 `(1006, +∞]` 的间隙内插入数据，它也试图获取插入意向锁，但这个间隙已被事务A的Next-Key Lock锁定，所以事务B等待事务A释放锁。
        
    - 两者互相等待，形成循环，导致死锁。
        

#### Insert 语句的加锁机制

1. 隐式锁
    
    - 正常情况下，`insert` 语句不加锁，而是通过记录中的 `trx_id` 隐藏列形成一个“隐式锁”，这是一种延迟加锁的优化，可以提高性能。
        
    - 只有在可能发生冲突时，隐式锁才会转换为显式锁（真实的锁结构）。
        
2. 隐式锁转换为显式锁的场景
    
    场景一：记录之间加有间隙锁
    
    - 当一个事务 `insert` 的位置被另一个事务的间隙锁覆盖时，`insert` 操作会生成一个状态为 `WAITING` 的插入意向锁，并被阻塞。
        
    
    场景二：遇到唯一键冲突
    
    - 当 `insert` 的记录与已有记录发生唯一键冲突时，插入失败，并且会给已存在的记录加上一个S型（共享）锁。
        
    - 主键索引冲突：给已存在的聚簇索引记录添加 S 型的 Record Lock（记录锁）。
        
    - 唯一二级索引冲突：
        
        - 单事务冲突：给已存在的二级索引记录添加 S 型的 Next-Key Lock。
            
        - 并发插入相同记录：
            
            - 事务A先 `insert` 成功，记录被隐式锁保护。
                
            - 事务B后 `insert` 相同记录，遇到唯一键冲突。
                
            - 此时，事务A的隐式锁会立刻转换为一个 X 型（排他）的 Record Lock。
                
            - 事务B因冲突，需要获取一个 S 型的 Next-Key Lock，但该请求与事务A持有的X锁冲突，因此事务B被阻塞。
                

#### 如何避免死锁

1. 数据库层面的策略（被动解除）
    
    - 设置锁等待超时：通过 `innodb_lock_wait_timeout` 参数（默认50秒）设置超时时间。当一个事务等待锁超过该时间后，会自动回滚，从而释放锁。
        
    - 开启主动死锁检测：通过 `innodb_deadlock_detect` 参数（默认开启）启用。InnoDB会主动检测是否存在循环等待，一旦发现，会选择一个事务（通常是undo量最小的）进行回滚，打破死锁。
        
2. 业务层面的策略（主动预防）
    
    - 在本次案例中，为了保证订单号的唯一性，最佳实践是直接给 `order_no` 字段设置唯一索引（UNIQUE INDEX）。
        
    - 这样，当插入重复订单时，数据库会直接抛出唯一性约束异常，应用层只需捕获并处理这个异常即可，无需使用 `select ... for update`，从根源上避免了因此产生的死锁。