
#### 第一步：连接器

连接器的主要职责是与客户端建立连接、获取权限和管理连接。

1.  建立连接：客户端通过TCP协议与MySQL服务器进行三次握手。
2.  权限验证：连接器会验证客户端提供的用户名和密码。如果验证失败，会返回"Access denied for user"错误。
3.  获取权限：验证成功后，连接器会查询并缓存该用户的权限。该连接后续的所有操作都将基于这个缓存的权限进行判断，即使管理员中途修改了权限，对已存在的连接也不生效。

连接管理：
*   查看连接：`show processlist`命令可以查看当前所有连接。Command列为Sleep表示这是一个空闲连接。
*   空闲连接：由`wait_timeout`参数控制最大空闲时长，默认为8小时。超时后连接器会自动断开连接。客户端再次请求时会收到连接丢失的错误。
*   最大连接数：由`max_connections`参数控制，超过这个数值的连接请求会被拒绝。
*   长连接与短连接：推荐使用长连接以减少连接和断开的开销。但长连接可能导致内存占用过高，因为MySQL为每个连接分配的内存资源只有在连接断开时才释放。
*   解决长连接内存问题：
    *   定期断开长连接。
    *   在客户端调用`mysql_reset_connection()`函数重置连接，这可以在不重新建立连接和验证权限的情况下释放内存，将连接恢复到初始状态。

#### 第二步：查询缓存

连接建立后，MySQL会先检查查询缓存。

1.  工作机制：查询缓存以Key-Value形式存储，Key是SQL查询语句，Value是查询结果。如果命中缓存，则直接返回结果。
2.  失效机制：只要表中的数据有任何更新，与该表相关的查询缓存就会被全部清空。
3.  对于更新频繁的表，缓存命中率低，维护开销大，显得很鸡肋，MySQL 8.0版本已经移除了查询缓存功能。

#### 第三步：解析SQL

如果缓存未命中，SQL语句会进入解析器阶段。

1.  词法分析：将SQL语句字符串拆分成一个个独立的词（Token），如`select`、`product`、`where`等。
2.  语法分析：根据词法分析的结果，依据MySQL的语法规则检查SQL语句是否合法，并生成一个“语法树”。如果语法有误，例如关键字写错，会在这个阶段报错。

#### 第四步：执行SQL

SQL的执行过程分为三个阶段：预处理、优化和执行。

1.  预处理器
    *   功能：
        *   检查SQL语句中涉及的表和字段是否存在。如果表或字段不存在，会在此阶段报错。
        *   将`select *`中的`*`扩展为该表的所有列名。

2.  优化器
    *   功能：根据解析树生成多种执行计划，并基于成本选择一个最优的执行计划。
    *   决策内容：例如，当一个表有多个索引可用时，优化器会决定使用哪个索引效率最高。或者决定是否使用覆盖索引等。
    *   可以使用`explain`命令查看SQL语句的执行计划，其中`key`字段显示了优化器决定使用的索引。

3.  执行器
    *   功能：根据优化器生成的执行计划，调用存储引擎的接口来执行SQL语句。
    *   交互方式：执行器与存储引擎以记录（row）为单位进行交互。
    *   执行流程示例：
        *   主键索引查询 (`where id = 1`)：执行器调用存储引擎的接口，并告知要查询`id=1`的记录。存储引擎通过主键索引（B+树）快速定位到该记录并返回给执行器。执行器判断条件满足后，将记录返回给客户端，然后结束查询。
        *   全表扫描 (`where name = 'iphone'` 且name列无索引)：执行器调用存储引擎的接口，让其读取表的第一条记录。存储引擎返回记录后，执行器判断记录是否满足`name = 'iphone'`的条件。如果满足，则发送给客户端。这个过程会循环进行，直到存储引擎读取完表中的所有记录。
        *   索引下推 (Index Condition Pushdown, ICP)：这是MySQL 5.6引入的优化。
            *   场景：`select * from t_user where age > 20 and reward = 100000;` 假设有 `(age, reward)` 联合索引。
            *   无索引下推时：存储引擎通过索引找到`age > 20`的记录，然后进行回表（根据主键值去查找完整的行数据），将完整数据返回给Server层的执行器。执行器再判断`reward`是否等于100000。这个过程包含了很多不必要的“回表”操作。
            *   有索引下推时：存储引擎通过索引找到`age > 20`的记录后，不会立即回表，而是先在存储引擎内部判断该索引记录中的`reward`字段是否满足条件。只有满足条件的记录，存储引擎才会去执行“回表”操作并返回给执行器。这大大减少了回表次数和Server层与存储引擎层之间的数据传输量，提升了效率。执行计划的`Extra`字段显示`Using index condition`即表示使用了索引下推。

一条查询语句的完整旅程是：

1.  客户端通过连接器连接到MySQL服务器，完成身份验证和权限获取。
2.  SQL语句交给解析器进行词法和语法分析，生成语法树。
3.  预处理器检查表和字段是否存在，并扩展`*`。
4.  优化器根据语法树生成并选择最优的执行计划。
5.  执行器根据执行计划，调用存储引擎的接口获取数据，并将结果返回给客户端。