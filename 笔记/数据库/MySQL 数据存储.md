
#### 数据文件位置

1.  数据目录：通过 `SHOW VARIABLES LIKE 'datadir';` 命令可以查到 MySQL 的数据存储目录，通常在 `/var/lib/mysql/`。
2.  数据库目录：每个数据库都会在此目录下创建一个同名文件夹。
3.  表文件：在对应的数据库文件夹内，每张表通常有以下文件：
    *   `db.opt`: 存储数据库的默认字符集和校验规则。
    *   `表名.frm`: 存储表的结构定义（元数据）。
    *   `表名.ibd`: 存储表的数据和索引。自 MySQL 5.6.6 版本起，`innodb_file_per_table` 默认为开启，每张表的数据会独立存储在 `.ibd` 文件中，这个文件也叫独占表空间。

#### 表空间结构
InnoDB 的逻辑存储层次从大到小依次是：表空间、段 (segment)、区 (extent)、页 (page)、行 (row)。

*   行 (row)：表中的记录是按行存放的，行的具体存储结构称为行格式。
*   页 (page)：是 InnoDB 磁盘管理的最小单位，也是数据读写的单位。默认大小为 16KB。这样做可以避免一次 I/O 只读一行数据导致的效率低下问题。表中的行记录就存放在数据页中。
*   区 (extent)：为了提高 I/O 效率，避免随机 I/O，InnoDB 引入了区的概念。一个区由 64 个物理上连续的页组成，大小为 1MB。当数据量大时，按区分配空间可以使得相邻的页在物理上也相邻，从而利用顺序 I/O 提升性能。
*   段 (segment)：由多个区组成，用于管理不同类型的数据。常见的段有：
    *   数据段：存放 B+ 树的叶子节点。
    *   索引段：存放 B+ 树的非叶子节点。
    *   回滚段：存放回滚数据，用于事务和 MVCC。

### InnoDB 行格式
行格式 (row_format) 决定了一行记录的具体存储结构。InnoDB 主要有四种行格式：

*   Redundant: MySQL 5.0 之前的旧格式，已很少使用。
*   Compact: MySQL 5.1 开始默认使用的紧凑型行格式，旨在节省空间。
*   Dynamic: MySQL 5.7 开始的默认行格式，基于 Compact 改进。
*   Compressed: 与 Dynamic 类似，但会对行数据进行压缩。

#### COMPACT 行格式详解
一条记录在 Compact 格式下分为两大部分：“记录的额外信息”和“记录的真实数据”。

##### 1. 记录的额外信息
这部分包含三个组成部分：

*   变长字段长度列表：
    *   用途：用于存储 `VARCHAR`, `TEXT`, `BLOB` 等变长字段实际占用的字节数。如果表中没有变长字段，则没有此列表。
    *   存储方式：按列的顺序“逆序”存放每个变长字段的长度。例如，一行的两个变长字段长度分别为 1 字节和 3 字节，列表中会存为 `03 01`。逆序存放是为了让字段的真实数据与其长度信息尽可能地处在同一个 CPU Cache Line 中，提高缓存命中率。
    *   长度表示：如果变长字段允许的最大字节数小于等于 255，用 1 字节表示长度；如果大于 255，则用 2 字节表示。

*   NULL 值列表：
    *   用途：用于标记哪些允许为 NULL 的列当前值就是 NULL，以节省空间，NULL 值本身不占用“记录的真实数据”部分的空间。如果所有字段都定义为 `NOT NULL`，则没有此列表。
    *   存储方式：每个允许为 NULL 的列对应一个二进制位 (bit)。同样按照列的顺序“逆序”排列。`1` 代表该列为 NULL，`0` 代表不为 NULL。
    *   空间占用：必须是整数个字节。如果列数不足 8 的整数倍，会在高位补 0。例如，有 4 个可为 NULL 的列，该列表仍然占用 1 字节。如果超过 8 个，则会占用 2 字节，以此类推。

*   记录头信息：
    *   固定占用 5 字节，包含一些关键信息。
    *   `delete_mask`: 标记记录是否被删除（逻辑删除）。
    *   `next_record`: 指向下一条记录的指针，形成单向链表。
    *   `record_type`: 记录的类型（0: 普通记录, 1: B+树非叶子节点, 2: 最小记录, 3: 最大记录）。

##### 2. 记录的真实数据
这部分除了包含我们定义的各个列的数据外，还有 InnoDB 自动添加的三个隐藏列：

*   `row_id` (6字节，可选)：如果表没有定义主键也没有非空的唯一索引，InnoDB 会自动创建一个 `row_id` 作为隐藏主键。
*   `trx_id` (6字节，必需)：记录最后修改这条记录的事务 ID。
*   `roll_pointer` (7字节，必需)：指向这条记录上一个版本的位置，用于 MVCC。

#### MySQL 的 NULL 值会占用空间吗？
NULL 值不直接存储在记录的真实数据部分。它的存在是通过“NULL 值列表”中的一个比特位来表示的。如果一个表有允许为 NULL 的字段，那么即使某一行没有任何 NULL 值，也会存在至少 1 字节的 NULL 值列表。因此，将字段都设置为 `NOT NULL` 可以节省这部分空间。

#### MySQL 怎么知道 varchar(n) 实际占用数据的大小？
通过“记录的额外信息”中的“变长字段长度列表”来得知。这个列表存储了每个变长字段实际占用的字节数。

#### varchar(n) 中 n 最大取值为多少？
MySQL 规定，除大对象类型（`TEXT`, `BLOB`）外，一行所有列（不含隐藏列和记录头）的总长度不能超过 65535 字节。这个总长度包含了“变长字段长度列表”和“NULL 值列表”所占用的空间。

*   计算方法：`所有列定义长度之和 + 变长字段长度列表占用字节 + NULL值列表占用字节 <= 65535`
*   单字段示例：假设一张表只有一个字段 `name VARCHAR(n) NULL`，字符集为 `ascii`。
    *   `n` 的理论最大值需要从 65535 中减去元数据开销。
    *   变长字段长度列表：由于 `n` 会很大（超过255），需要 2 字节来存储长度。
    *   NULL 值列表：因为字段允许为 NULL，需要 1 字节。
    *   所以，n 的最大值 = `65535 - 2 - 1 = 65532`。
*   多字段情况：需要保证所有字段的长度加上所有元数据开销的总和不超过 65535 字节。
*   字符集影响：如果字符集是 `utf8mb4`，一个字符最多占 4 字节，那么 `n` 的最大值还需要除以 4。

#### 行溢出后，MySQL 是怎么处理的？
当一行记录的实际大小超过了一个数据页（16KB）的存储能力时，就会发生行溢出。InnoDB 会将超出的数据存储在特殊的“溢出页”中。

*   Compact 行格式的处理：
    *   它会在记录的真实数据部分存储该列的一部分数据（通常是前 768 字节）。
    *   然后用一个 20 字节的指针指向存储剩余数据的溢出页。

*   Dynamic 和 Compressed 行格式的处理：
    *   这两种格式采用“完全行溢出”策略。
    *   在记录的真实数据部分不存储任何数据，只存储一个 20 字节的指针，直接指向存储所有数据的溢出页。这种方式对于大字段更加高效。