
#### 什么是索引？

索引是一种帮助存储引擎快速获取数据的数据结构，可以将其理解为书籍的目录。它通过牺牲一定的存储空间来换取查询时间的缩短。MySQL的索引和数据都由存储引擎层管理，如InnoDB。

##### 索引的分类

1.  按数据结构分类
    *   MySQL中最常用的是B+Tree索引。不同的存储引擎支持的索引类型不同，例如InnoDB和MyISAM都支持B+Tree索引，而Memory引擎还支持Hash索引。
    *   InnoDB存储引擎在建表时，会按以下顺序选择列作为聚簇索引：
        1.  若有主键，则使用主键。
        2.  若无主键，则选择第一个不包含NULL值的唯一列。
        3.  若以上两者都没有，则自动生成一个隐式的自增id列作为聚簇索引。
    *   B+Tree结构特点：
        *   是一种多叉树。
        *   只有叶子节点才存储数据（对于主键索引是整行数据，对于二级索引是主键值），非叶子节点只存储索引键。
        *   节点内的数据按键值顺序存放。
        *   叶子节点之间通过一个双向链表连接，便于范围查询。
    *   主键索引查询过程：通过B+Tree从根节点开始，逐层向下比较查找，直到在叶子节点找到对应的数据。例如，查询千万级的数据表通常只需要3-4次磁盘I/O。
    *   二级索引查询过程：
        *   二级索引的B+Tree叶子节点存放的是主键值。
        *   当使用二级索引查询时，首先在二级索引树中找到对应的主键值。
        *   然后拿着主键值再去主键索引树（聚簇索引）中查找完整的行数据，这个过程称为“回表”。
        *   如果查询的字段恰好在二级索引中都存在，则无需回表，这个过程称为“覆盖索引”。

2.  按物理存储分类
    *   聚簇索引（主键索引）：叶子节点存储了完整的用户记录。一个表只有一个聚簇索引。
    *   二级索引（辅助索引）：叶子节点存储的是主键值。

3.  按字段特性分类
    *   主键索引：建立在主键字段上的索引，值唯一且不能为空。
    *   唯一索引：建立在UNIQUE字段上的索引，值必须唯一，但允许有空值。一个表可有多个。
    *   普通索引：建立在普通字段上，没有唯一性等限制。
    *   前缀索引：对字符类型字段的前几个字符建立索引，目的是减少索引大小，提高效率。

4.  按字段个数分类
    *   单列索引：建立在单个列上的索引。
    *   联合索引（复合索引）：建立在多个列上的索引。
        *   遵循“最左匹配原则”：查询必须从联合索引的第一个字段开始，按顺序使用，索引才会生效。例如，对于(a, b, c)的联合索引，`where a=1` 或 `where a=1 and b=2` 会使用索引，但 `where b=2` 则不会。这是因为索引是先按a排序，再按b排序，最后按c排序，单独的b或c是无序的。
        *   联合索引与范围查询：最左匹配原则会一直向右匹配，直到遇到范围查询（如 >, <）就停止。但对于 >=, <=, BETWEEN, 和 like '前缀%' 这类范围查询，后续的字段仍可能继续使用索引。
        *   索引下推 (Index Condition Pushdown)：MySQL 5.6引入的优化。对于联合索引，即使部分条件不能用于缩小扫描范围，也可以在存储引擎层面（遍历索引时）直接用这些条件过滤数据，减少回表次数。在EXPLAIN的Extra列中显示为 `Using index condition`。

##### 什么时候需要 / 不需要创建索引？

*   需要创建索引的情况：
    1.  有唯一性约束的字段。
    2.  经常作为WHERE查询条件的字段。
    3.  经常用于GROUP BY和ORDER BY的字段，可利用索引的有序性避免额外排序。

*   不需要创建索引的情况：
    1.  在查询条件中用不到的字段。
    2.  字段中存在大量重复数据（区分度低），如性别。查询优化器可能会放弃索引而选择全表扫描。
    3.  数据量很小的表。
    4.  经常被更新的字段，因为维护索引有开销。

##### 有什么优化索引的方法？

1.  前缀索引优化：对大字符串字段使用前缀索引可以减小索引体积。但其局限性在于不能用于ORDER BY，也不能实现覆盖索引。

2.  覆盖索引优化：让查询的所有字段都包含在索引中，从而避免回表，减少I/O操作。

3.  主键索引最好是自增的：
    *   自增主键保证了新插入的数据是顺序追加的，避免了数据的移动和“页分裂”。
    *   非自增主键（如UUID）会导致随机插入，引发页分裂，造成性能下降和空间浪费。
    *   主键字段长度应尽可能小，因为二级索引会存储主键值，小主键能让二级索引更小。

4.  索引最好设置为 NOT NULL：
    *   NULL值会使优化器在索引选择时变得更复杂。
    *   NULL值本身也需要额外的存储空间。

5.  防止索引失效：
    *   索引失效的常见场景：
        *   使用左模糊或左右模糊匹配，如 `like '%xx'`。
        *   对索引列进行计算、使用函数或进行类型转换。
        *   联合索引未遵循最左匹配原则。
        *   OR条件中，如果OR后面的条件列不是索引列，则整个索引会失效。


##### 为什么 MySQL 采用 B+ 树作为索引？

*   对比 B 树：B+树的非叶子节点不存储数据，只存索引，因此单个节点可以存放更多索引键，使得树的高度更低。B+树的叶子节点有双向链表，非常适合范围查询。
*   对比二叉树：B+树是多叉的，树的高度远低于二叉树，意味着查找数据时磁盘I/O次数更少。
*   对比 Hash：Hash索引在等值查询时效率极高（O(1)），但不支持范围查询。B+树则适用场景更广。

