

事务（Transaction）用于保证一系列数据库操作的不可分割性，即要么全部成功执行，要么全部失败回滚。例如，在转账场景中，从一个账户扣款和向另一个账户存款这两个操作必须捆绑在一个事务中，以防止因服务器掉电等意外导致数据不一致（如钱被扣除但未到账）。

#### 事务的特性 (ACID)

事务由MySQL的引擎层实现，常用的InnoDB引擎支持事务，而MyISAM引擎则不支持。事务必须遵守四个特性：

1.  原子性 (Atomicity): 事务中的所有操作是一个整体，要么全部完成，要么全部不完成。如果发生错误，会回滚到事务开始前的状态。
2.  一致性 (Consistency): 事务执行前后，数据库从一个一致性状态转移到另一个一致性状态。数据的完整性约束没有被破坏。
3.  隔离性 (Isolation): 多个并发事务同时操作相同数据时，它们之间不会相互干扰，每个事务都像在独立的空间中运行。
4.  持久性 (Durability): 事务一旦提交，其对数据库的修改就是永久性的，即使系统发生故障也不会丢失。

InnoDB引擎通过以下技术保证这些特性：
*   持久性：通过 redo log (重做日志) 保证。
*   原子性：通过 undo log (回滚日志) 保证。
*   隔离性：通过 MVCC (多版本并发控制) 或锁机制保证。
*   一致性：通过原子性、持久性和隔离性共同保证。

#### 并行事务会引发什么问题？

多个事务并发执行时，可能引发以下问题：

1.  脏读 (Dirty Read)
    *   定义：一个事务读取到了另一个尚未提交事务修改过的数据。
    *   后果：如果未提交的事务最终回滚，那么读取到的数据就是无效的“脏”数据。

2.  不可重复读 (Non-repeatable Read)
    *   定义：在一个事务内部，多次读取同一行数据，但得到的结果却不一致。
    *   原因：在两次读取之间，有另一个事务修改了该行数据并提交了。

3.  幻读 (Phantom Read)
    *   定义：在一个事务内部，多次执行相同的范围查询，但返回的记录数量不一致。
    *   原因：在两次查询之间，有另一个事务插入或删除了符合查询条件的数据并提交了。

这三个问题的严重性从高到低依次是：脏读 > 不可重复读 > 幻读。

#### 事务的隔离级别有哪些？

SQL标准定义了四种隔离级别，用以解决上述并发问题。隔离级别越高，数据一致性越好，但并发性能越差。

1.  读未提交 (Read Uncommitted):
    *   一个事务可以读取到其他事务未提交的变更。
    *   可能发生：脏读、不可重复读、幻读。

2.  读提交 (Read Committed):
    *   一个事务只能读取到其他事务已经提交的变更。
    *   可以避免脏读。
    *   可能发生：不可重复读、幻读。

3.  可重复读 (Repeatable Read):
    *   事务在执行过程中看到的数据，始终与事务启动时看到的数据一致。
    *   MySQL InnoDB引擎的默认隔离级别。
    *   可以避免：脏读、不可重复读。
    *   可能发生：幻读（理论上），但MySQL通过特定机制在很大程度上避免了。

4.  串行化 (Serializable):
    *   对记录加读写锁，强制事务串行执行。
    *   可以避免所有并发问题：脏读、不可重复读、幻读。
    *   性能最差，并发能力最低。

MySQL在可重复读隔离级别下，很大程度上避免了幻读问题，其解决方案是：
*   对于快照读 (普通 `SELECT` 语句)：通过MVCC实现。事务启动时生成的数据快照在整个事务期间保持一致，其他事务新插入的数据对当前事务不可见。
*   对于当前读 (`SELECT ... FOR UPDATE` 等语句)：通过 `next-key lock` (记录锁 + 间隙锁) 实现。这会锁定一个范围，阻止其他事务在该范围内插入新纪录，从而避免幻读。

#### Read View 在 MVCC 里如何工作的？

读提交和可重复读隔离级别都是通过MVCC机制和Read View（可以理解为数据快照）来实现的。

核心概念：

1.  Read View 的四个关键字段：
    *   `m_ids`: 创建Read View时，当前数据库中所有活跃事务（已启动但未提交）的ID列表。
    *   `min_trx_id`: `m_ids` 列表中的最小事务ID。
    *   `max_trx_id`: 创建Read View时，预计分配给下一个新事务的ID值（即当前最大事务ID + 1）。
    *   `creator_trx_id`: 创建该Read View的事务本身的ID。

2.  聚簇索引记录中的两个隐藏列：
    *   `trx_id`: 记录最后一次修改该行数据的事务ID。
    *   `roll_pointer`: 一个指针，指向该行数据的前一个版本（存储在undo log中），形成一个版本链。

数据可见性判断规则：
当一个事务访问某条记录时，会将记录的 `trx_id` 与当前事务的 Read View 进行比较：
*   如果 `trx_id` < `min_trx_id`：表示修改该记录的事务在当前事务创建Read View前就已提交，因此该版本记录可见。
*   如果 `trx_id` >= `max_trx_id`：表示修改该记录的事务在当前事务创建Read View后才启动，因此该版本记录不可见。
*   如果 `min_trx_id` <= `trx_id` < `max_trx_id`：
    *   若 `trx_id` 在 `m_ids` 列表中：表示修改该记录的事务在创建Read View时仍是活跃的（未提交），因此该版本记录不可见。
    *   若 `trx_id` 不在 `m_ids` 列表中：表示修改该记录的事务在创建Read View时已经提交，因此该版本记录可见。
如果一个版本不可见，事务会沿着 `roll_pointer` 指针去查找undo log中的上一个版本，并重复此判断过程，直到找到一个可见的版本。

#### 可重复读是如何工作的？

*   核心机制：在事务启动时创建唯一一个Read View，并在整个事务期间复用这个Read View。
*   工作流程：
    1.  事务A启动，创建自己的Read View。
    2.  事务B在事务A执行期间修改了某条数据并提交。
    3.  事务A再次读取该数据时，使用的仍然是启动时创建的那个Read View。
    4.  根据可见性判断规则，新修改数据的 `trx_id` (即事务B的ID) 对于事务A的Read View来说是不可见的（因为它要么在 `m_ids` 里，要么大于等于 `max_trx_id`）。
    5.  因此，事务A会沿着undo log链找到该数据在事务A启动前的那个版本，从而保证了多次读取结果的一致性。

#### 读提交是如何工作的？

*   核心机制：在事务中的每一次 `SELECT` 语句执行之前，都会重新创建一个新的Read View。
*   工作流程：
    1.  事务A启动，执行第一次查询，创建一个Read View，读取到数据。
    2.  事务B修改了该数据并提交。
    3.  事务A执行第二次查询，会创建一个全新的Read View。
    4.  此时，由于事务B已经提交，它的事务ID将不再是活跃事务，对于新创建的Read View来说，该ID会小于 `min_trx_id`。
    5.  因此，根据可见性判断规则，事务B所做的修改对事务A的这次查询是可见的。
    6.  这就导致了事务A在同一个事务中前后两次查询的结果不一致，即发生了不可重复读。
