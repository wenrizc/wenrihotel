

MySQL InnoDB 引擎的默认隔离级别是“可重复读”。

它在很大程度上避免了幻读现象，但并不能完全解决。

解决幻读的方案主要有两种：

1. 针对快照读 (普通 select 语句): 通过 MVCC (多版本并发控制) 方式解决。
    
2. 针对当前读 (如 select ... for update 语句): 通过 next-key lock (记录锁+间隙锁) 方式解决。
    

#### 幻读的定义

根据MySQL官方文档，幻读 (Phantom Read) 指的是：在同一个事务中，当同一个查询在不同的时间点执行时，产生了不同的结果集。

例如，一个查询第一次返回5条记录，但第二次执行时返回了6条记录，新多出来的那行数据就是“幻象”行。查询结果从5条变为4条也属于幻读。

#### 快照读如何避免幻读

1. 实现原理: MVCC (多版本并发控制)。
    
2. 工作方式: 当事务开启后（执行begin），在执行第一个查询语句时，会创建一个Read View（读视图）。
    
3. 效果: 之后该事务内所有的查询都将沿用这个Read View。通过这个Read View，事务只能在undo log版本链中找到符合其启动时版本的数据。
    
4. 结论: 即使中途有其他事务插入了新纪录并提交，本事务也查询不到这些新数据，因为看到的数据始终与事务启动时一致，从而避免了幻读。
    

#### 当前读如何避免幻读

1. 什么是当前读: 除了普通select是快照读，其他如 update、insert、delete 以及 select ... for update 都是当前读。它们在执行时总会读取最新的已提交数据。
    
2. 潜在问题: 如果当前读不加锁，就会读到其他事务新插入的记录，从而导致幻读。
    
3. 解决方案: InnoDB 引擎引入了间隙锁 (Gap Lock)。
    
4. 实现机制: 当前读执行时，会使用 next-key lock（记录锁和间隙锁的组合）。
    
5. 工作方式: 当事务A对某个范围（例如 id > 2）执行当前读时，会加上一个范围为 (2, +∞] 的 next-key lock。此时，如果事务B试图在这个范围内插入新记录（例如 id = 4），插入操作会被阻塞，直到事务A提交。
    
6. 结论: next-key lock阻止了新纪录的插入，有效防止了当前读场景下的幻读。
    

#### 幻读并未被完全解决

尽管有上述机制，可重复读隔离级别下，在某些特殊场景中，幻读依然会发生。

场景一：更新了“不存在”的记录

1. 事务A执行快照读 `select * from t_stu where id = 5;`，发现记录不存在。此时生成了一个Read View。
    
2. 事务B插入一条 `id = 5` 的记录，并提交事务。
    
3. 事务A执行 `update t_stu set name = '新名字' where id = 5;`。这是一个当前读操作，它能“看到”并更新事务B提交的记录。更新成功后，这条记录的隐藏列 `trx_id` 会变成事务A的事务ID。
    
4. 事务A再次执行 `select * from t_stu where id = 5;`。因为这条记录的 `trx_id` 已经属于当前事务A，所以它对A的Read View可见了。
    
5. 结果：事务A第一次查询无结果，第二次查询有结果，发生了幻读。
    

场景二：混合使用快照读与当前读

1. T1时刻：事务A执行快照读 `select * from t_test where id > 100;`，得到3条记录。
    
2. T2时刻：事务B插入一条 `id = 200` 的记录，并提交。
    
3. T3时刻：事务A再执行当前读 `select * from t_test where id > 100 for update;`。这个查询会读取最新数据，因此会查到4条记录（包括事务B新插入的）。
    
4. 结果：在事务A内部，两次查询的结果集不同，发生了幻读。
    