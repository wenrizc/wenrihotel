
1.  对索引使用左模糊或左右模糊匹配
    *   场景：`LIKE '%xx'` 或 `LIKE '%xx%'`。
    *   原因：索引 B+ 树是按照索引值从左到右有序排列的。如果查询条件的开头是通配符 `%`，数据库就不知道应该从 B+ 树的哪个位置开始查找，因此无法利用索引的有序性，只能进行全表扫描。
    *   例外：`LIKE 'xx%'`（右模糊匹配）是可以走索引的，因为查询的前缀是确定的，可以在 B+ 树中定位到起始范围。

2.  对索引列使用函数
    *   场景：`WHERE LENGTH(name) = 6`。
    *   原因：索引中存储的是字段的原始值，而不是经过函数计算后的值。数据库必须取出表中每一行的 `name` 值，应用 `LENGTH()` 函数计算后，再与 6 比较。这个过程无法利用索引，导致全表扫描。
    *   例外 (MySQL 8.0+)：可以使用函数索引。可以创建一个基于函数计算结果的索引，如 `ADD KEY idx_name_length ((length(name)))`。之后，使用 `WHERE length(name)=...` 的查询就可以利用这个新创建的函数索引。

3.  对索引列进行表达式计算
    *   场景：`WHERE id + 1 = 10`。
    *   原因：这和使用函数类似。索引保存的是 `id` 的原始值，而不是 `id + 1` 的计算结果。数据库无法直接使用索引定位，只能全表扫描并对每一行的 `id` 进行计算。
    *   解决方案：将表达式移到非索引列一侧。将查询改写为 `WHERE id = 10 - 1`。这样，数据库可以直接用计算出的结果 `9` 去索引中查找，从而有效利用索引。

4.  对索引列进行隐式类型转换
    *   场景：`phone` 字段是 `varchar` 字符串类型并建有索引，但查询条件写成 `WHERE phone = 1300000001` (数字类型)。
    *   原因：MySQL 在处理字符串和数字比较时，会将字符串自动转换为数字。因此，上述查询被 MySQL 内部转换为 `WHERE CAST(phone AS signed int) = 1300000001`。这相当于对索引列 `phone` 使用了 `CAST` 函数，从而导致索引失效。
    *   反例：如果 `id` 字段是 `int` 类型，查询 `WHERE id = '1'` (字符串类型) 是可以走索引的。因为此时 MySQL 会将输入参数 `'1'` 转换为数字，查询变为 `WHERE id = CAST('1' AS signed int)`，索引列 `id` 本身没有被函数包裹，索引依然有效。

5.  联合索引不遵循最左匹配原则
    *   概念：对于一个联合索引 `(a, b, c)`，它的排序规则是先按 `a` 排序，在 `a` 相同的情况下再按 `b` 排序，以此类推。因此，使用该索引必须遵循最左匹配原则。
    *   有效场景：`WHERE a=1`、`WHERE a=1 AND b=2`、`WHERE a=1 AND b=2 AND c=3`。
    *   失效场景：`WHERE b=2` 或 `WHERE c=3`。因为没有 `a` 作为起点，数据库不知道从何查起。
    *   特殊情况 (`WHERE a=1 AND c=3`)：
        *   MySQL 5.6 之前：索引会用到 `a` 部分，但 `c` 条件无法在索引层面过滤。数据库会找到所有 `a=1` 的记录并回表，然后在 Server 层再过滤 `c=3` 的数据。
        *   MySQL 5.6 及之后：引入了“索引下推” (Index Condition Pushdown)。存储引擎在扫描 `a=1` 的索引时，会同时判断索引中包含的 `c` 字段是否满足 `c=3` 的条件，直接在引擎层过滤掉不满足的记录，减少了回表的次数，提升了性能。

6.  WHERE 子句中使用 OR
    *   场景：`WHERE id = 1 OR age = 18`，其中 `id` 有索引，但 `age` 没有索引。
    *   原因：`OR` 条件意味着满足任意一个即可。因为对 `age` 的判断需要全表扫描，所以优化器会认为，与其分别查找再合并，不如直接进行一次全表扫描来判断两个条件。
    *   解决方案：为 `OR` 连接的每一个条件列都创建索引。如果 `id` 和 `age` 都有索引，优化器可能会采用 `index_merge` 策略，即分别扫描两个索引然后合并结果集，从而避免全表扫描。