
#### 全局锁

1. 使用方式
- 加锁命令: `flush tables with read lock`
- 效果: 执行后整个数据库处于只读状态。所有对数据的增删改（insert, delete, update）和对表结构的更改（alter table, drop table）操作都会被阻塞。
- 释放锁: 执行 `unlock tables` 命令，或者当执行加锁命令的会话断开连接时自动释放。

2. 应用场景
- 主要用于做全库逻辑备份。
- 目的: 保证在备份期间，数据和表结构不发生变化，从而确保备份数据的一致性。
- 反例（不加锁）: 备份过程中，若先备份了用户表，然后发生了用户购买操作（扣减了商品库存），再备份商品表。会导致备份文件中用户余额未扣，但商品库存已减，造成数据不一致。

3. 缺点与替代方案
- 缺点: 加全局锁导致数据库在备份期间完全只读，如果备份时间长，会造成业务长时间停滞。
- 替代方案: 对于支持可重复读隔离级别的事务型存储引擎（如InnoDB），可以使用 `mysqldump --single-transaction` 参数。
- 替代方案原理: 该命令在备份前开启一个事务，利用MVCC和Read View机制，保证备份期间读取到的是一个一致性的数据快照，同时业务的更新操作可以正常进行。
- 注意: 对于不支持事务的引擎（如MyISAM），仍然需要使用全局锁进行备份。

#### 表级锁

MySQL的表级锁主要有：表锁、元数据锁（MDL）、意向锁、AUTO-INC锁。

1. 表锁
- 命令:
  - 读锁（共享锁）: `lock tables 表名 read;`
  - 写锁（独占锁）: `lock tables 表名 write;`
- 效果:
  - 对某表加读锁后，本会话只能读该表，不能写该表，也不能访问其他任何表。其他会话可以读该表，但写操作会被阻塞。
  - 对某表加写锁后，本会话可以读写该表，但不能访问其他任何表。其他会话对该表的读写操作都会被阻塞。
- 释放锁: `unlock tables`（释放当前会话的所有表锁），或会话退出时自动释放。
- 建议: InnoDB引擎支持更细粒度的行级锁，应尽量避免使用颗粒度太大的表锁，以免影响并发性能。

2. 元数据锁 (MDL - MetaData Lock)
- 加锁方式: 自动加锁，无需显式调用。
  - 对表进行CRUD操作时，自动加MDL读锁。
  - 对表进行结构变更（DDL）时，自动加MDL写锁。
- 作用: 保证在对表进行CRUD时，表结构不会被其他线程修改。读锁与读锁兼容，读锁与写锁、写锁与写锁互斥。
- 释放时机: 事务提交后才释放。
- 潜在问题（长事务）:
  - 一个长事务持有MDL读锁未提交。
  - 另一个线程尝试修改表结构（申请MDL写锁），会被阻塞。
  - 由于申请MDL锁的操作会形成队列，且写锁优先级高于读锁，一旦有写锁在等待，后续所有对该表的CRUD请求（申请MDL读锁）都会被阻塞。
  - 这会导致大量请求堆积，可能耗尽数据库的线程资源。
- 解决方案: 在做表结构变更前，应检查并处理长事务（如kill掉）。

3. 意向锁 (Intention Lock)
- 类型:
  - 意向共享锁 (IS): 事务准备给某些行加共享锁（S锁）前，先在表上加此锁。
  - 意向独占锁 (IX): 事务准备给某些行加独占锁（X锁）前，先在表上加此锁。
- 作用: 意向锁是表级锁，其目的是为了快速判断表里是否有记录被加了行锁。
- 原理: 如果没有意向锁，当要给整个表加表锁时，需要遍历表中的每一行来确认有无行锁，效率很低。有了意向锁，只需检查表上是否存在意向锁，即可知道是否有行锁存在。
- 兼容性: 意向锁之间互相兼容。它们只与表锁（`lock tables ... read/write`）冲突，与行锁不冲突。

4. AUTO-INC 锁
- 作用: 用于实现`AUTO_INCREMENT`自增主键的分配。
- 旧机制: 一种特殊的表锁，在执行插入语句时持有，语句结束后立即释放（不是事务结束后）。这会阻塞其他事务的插入，影响并发。
- 新机制 (MySQL 5.1.22+): 引入一种轻量级锁。该锁只在分配自增值的瞬间持有，分配完毕后立即释放，无需等待插入语句执行完成。
- 控制参数 `innodb_autoinc_lock_mode`:
  - `0`: 采用旧的AUTO-INC表锁。
  - `1`(默认): 混合模式。普通insert用轻量级锁；批量insert（如`insert ... select`）用AUTO-INC表锁。
  - `2`: 全部采用轻量级锁，性能最高。
- `mode=2` 的主从复制问题:
  - 当 `binlog_format = statement` 时，并发插入可能导致主库生成的自增ID不连续。而从库是顺序执行SQL，生成的ID是连续的，从而造成主从数据不一致。
  - 解决方案: 将 `binlog_format` 设置为 `row`。Row格式记录的是行的实际变更内容（包含主库分配好的自增ID），可以保证主从数据一致。

#### 行级锁

InnoDB引擎支持行级锁，MyISAM不支持。

- 加锁方式（锁定读）:
  - 共享锁: `select ... lock in share mode;`
  - 独占锁: `select ... for update;`
- 注意: 锁定读必须在事务中进行，锁在事务提交后释放。

行级锁主要有三类：Record Lock, Gap Lock, Next-Key Lock。

1. Record Lock (记录锁)
- 定义: 仅仅锁定单条记录。
- 分类: 有S锁（共享）和X锁（独占）之分，遵循标准的读写锁兼容规则。

2. Gap Lock (间隙锁)
- 定义: 锁定一个范围（索引记录之间的间隙），但不包含记录本身。
- 存在级别: 可重复读、串行化隔离级别。
- 目的: 解决可重复读隔离级别下的幻读问题。通过锁定间隙，防止其他事务在此间隙插入新记录。
- 兼容性: 间隙锁之间互相兼容。一个事务持有的间隙锁不会阻塞另一个事务持有相同范围的间隙锁。

3. Next-Key Lock (临键锁)
- 定义: Record Lock + Gap Lock 的组合，即锁定一条记录以及该记录之前的间隙。
- 作用: 既能保护记录本身不被修改，又能阻止新纪录插入到其前方的间隙中。
- 兼容性: 由于包含了记录锁，所以两个事务不能同时获取相同范围的X型临键锁，因为记录锁部分会冲突。

4. 插入意向锁 (Insert Intention Lock)
- 定义: 它是一种特殊的间隙锁，但不是意向锁。
- 发生时机: 当一个事务尝试在某个已被其他事务加上间隙锁的区间内插入记录时，插入操作会被阻塞，并在此期间生成一个插入意向锁。
- 特点:
  - 表明有事务想要在某个点插入记录，但正处于等待状态。
  - 如果说间隙锁锁住的是一个“面”（区间），插入意向锁锁住的是一个“点”。
  - 它与持有该区间的间隙锁是不兼容的。