
### 一、计算机抽象的两个视角

1. **微观视角（状态机）**
    
    - 程序是一个状态机
    - 可以精确描述每条指令的执行

2. **宏观视角（抽象层）**
    
    - 计算机是多个抽象层的叠加
    - 每层都封装了特定的功能
    - 向上提供简化的接口


### 二、抽象层次的构成

从上到下分为以下几层：

| TRM    | 计算           | 内存申请             | 结束运行      | 打印信息               |
| ------ | -------------- | -------------------- | ------------- | ---------------------- |
| 运行环境   | -             | malloc()/free()     | -             | printf()              |
| AM API | -             | heap                | halt()        | putch()               |
| ISA接口  | 指令           | 物理内存地址空间         | nemu_trap指令 | I/O方式                |
| 硬件模块   | 处理器         | 物理内存             | Monitor       | 串口                   |
| 电路实现   | cpu_exec()    | pmem[]              | nemu_state    | serial_io_handler()    |

### 三、核心功能的抽象映射

1. **计算功能**

```
应用程序 -> 指令序列 -> CPU执行
```

2. **内存管理**

```
malloc/free -> heap API -> 物理地址空间 -> 物理内存 -> pmem[]
```

3. **程序控制**

```
程序结束 -> halt() -> nemu_trap指令 -> Monitor -> nemu_state
```

4. **信息输出**

```
printf() -> putch() -> I/O指令 -> 串口 -> serial_io_handler()
```

### 四、抽象层的意义

1. **实现分离**  
    - 同一功能可以有不同实现  
    - 例如处理器可以是：  
        - NEMU解释执行  
        - QEMU二进制翻译  
        - Verilog硬件实现  

2. **接口统一**  
    - ISA统一硬件接口  
    - AM统一软件接口  
    - 运行环境提供标准库  

3. **细节屏蔽**  
    - 上层不需要知道下层实现  
    - 便于跨平台开发  
    - 降低开发难度  

### 五、抽象层的优势

1. **模块化**  
    - 每层功能清晰  
    - 接口定义明确  
    - 便于维护和更新  

2. **可移植性**  
    - 只需修改底层实现  
    - 上层代码可以复用  
    - 跨平台开发更容易  

3. **开发效率**  
    - 降低认知负担  
    - 提高代码重用  
    - 便于团队协作